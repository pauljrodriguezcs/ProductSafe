
AddUser.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000cc  00800100  00001d42  00001dd6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001d42  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000856  008001cc  008001cc  00001ea2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001ea2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001ed4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000250  00000000  00000000  00001f14  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003ef7  00000000  00000000  00002164  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000122e  00000000  00000000  0000605b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000224f  00000000  00000000  00007289  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000600  00000000  00000000  000094d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000fd7  00000000  00000000  00009ad8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001e66  00000000  00000000  0000aaaf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000270  00000000  00000000  0000c915  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	35 c1       	rjmp	.+618    	; 0x26c <__ctors_end>
       2:	00 00       	nop
       4:	51 c1       	rjmp	.+674    	; 0x2a8 <__bad_interrupt>
       6:	00 00       	nop
       8:	4f c1       	rjmp	.+670    	; 0x2a8 <__bad_interrupt>
       a:	00 00       	nop
       c:	4d c1       	rjmp	.+666    	; 0x2a8 <__bad_interrupt>
       e:	00 00       	nop
      10:	4b c1       	rjmp	.+662    	; 0x2a8 <__bad_interrupt>
      12:	00 00       	nop
      14:	49 c1       	rjmp	.+658    	; 0x2a8 <__bad_interrupt>
      16:	00 00       	nop
      18:	47 c1       	rjmp	.+654    	; 0x2a8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	45 c1       	rjmp	.+650    	; 0x2a8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	43 c1       	rjmp	.+646    	; 0x2a8 <__bad_interrupt>
      22:	00 00       	nop
      24:	41 c1       	rjmp	.+642    	; 0x2a8 <__bad_interrupt>
      26:	00 00       	nop
      28:	3f c1       	rjmp	.+638    	; 0x2a8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	3d c1       	rjmp	.+634    	; 0x2a8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	3b c1       	rjmp	.+630    	; 0x2a8 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 0b 0b 	jmp	0x1616	; 0x1616 <__vector_13>
      38:	37 c1       	rjmp	.+622    	; 0x2a8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	35 c1       	rjmp	.+618    	; 0x2a8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	33 c1       	rjmp	.+614    	; 0x2a8 <__bad_interrupt>
      42:	00 00       	nop
      44:	31 c1       	rjmp	.+610    	; 0x2a8 <__bad_interrupt>
      46:	00 00       	nop
      48:	2f c1       	rjmp	.+606    	; 0x2a8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	2d c1       	rjmp	.+602    	; 0x2a8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	2b c1       	rjmp	.+598    	; 0x2a8 <__bad_interrupt>
      52:	00 00       	nop
      54:	29 c1       	rjmp	.+594    	; 0x2a8 <__bad_interrupt>
      56:	00 00       	nop
      58:	27 c1       	rjmp	.+590    	; 0x2a8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	25 c1       	rjmp	.+586    	; 0x2a8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	23 c1       	rjmp	.+582    	; 0x2a8 <__bad_interrupt>
      62:	00 00       	nop
      64:	21 c1       	rjmp	.+578    	; 0x2a8 <__bad_interrupt>
      66:	00 00       	nop
      68:	1f c1       	rjmp	.+574    	; 0x2a8 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	1d c1       	rjmp	.+570    	; 0x2a8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	1b c1       	rjmp	.+566    	; 0x2a8 <__bad_interrupt>
      72:	00 00       	nop
      74:	19 c1       	rjmp	.+562    	; 0x2a8 <__bad_interrupt>
      76:	00 00       	nop
      78:	17 c1       	rjmp	.+558    	; 0x2a8 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	15 c1       	rjmp	.+554    	; 0x2a8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	13 c1       	rjmp	.+550    	; 0x2a8 <__bad_interrupt>
      82:	00 00       	nop
      84:	11 c1       	rjmp	.+546    	; 0x2a8 <__bad_interrupt>
      86:	00 00       	nop
      88:	0f c1       	rjmp	.+542    	; 0x2a8 <__bad_interrupt>
	...

0000008c <CHARSET>:
      8c:	00 00 00 00 00 00 00 5f 00 00 00 07 00 07 00 14     ......._........
      9c:	7f 14 7f 14 24 2a 7f 2a 12 23 13 08 64 62 36 49     ....$*.*.#..db6I
      ac:	55 22 50 00 05 03 00 00 00 1c 22 41 00 00 41 22     U"P......."A..A"
      bc:	1c 00 14 08 3e 08 14 08 08 3e 08 08 00 50 30 00     ....>....>...P0.
      cc:	00 08 08 08 08 08 00 60 60 00 00 20 10 08 04 02     .......``.. ....
      dc:	3e 51 49 45 3e 00 42 7f 40 00 42 61 51 49 46 21     >QIE>.B.@.BaQIF!
      ec:	41 45 4b 31 18 14 12 7f 10 27 45 45 45 39 3c 4a     AEK1.....'EEE9<J
      fc:	49 49 30 01 71 09 05 03 36 49 49 49 36 06 49 49     II0.q...6III6.II
     10c:	29 1e 00 36 36 00 00 00 56 36 00 00 08 14 22 41     )..66...V6...."A
     11c:	00 14 14 14 14 14 00 41 22 14 08 02 01 51 09 06     .......A"....Q..
     12c:	32 49 79 41 3e 7e 11 11 11 7e 7f 49 49 49 36 3e     2IyA>~...~.III6>
     13c:	41 41 41 22 7f 41 41 22 1c 7f 49 49 49 41 7f 09     AAA".AA"..IIIA..
     14c:	09 09 01 3e 41 49 49 7a 7f 08 08 08 7f 00 41 7f     ...>AIIz......A.
     15c:	41 00 20 40 41 3f 01 7f 08 14 22 41 7f 40 40 40     A. @A?...."A.@@@
     16c:	40 7f 02 0c 02 7f 7f 04 08 10 7f 3e 41 41 41 3e     @..........>AAA>
     17c:	7f 09 09 09 06 3e 41 51 21 5e 7f 09 19 29 46 46     .....>AQ!^...)FF
     18c:	49 49 49 31 01 01 7f 01 01 3f 40 40 40 3f 1f 20     III1.....?@@@?. 
     19c:	40 20 1f 3f 40 38 40 3f 63 14 08 14 63 07 08 70     @ .?@8@?c...c..p
     1ac:	08 07 61 51 49 45 43 00 7f 41 41 00 02 04 08 10     ..aQIEC..AA.....
     1bc:	20 00 41 41 7f 00 04 02 01 02 04 40 40 40 40 40      .AA.......@@@@@
     1cc:	00 01 02 04 00 20 54 54 54 78 7f 48 44 44 38 38     ..... TTTx.HDD88
     1dc:	44 44 44 20 38 44 44 48 7f 38 54 54 54 18 08 7e     DDD 8DDH.8TTT..~
     1ec:	09 01 02 0c 52 52 52 3e 7f 08 04 04 78 00 44 7d     ....RRR>....x.D}
     1fc:	40 00 20 40 44 3d 00 7f 10 28 44 00 00 41 7f 40     @. @D=...(D..A.@
     20c:	00 7c 04 18 04 78 7c 08 04 04 78 38 44 44 44 38     .|...x|...x8DDD8
     21c:	7c 14 14 14 08 08 14 14 18 7c 7c 08 04 04 08 48     |........||....H
     22c:	54 54 54 20 04 3f 44 40 20 3c 40 40 20 7c 1c 20     TTT .?D@ <@@ |. 
     23c:	40 20 1c 3c 40 30 40 3c 44 28 10 28 44 0c 50 50     @ .<@0@<D(.(D.PP
     24c:	50 3c 44 64 54 4c 44 00 08 36 41 00 00 00 7f 00     P<DdTLD..6A.....
     25c:	00 00 41 36 08 00 10 08 08 10 08 00 00 00 00 00     ..A6............

0000026c <__ctors_end>:
     26c:	11 24       	eor	r1, r1
     26e:	1f be       	out	0x3f, r1	; 63
     270:	cf ef       	ldi	r28, 0xFF	; 255
     272:	d0 e4       	ldi	r29, 0x40	; 64
     274:	de bf       	out	0x3e, r29	; 62
     276:	cd bf       	out	0x3d, r28	; 61

00000278 <__do_copy_data>:
     278:	11 e0       	ldi	r17, 0x01	; 1
     27a:	a0 e0       	ldi	r26, 0x00	; 0
     27c:	b1 e0       	ldi	r27, 0x01	; 1
     27e:	e2 e4       	ldi	r30, 0x42	; 66
     280:	fd e1       	ldi	r31, 0x1D	; 29
     282:	00 e0       	ldi	r16, 0x00	; 0
     284:	0b bf       	out	0x3b, r16	; 59
     286:	02 c0       	rjmp	.+4      	; 0x28c <__do_copy_data+0x14>
     288:	07 90       	elpm	r0, Z+
     28a:	0d 92       	st	X+, r0
     28c:	ac 3c       	cpi	r26, 0xCC	; 204
     28e:	b1 07       	cpc	r27, r17
     290:	d9 f7       	brne	.-10     	; 0x288 <__do_copy_data+0x10>

00000292 <__do_clear_bss>:
     292:	2a e0       	ldi	r18, 0x0A	; 10
     294:	ac ec       	ldi	r26, 0xCC	; 204
     296:	b1 e0       	ldi	r27, 0x01	; 1
     298:	01 c0       	rjmp	.+2      	; 0x29c <.do_clear_bss_start>

0000029a <.do_clear_bss_loop>:
     29a:	1d 92       	st	X+, r1

0000029c <.do_clear_bss_start>:
     29c:	a2 32       	cpi	r26, 0x22	; 34
     29e:	b2 07       	cpc	r27, r18
     2a0:	e1 f7       	brne	.-8      	; 0x29a <.do_clear_bss_loop>
     2a2:	e9 d6       	rcall	.+3538   	; 0x1076 <main>
     2a4:	0c 94 9f 0e 	jmp	0x1d3e	; 0x1d3e <_exit>

000002a8 <__bad_interrupt>:
     2a8:	ab ce       	rjmp	.-682    	; 0x0 <__vectors>

000002aa <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     2aa:	cf 93       	push	r28
     2ac:	df 93       	push	r29
     2ae:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     2b0:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     2b4:	20 91 cc 01 	lds	r18, 0x01CC	; 0x8001cc <__data_end>
     2b8:	30 91 cd 01 	lds	r19, 0x01CD	; 0x8001cd <__data_end+0x1>
     2bc:	c9 01       	movw	r24, r18
     2be:	8c 0f       	add	r24, r28
     2c0:	9d 1f       	adc	r25, r29
     2c2:	8c 3d       	cpi	r24, 0xDC	; 220
     2c4:	45 e0       	ldi	r20, 0x05	; 5
     2c6:	94 07       	cpc	r25, r20
     2c8:	58 f4       	brcc	.+22     	; 0x2e0 <pvPortMalloc+0x36>
     2ca:	28 17       	cp	r18, r24
     2cc:	39 07       	cpc	r19, r25
     2ce:	58 f4       	brcc	.+22     	; 0x2e6 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     2d0:	e9 01       	movw	r28, r18
     2d2:	c2 53       	subi	r28, 0x32	; 50
     2d4:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
     2d6:	90 93 cd 01 	sts	0x01CD, r25	; 0x8001cd <__data_end+0x1>
     2da:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <__data_end>
     2de:	05 c0       	rjmp	.+10     	; 0x2ea <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     2e0:	c0 e0       	ldi	r28, 0x00	; 0
     2e2:	d0 e0       	ldi	r29, 0x00	; 0
     2e4:	02 c0       	rjmp	.+4      	; 0x2ea <pvPortMalloc+0x40>
     2e6:	c0 e0       	ldi	r28, 0x00	; 0
     2e8:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     2ea:	0e 94 38 0d 	call	0x1a70	; 0x1a70 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     2ee:	ce 01       	movw	r24, r28
     2f0:	df 91       	pop	r29
     2f2:	cf 91       	pop	r28
     2f4:	08 95       	ret

000002f6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     2f6:	08 95       	ret

000002f8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     2f8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     2fa:	03 96       	adiw	r24, 0x03	; 3
     2fc:	92 83       	std	Z+2, r25	; 0x02
     2fe:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     300:	2f ef       	ldi	r18, 0xFF	; 255
     302:	3f ef       	ldi	r19, 0xFF	; 255
     304:	34 83       	std	Z+4, r19	; 0x04
     306:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     308:	96 83       	std	Z+6, r25	; 0x06
     30a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     30c:	90 87       	std	Z+8, r25	; 0x08
     30e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     310:	10 82       	st	Z, r1
     312:	08 95       	ret

00000314 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     314:	fc 01       	movw	r30, r24
     316:	11 86       	std	Z+9, r1	; 0x09
     318:	10 86       	std	Z+8, r1	; 0x08
     31a:	08 95       	ret

0000031c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     31c:	cf 93       	push	r28
     31e:	df 93       	push	r29
     320:	fc 01       	movw	r30, r24
     322:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     324:	21 81       	ldd	r18, Z+1	; 0x01
     326:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     328:	e9 01       	movw	r28, r18
     32a:	8a 81       	ldd	r24, Y+2	; 0x02
     32c:	9b 81       	ldd	r25, Y+3	; 0x03
     32e:	13 96       	adiw	r26, 0x03	; 3
     330:	9c 93       	st	X, r25
     332:	8e 93       	st	-X, r24
     334:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     336:	81 81       	ldd	r24, Z+1	; 0x01
     338:	92 81       	ldd	r25, Z+2	; 0x02
     33a:	15 96       	adiw	r26, 0x05	; 5
     33c:	9c 93       	st	X, r25
     33e:	8e 93       	st	-X, r24
     340:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     342:	8a 81       	ldd	r24, Y+2	; 0x02
     344:	9b 81       	ldd	r25, Y+3	; 0x03
     346:	ec 01       	movw	r28, r24
     348:	7d 83       	std	Y+5, r23	; 0x05
     34a:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     34c:	e9 01       	movw	r28, r18
     34e:	7b 83       	std	Y+3, r23	; 0x03
     350:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     352:	72 83       	std	Z+2, r23	; 0x02
     354:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     356:	19 96       	adiw	r26, 0x09	; 9
     358:	fc 93       	st	X, r31
     35a:	ee 93       	st	-X, r30
     35c:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     35e:	80 81       	ld	r24, Z
     360:	8f 5f       	subi	r24, 0xFF	; 255
     362:	80 83       	st	Z, r24
}
     364:	df 91       	pop	r29
     366:	cf 91       	pop	r28
     368:	08 95       	ret

0000036a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     36a:	cf 93       	push	r28
     36c:	df 93       	push	r29
     36e:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     370:	48 81       	ld	r20, Y
     372:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     374:	4f 3f       	cpi	r20, 0xFF	; 255
     376:	2f ef       	ldi	r18, 0xFF	; 255
     378:	52 07       	cpc	r21, r18
     37a:	31 f4       	brne	.+12     	; 0x388 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     37c:	dc 01       	movw	r26, r24
     37e:	17 96       	adiw	r26, 0x07	; 7
     380:	ed 91       	ld	r30, X+
     382:	fc 91       	ld	r31, X
     384:	18 97       	sbiw	r26, 0x08	; 8
     386:	17 c0       	rjmp	.+46     	; 0x3b6 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     388:	fc 01       	movw	r30, r24
     38a:	33 96       	adiw	r30, 0x03	; 3
     38c:	dc 01       	movw	r26, r24
     38e:	15 96       	adiw	r26, 0x05	; 5
     390:	2d 91       	ld	r18, X+
     392:	3c 91       	ld	r19, X
     394:	16 97       	sbiw	r26, 0x06	; 6
     396:	d9 01       	movw	r26, r18
     398:	2d 91       	ld	r18, X+
     39a:	3c 91       	ld	r19, X
     39c:	42 17       	cp	r20, r18
     39e:	53 07       	cpc	r21, r19
     3a0:	50 f0       	brcs	.+20     	; 0x3b6 <vListInsert+0x4c>
     3a2:	02 80       	ldd	r0, Z+2	; 0x02
     3a4:	f3 81       	ldd	r31, Z+3	; 0x03
     3a6:	e0 2d       	mov	r30, r0
     3a8:	a2 81       	ldd	r26, Z+2	; 0x02
     3aa:	b3 81       	ldd	r27, Z+3	; 0x03
     3ac:	2d 91       	ld	r18, X+
     3ae:	3c 91       	ld	r19, X
     3b0:	42 17       	cp	r20, r18
     3b2:	53 07       	cpc	r21, r19
     3b4:	b0 f7       	brcc	.-20     	; 0x3a2 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     3b6:	a2 81       	ldd	r26, Z+2	; 0x02
     3b8:	b3 81       	ldd	r27, Z+3	; 0x03
     3ba:	bb 83       	std	Y+3, r27	; 0x03
     3bc:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     3be:	15 96       	adiw	r26, 0x05	; 5
     3c0:	dc 93       	st	X, r29
     3c2:	ce 93       	st	-X, r28
     3c4:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     3c6:	fd 83       	std	Y+5, r31	; 0x05
     3c8:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     3ca:	d3 83       	std	Z+3, r29	; 0x03
     3cc:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3ce:	99 87       	std	Y+9, r25	; 0x09
     3d0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     3d2:	fc 01       	movw	r30, r24
     3d4:	20 81       	ld	r18, Z
     3d6:	2f 5f       	subi	r18, 0xFF	; 255
     3d8:	20 83       	st	Z, r18
}
     3da:	df 91       	pop	r29
     3dc:	cf 91       	pop	r28
     3de:	08 95       	ret

000003e0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     3e0:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     3e2:	a2 81       	ldd	r26, Z+2	; 0x02
     3e4:	b3 81       	ldd	r27, Z+3	; 0x03
     3e6:	84 81       	ldd	r24, Z+4	; 0x04
     3e8:	95 81       	ldd	r25, Z+5	; 0x05
     3ea:	15 96       	adiw	r26, 0x05	; 5
     3ec:	9c 93       	st	X, r25
     3ee:	8e 93       	st	-X, r24
     3f0:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     3f2:	a4 81       	ldd	r26, Z+4	; 0x04
     3f4:	b5 81       	ldd	r27, Z+5	; 0x05
     3f6:	82 81       	ldd	r24, Z+2	; 0x02
     3f8:	93 81       	ldd	r25, Z+3	; 0x03
     3fa:	13 96       	adiw	r26, 0x03	; 3
     3fc:	9c 93       	st	X, r25
     3fe:	8e 93       	st	-X, r24
     400:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     402:	a0 85       	ldd	r26, Z+8	; 0x08
     404:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     406:	11 96       	adiw	r26, 0x01	; 1
     408:	8d 91       	ld	r24, X+
     40a:	9c 91       	ld	r25, X
     40c:	12 97       	sbiw	r26, 0x02	; 2
     40e:	e8 17       	cp	r30, r24
     410:	f9 07       	cpc	r31, r25
     412:	31 f4       	brne	.+12     	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     414:	84 81       	ldd	r24, Z+4	; 0x04
     416:	95 81       	ldd	r25, Z+5	; 0x05
     418:	12 96       	adiw	r26, 0x02	; 2
     41a:	9c 93       	st	X, r25
     41c:	8e 93       	st	-X, r24
     41e:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     420:	11 86       	std	Z+9, r1	; 0x09
     422:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     424:	8c 91       	ld	r24, X
     426:	81 50       	subi	r24, 0x01	; 1
     428:	8c 93       	st	X, r24
     42a:	08 95       	ret

0000042c <GetKeypadKey>:
//Parameter: None
//Returns: A keypad button press else '\0'
unsigned char GetKeypadKey() {

	// Check keys in col 1
	KEYPADPORT = 0xFE; // Set Px0 to 0; others 1
     42c:	8e ef       	ldi	r24, 0xFE	; 254
     42e:	88 b9       	out	0x08, r24	; 8
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
     430:	00 00       	nop
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '1'; }
     432:	86 b1       	in	r24, 0x06	; 6
     434:	80 95       	com	r24
     436:	84 fd       	sbrc	r24, 4
     438:	46 c0       	rjmp	.+140    	; 0x4c6 <GetKeypadKey+0x9a>
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '4'; }
     43a:	86 b1       	in	r24, 0x06	; 6
     43c:	80 95       	com	r24
     43e:	85 fd       	sbrc	r24, 5
     440:	44 c0       	rjmp	.+136    	; 0x4ca <GetKeypadKey+0x9e>
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '7'; }
     442:	86 b1       	in	r24, 0x06	; 6
     444:	80 95       	com	r24
     446:	86 fd       	sbrc	r24, 6
     448:	42 c0       	rjmp	.+132    	; 0x4ce <GetKeypadKey+0xa2>
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '*'; }
     44a:	86 b1       	in	r24, 0x06	; 6
     44c:	80 95       	com	r24
     44e:	90 e0       	ldi	r25, 0x00	; 0
     450:	88 0f       	add	r24, r24
     452:	89 2f       	mov	r24, r25
     454:	88 1f       	adc	r24, r24
     456:	99 0b       	sbc	r25, r25
     458:	91 95       	neg	r25
     45a:	89 2b       	or	r24, r25
     45c:	d1 f5       	brne	.+116    	; 0x4d2 <GetKeypadKey+0xa6>

	// Check keys in col 2
	KEYPADPORT = 0xFD;; // Set Px1 to 0; others 1
     45e:	8d ef       	ldi	r24, 0xFD	; 253
     460:	88 b9       	out	0x08, r24	; 8
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
     462:	00 00       	nop
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '2'; }
     464:	86 b1       	in	r24, 0x06	; 6
     466:	80 95       	com	r24
     468:	84 fd       	sbrc	r24, 4
     46a:	35 c0       	rjmp	.+106    	; 0x4d6 <GetKeypadKey+0xaa>
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '5'; }
     46c:	86 b1       	in	r24, 0x06	; 6
     46e:	80 95       	com	r24
     470:	85 fd       	sbrc	r24, 5
     472:	33 c0       	rjmp	.+102    	; 0x4da <GetKeypadKey+0xae>
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '8'; }
     474:	86 b1       	in	r24, 0x06	; 6
     476:	80 95       	com	r24
     478:	86 fd       	sbrc	r24, 6
     47a:	31 c0       	rjmp	.+98     	; 0x4de <GetKeypadKey+0xb2>
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '0'; }
     47c:	86 b1       	in	r24, 0x06	; 6
     47e:	80 95       	com	r24
     480:	90 e0       	ldi	r25, 0x00	; 0
     482:	88 0f       	add	r24, r24
     484:	89 2f       	mov	r24, r25
     486:	88 1f       	adc	r24, r24
     488:	99 0b       	sbc	r25, r25
     48a:	91 95       	neg	r25
     48c:	89 2b       	or	r24, r25
     48e:	49 f5       	brne	.+82     	; 0x4e2 <GetKeypadKey+0xb6>

	// Check keys in col 3
	KEYPADPORT = 0xFB;; // Set Px2 to 0; others 1
     490:	8b ef       	ldi	r24, 0xFB	; 251
     492:	88 b9       	out	0x08, r24	; 8
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
     494:	00 00       	nop
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '3'; }
     496:	86 b1       	in	r24, 0x06	; 6
     498:	80 95       	com	r24
     49a:	84 fd       	sbrc	r24, 4
     49c:	24 c0       	rjmp	.+72     	; 0x4e6 <GetKeypadKey+0xba>
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '6'; }
     49e:	86 b1       	in	r24, 0x06	; 6
     4a0:	80 95       	com	r24
     4a2:	85 fd       	sbrc	r24, 5
     4a4:	22 c0       	rjmp	.+68     	; 0x4ea <GetKeypadKey+0xbe>
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '9'; }
     4a6:	86 b1       	in	r24, 0x06	; 6
     4a8:	80 95       	com	r24
     4aa:	86 fd       	sbrc	r24, 6
     4ac:	20 c0       	rjmp	.+64     	; 0x4ee <GetKeypadKey+0xc2>
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '#'; }
     4ae:	86 b1       	in	r24, 0x06	; 6
     4b0:	80 95       	com	r24
     4b2:	90 e0       	ldi	r25, 0x00	; 0
     4b4:	88 0f       	add	r24, r24
     4b6:	89 2f       	mov	r24, r25
     4b8:	88 1f       	adc	r24, r24
     4ba:	99 0b       	sbc	r25, r25
     4bc:	91 95       	neg	r25
     4be:	89 2b       	or	r24, r25
     4c0:	c1 f4       	brne	.+48     	; 0x4f2 <GetKeypadKey+0xc6>
	
	return '\0';
     4c2:	80 e0       	ldi	r24, 0x00	; 0
     4c4:	08 95       	ret
unsigned char GetKeypadKey() {

	// Check keys in col 1
	KEYPADPORT = 0xFE; // Set Px0 to 0; others 1
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '1'; }
     4c6:	81 e3       	ldi	r24, 0x31	; 49
     4c8:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '4'; }
     4ca:	84 e3       	ldi	r24, 0x34	; 52
     4cc:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '7'; }
     4ce:	87 e3       	ldi	r24, 0x37	; 55
     4d0:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '*'; }
     4d2:	8a e2       	ldi	r24, 0x2A	; 42
     4d4:	08 95       	ret

	// Check keys in col 2
	KEYPADPORT = 0xFD;; // Set Px1 to 0; others 1
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '2'; }
     4d6:	82 e3       	ldi	r24, 0x32	; 50
     4d8:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '5'; }
     4da:	85 e3       	ldi	r24, 0x35	; 53
     4dc:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '8'; }
     4de:	88 e3       	ldi	r24, 0x38	; 56
     4e0:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '0'; }
     4e2:	80 e3       	ldi	r24, 0x30	; 48
     4e4:	08 95       	ret

	// Check keys in col 3
	KEYPADPORT = 0xFB;; // Set Px2 to 0; others 1
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '3'; }
     4e6:	83 e3       	ldi	r24, 0x33	; 51
     4e8:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '6'; }
     4ea:	86 e3       	ldi	r24, 0x36	; 54
     4ec:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '9'; }
     4ee:	89 e3       	ldi	r24, 0x39	; 57
     4f0:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '#'; }
     4f2:	83 e2       	ldi	r24, 0x23	; 35
	
	return '\0';
}
     4f4:	08 95       	ret

000004f6 <AlphaNumPad>:
unsigned long auto_timer = 0;

unsigned char testing_flag = 0;

unsigned char AlphaNumPad(){
	while((pushed_key_ANP = GetKeypadKey()) == '\0'){
     4f6:	2f c0       	rjmp	.+94     	; 0x556 <AlphaNumPad+0x60>
		if(auto_timer == 50){
     4f8:	40 91 c4 07 	lds	r20, 0x07C4	; 0x8007c4 <auto_timer>
     4fc:	50 91 c5 07 	lds	r21, 0x07C5	; 0x8007c5 <auto_timer+0x1>
     500:	60 91 c6 07 	lds	r22, 0x07C6	; 0x8007c6 <auto_timer+0x2>
     504:	70 91 c7 07 	lds	r23, 0x07C7	; 0x8007c7 <auto_timer+0x3>
     508:	42 33       	cpi	r20, 0x32	; 50
     50a:	51 05       	cpc	r21, r1
     50c:	61 05       	cpc	r22, r1
     50e:	71 05       	cpc	r23, r1
     510:	49 f4       	brne	.+18     	; 0x524 <AlphaNumPad+0x2e>
			auto_timer = 0;
     512:	10 92 c4 07 	sts	0x07C4, r1	; 0x8007c4 <auto_timer>
     516:	10 92 c5 07 	sts	0x07C5, r1	; 0x8007c5 <auto_timer+0x1>
     51a:	10 92 c6 07 	sts	0x07C6, r1	; 0x8007c6 <auto_timer+0x2>
     51e:	10 92 c7 07 	sts	0x07C7, r1	; 0x8007c7 <auto_timer+0x3>
			return '\0';
     522:	08 95       	ret
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     524:	87 ea       	ldi	r24, 0xA7	; 167
     526:	91 e6       	ldi	r25, 0x61	; 97
     528:	01 97       	sbiw	r24, 0x01	; 1
     52a:	f1 f7       	brne	.-4      	; 0x528 <AlphaNumPad+0x32>
     52c:	00 c0       	rjmp	.+0      	; 0x52e <AlphaNumPad+0x38>
     52e:	00 00       	nop
		}
		
		_delay_ms(100);
		++auto_timer;
     530:	80 91 c4 07 	lds	r24, 0x07C4	; 0x8007c4 <auto_timer>
     534:	90 91 c5 07 	lds	r25, 0x07C5	; 0x8007c5 <auto_timer+0x1>
     538:	a0 91 c6 07 	lds	r26, 0x07C6	; 0x8007c6 <auto_timer+0x2>
     53c:	b0 91 c7 07 	lds	r27, 0x07C7	; 0x8007c7 <auto_timer+0x3>
     540:	01 96       	adiw	r24, 0x01	; 1
     542:	a1 1d       	adc	r26, r1
     544:	b1 1d       	adc	r27, r1
     546:	80 93 c4 07 	sts	0x07C4, r24	; 0x8007c4 <auto_timer>
     54a:	90 93 c5 07 	sts	0x07C5, r25	; 0x8007c5 <auto_timer+0x1>
     54e:	a0 93 c6 07 	sts	0x07C6, r26	; 0x8007c6 <auto_timer+0x2>
     552:	b0 93 c7 07 	sts	0x07C7, r27	; 0x8007c7 <auto_timer+0x3>
unsigned long auto_timer = 0;

unsigned char testing_flag = 0;

unsigned char AlphaNumPad(){
	while((pushed_key_ANP = GetKeypadKey()) == '\0'){
     556:	6a df       	rcall	.-300    	; 0x42c <GetKeypadKey>
     558:	80 93 20 0a 	sts	0x0A20, r24	; 0x800a20 <pushed_key_ANP>
     55c:	88 23       	and	r24, r24
     55e:	61 f2       	breq	.-104    	; 0x4f8 <AlphaNumPad+0x2>
		
		_delay_ms(100);
		++auto_timer;
	}
	
	while((tmp_pressed_key = GetKeypadKey()) == pushed_key_ANP){}
     560:	65 df       	rcall	.-310    	; 0x42c <GetKeypadKey>
     562:	80 93 21 0a 	sts	0x0A21, r24	; 0x800a21 <tmp_pressed_key>
     566:	90 91 20 0a 	lds	r25, 0x0A20	; 0x800a20 <pushed_key_ANP>
     56a:	89 17       	cp	r24, r25
     56c:	c9 f3       	breq	.-14     	; 0x560 <AlphaNumPad+0x6a>
     56e:	10 92 c4 07 	sts	0x07C4, r1	; 0x8007c4 <auto_timer>
	
	auto_timer = 0;
     572:	10 92 c5 07 	sts	0x07C5, r1	; 0x8007c5 <auto_timer+0x1>
     576:	10 92 c6 07 	sts	0x07C6, r1	; 0x8007c6 <auto_timer+0x2>
     57a:	10 92 c7 07 	sts	0x07C7, r1	; 0x8007c7 <auto_timer+0x3>
     57e:	80 91 ca 07 	lds	r24, 0x07CA	; 0x8007ca <previous_key_ANP>
	
	if(previous_key_ANP == pushed_key_ANP){
     582:	98 13       	cpse	r25, r24
     584:	8a c0       	rjmp	.+276    	; 0x69a <AlphaNumPad+0x1a4>
     586:	20 91 c8 07 	lds	r18, 0x07C8	; 0x8007c8 <num_times_key_pushed>
		if(num_times_key_pushed < 3){
     58a:	30 91 c9 07 	lds	r19, 0x07C9	; 0x8007c9 <num_times_key_pushed+0x1>
     58e:	23 30       	cpi	r18, 0x03	; 3
     590:	31 05       	cpc	r19, r1
     592:	38 f4       	brcc	.+14     	; 0x5a2 <AlphaNumPad+0xac>
     594:	2f 5f       	subi	r18, 0xFF	; 255
			num_times_key_pushed++;
     596:	3f 4f       	sbci	r19, 0xFF	; 255
     598:	30 93 c9 07 	sts	0x07C9, r19	; 0x8007c9 <num_times_key_pushed+0x1>
     59c:	20 93 c8 07 	sts	0x07C8, r18	; 0x8007c8 <num_times_key_pushed>
     5a0:	04 c0       	rjmp	.+8      	; 0x5aa <AlphaNumPad+0xb4>
     5a2:	10 92 c9 07 	sts	0x07C9, r1	; 0x8007c9 <num_times_key_pushed+0x1>
		}
		
		else{
			num_times_key_pushed = 0;
     5a6:	10 92 c8 07 	sts	0x07C8, r1	; 0x8007c8 <num_times_key_pushed>
     5aa:	81 33       	cpi	r24, 0x31	; 49
		}
		
		if(pushed_key_ANP == '1'){ return one[num_times_key_pushed]; }
     5ac:	41 f4       	brne	.+16     	; 0x5be <AlphaNumPad+0xc8>
     5ae:	e0 91 c8 07 	lds	r30, 0x07C8	; 0x8007c8 <num_times_key_pushed>
     5b2:	f0 91 c9 07 	lds	r31, 0x07C9	; 0x8007c9 <num_times_key_pushed+0x1>
     5b6:	e1 5c       	subi	r30, 0xC1	; 193
     5b8:	fe 4f       	sbci	r31, 0xFE	; 254
     5ba:	80 81       	ld	r24, Z
     5bc:	08 95       	ret
     5be:	82 33       	cpi	r24, 0x32	; 50
		else if(pushed_key_ANP == '2'){ return (two[num_times_key_pushed]); }
     5c0:	41 f4       	brne	.+16     	; 0x5d2 <AlphaNumPad+0xdc>
     5c2:	e0 91 c8 07 	lds	r30, 0x07C8	; 0x8007c8 <num_times_key_pushed>
     5c6:	f0 91 c9 07 	lds	r31, 0x07C9	; 0x8007c9 <num_times_key_pushed+0x1>
     5ca:	e5 5c       	subi	r30, 0xC5	; 197
     5cc:	fe 4f       	sbci	r31, 0xFE	; 254
     5ce:	80 81       	ld	r24, Z
     5d0:	08 95       	ret
     5d2:	83 33       	cpi	r24, 0x33	; 51
		else if(pushed_key_ANP == '3'){ return (three[num_times_key_pushed]); }
     5d4:	41 f4       	brne	.+16     	; 0x5e6 <AlphaNumPad+0xf0>
     5d6:	e0 91 c8 07 	lds	r30, 0x07C8	; 0x8007c8 <num_times_key_pushed>
     5da:	f0 91 c9 07 	lds	r31, 0x07C9	; 0x8007c9 <num_times_key_pushed+0x1>
     5de:	e9 5c       	subi	r30, 0xC9	; 201
     5e0:	fe 4f       	sbci	r31, 0xFE	; 254
     5e2:	80 81       	ld	r24, Z
     5e4:	08 95       	ret
     5e6:	84 33       	cpi	r24, 0x34	; 52
		else if(pushed_key_ANP == '4'){ return (four[num_times_key_pushed]); }
     5e8:	41 f4       	brne	.+16     	; 0x5fa <AlphaNumPad+0x104>
     5ea:	e0 91 c8 07 	lds	r30, 0x07C8	; 0x8007c8 <num_times_key_pushed>
     5ee:	f0 91 c9 07 	lds	r31, 0x07C9	; 0x8007c9 <num_times_key_pushed+0x1>
     5f2:	ed 5c       	subi	r30, 0xCD	; 205
     5f4:	fe 4f       	sbci	r31, 0xFE	; 254
     5f6:	80 81       	ld	r24, Z
     5f8:	08 95       	ret
     5fa:	85 33       	cpi	r24, 0x35	; 53
		else if(pushed_key_ANP == '5'){ return (five[num_times_key_pushed]); }
     5fc:	41 f4       	brne	.+16     	; 0x60e <AlphaNumPad+0x118>
     5fe:	e0 91 c8 07 	lds	r30, 0x07C8	; 0x8007c8 <num_times_key_pushed>
     602:	f0 91 c9 07 	lds	r31, 0x07C9	; 0x8007c9 <num_times_key_pushed+0x1>
     606:	e1 5d       	subi	r30, 0xD1	; 209
     608:	fe 4f       	sbci	r31, 0xFE	; 254
     60a:	80 81       	ld	r24, Z
     60c:	08 95       	ret
     60e:	86 33       	cpi	r24, 0x36	; 54
		else if(pushed_key_ANP == '6'){ return (six[num_times_key_pushed]); }
     610:	41 f4       	brne	.+16     	; 0x622 <AlphaNumPad+0x12c>
     612:	e0 91 c8 07 	lds	r30, 0x07C8	; 0x8007c8 <num_times_key_pushed>
     616:	f0 91 c9 07 	lds	r31, 0x07C9	; 0x8007c9 <num_times_key_pushed+0x1>
     61a:	e5 5d       	subi	r30, 0xD5	; 213
     61c:	fe 4f       	sbci	r31, 0xFE	; 254
     61e:	80 81       	ld	r24, Z
     620:	08 95       	ret
     622:	87 33       	cpi	r24, 0x37	; 55
		else if(pushed_key_ANP == '7'){ return (seven[num_times_key_pushed]); }
     624:	41 f4       	brne	.+16     	; 0x636 <AlphaNumPad+0x140>
     626:	e0 91 c8 07 	lds	r30, 0x07C8	; 0x8007c8 <num_times_key_pushed>
     62a:	f0 91 c9 07 	lds	r31, 0x07C9	; 0x8007c9 <num_times_key_pushed+0x1>
     62e:	e9 5d       	subi	r30, 0xD9	; 217
     630:	fe 4f       	sbci	r31, 0xFE	; 254
     632:	80 81       	ld	r24, Z
     634:	08 95       	ret
     636:	88 33       	cpi	r24, 0x38	; 56
		else if(pushed_key_ANP == '8'){ return (eight[num_times_key_pushed]); }
     638:	41 f4       	brne	.+16     	; 0x64a <AlphaNumPad+0x154>
     63a:	e0 91 c8 07 	lds	r30, 0x07C8	; 0x8007c8 <num_times_key_pushed>
     63e:	f0 91 c9 07 	lds	r31, 0x07C9	; 0x8007c9 <num_times_key_pushed+0x1>
     642:	ed 5d       	subi	r30, 0xDD	; 221
     644:	fe 4f       	sbci	r31, 0xFE	; 254
     646:	80 81       	ld	r24, Z
     648:	08 95       	ret
     64a:	89 33       	cpi	r24, 0x39	; 57
		else if(pushed_key_ANP == '9'){ return (nine[num_times_key_pushed]); }
     64c:	41 f4       	brne	.+16     	; 0x65e <AlphaNumPad+0x168>
     64e:	e0 91 c8 07 	lds	r30, 0x07C8	; 0x8007c8 <num_times_key_pushed>
     652:	f0 91 c9 07 	lds	r31, 0x07C9	; 0x8007c9 <num_times_key_pushed+0x1>
     656:	e1 5e       	subi	r30, 0xE1	; 225
     658:	fe 4f       	sbci	r31, 0xFE	; 254
     65a:	80 81       	ld	r24, Z
     65c:	08 95       	ret
     65e:	80 33       	cpi	r24, 0x30	; 48
		else if(pushed_key_ANP == '0'){return (zero[num_times_key_pushed]); }
     660:	41 f4       	brne	.+16     	; 0x672 <AlphaNumPad+0x17c>
     662:	e0 91 c8 07 	lds	r30, 0x07C8	; 0x8007c8 <num_times_key_pushed>
     666:	f0 91 c9 07 	lds	r31, 0x07C9	; 0x8007c9 <num_times_key_pushed+0x1>
     66a:	e5 5e       	subi	r30, 0xE5	; 229
     66c:	fe 4f       	sbci	r31, 0xFE	; 254
     66e:	80 81       	ld	r24, Z
     670:	08 95       	ret
     672:	8a 32       	cpi	r24, 0x2A	; 42
		else if(pushed_key_ANP == '*'){return (star[num_times_key_pushed]); }
     674:	41 f4       	brne	.+16     	; 0x686 <AlphaNumPad+0x190>
     676:	e0 91 c8 07 	lds	r30, 0x07C8	; 0x8007c8 <num_times_key_pushed>
     67a:	f0 91 c9 07 	lds	r31, 0x07C9	; 0x8007c9 <num_times_key_pushed+0x1>
     67e:	e9 5e       	subi	r30, 0xE9	; 233
     680:	fe 4f       	sbci	r31, 0xFE	; 254
     682:	80 81       	ld	r24, Z
     684:	08 95       	ret
     686:	83 32       	cpi	r24, 0x23	; 35
		else if(pushed_key_ANP == '#'){return (pound[num_times_key_pushed]); }
     688:	71 f4       	brne	.+28     	; 0x6a6 <AlphaNumPad+0x1b0>
     68a:	e0 91 c8 07 	lds	r30, 0x07C8	; 0x8007c8 <num_times_key_pushed>
     68e:	f0 91 c9 07 	lds	r31, 0x07C9	; 0x8007c9 <num_times_key_pushed+0x1>
     692:	ed 5e       	subi	r30, 0xED	; 237
     694:	fe 4f       	sbci	r31, 0xFE	; 254
     696:	80 81       	ld	r24, Z
     698:	08 95       	ret
     69a:	90 93 ca 07 	sts	0x07CA, r25	; 0x8007ca <previous_key_ANP>
		
	}
	
	else{
		previous_key_ANP = pushed_key_ANP;
     69e:	10 92 c9 07 	sts	0x07C9, r1	; 0x8007c9 <num_times_key_pushed+0x1>
		num_times_key_pushed = 0;
     6a2:	10 92 c8 07 	sts	0x07C8, r1	; 0x8007c8 <num_times_key_pushed>
     6a6:	80 91 ca 07 	lds	r24, 0x07CA	; 0x8007ca <previous_key_ANP>
	}
	
	return previous_key_ANP;
     6aa:	08 95       	ret

000006ac <adduser_name_display>:
}
     6ac:	cf 93       	push	r28

////////// End of helper function that returns Numeric & AlphaNumeric Values //////////


void adduser_name_display(const char* str){
     6ae:	df 93       	push	r29
     6b0:	ec 01       	movw	r28, r24
	nokia_lcd_clear();
     6b2:	46 d5       	rcall	.+2700   	; 0x1140 <nokia_lcd_clear>
	nokia_lcd_write_string("Enter Name",1);
     6b4:	61 e0       	ldi	r22, 0x01	; 1
     6b6:	85 e4       	ldi	r24, 0x45	; 69
     6b8:	91 e0       	ldi	r25, 0x01	; 1
     6ba:	28 d6       	rcall	.+3152   	; 0x130c <nokia_lcd_write_string>
	nokia_lcd_set_cursor(0,10);
     6bc:	6a e0       	ldi	r22, 0x0A	; 10
     6be:	80 e0       	ldi	r24, 0x00	; 0
     6c0:	37 d6       	rcall	.+3182   	; 0x1330 <nokia_lcd_set_cursor>
	nokia_lcd_write_string(str,1);
     6c2:	61 e0       	ldi	r22, 0x01	; 1
     6c4:	ce 01       	movw	r24, r28
     6c6:	22 d6       	rcall	.+3140   	; 0x130c <nokia_lcd_write_string>
	nokia_lcd_render();
     6c8:	38 d6       	rcall	.+3184   	; 0x133a <nokia_lcd_render>
     6ca:	df 91       	pop	r29
}
     6cc:	cf 91       	pop	r28
     6ce:	08 95       	ret

000006d0 <password_verification>:
     6d0:	90 91 b8 07 	lds	r25, 0x07B8	; 0x8007b8 <user_password>
unsigned char previous_character = '\0';
unsigned char password_attempt_fails = 0;

unsigned char password_verification(){
	for(unsigned char i = 0; i < 8; ++i){
		if(user_password[i] != user_compare_password[i]){
     6d4:	80 91 af 07 	lds	r24, 0x07AF	; 0x8007af <user_compare_password>
     6d8:	98 13       	cpse	r25, r24
     6da:	0f c0       	rjmp	.+30     	; 0x6fa <password_verification+0x2a>
     6dc:	e9 eb       	ldi	r30, 0xB9	; 185
     6de:	f7 e0       	ldi	r31, 0x07	; 7
     6e0:	a0 eb       	ldi	r26, 0xB0	; 176
     6e2:	b7 e0       	ldi	r27, 0x07	; 7
     6e4:	20 ec       	ldi	r18, 0xC0	; 192
     6e6:	37 e0       	ldi	r19, 0x07	; 7
     6e8:	91 91       	ld	r25, Z+
     6ea:	8d 91       	ld	r24, X+
     6ec:	98 13       	cpse	r25, r24
     6ee:	07 c0       	rjmp	.+14     	; 0x6fe <password_verification+0x2e>
unsigned char keypad_character = '\0';
unsigned char previous_character = '\0';
unsigned char password_attempt_fails = 0;

unsigned char password_verification(){
	for(unsigned char i = 0; i < 8; ++i){
     6f0:	e2 17       	cp	r30, r18
     6f2:	f3 07       	cpc	r31, r19
     6f4:	c9 f7       	brne	.-14     	; 0x6e8 <password_verification+0x18>
		if(user_password[i] != user_compare_password[i]){
			return 0;
		}
	}
	
	return 1;
     6f6:	81 e0       	ldi	r24, 0x01	; 1
     6f8:	08 95       	ret
unsigned char password_attempt_fails = 0;

unsigned char password_verification(){
	for(unsigned char i = 0; i < 8; ++i){
		if(user_password[i] != user_compare_password[i]){
			return 0;
     6fa:	80 e0       	ldi	r24, 0x00	; 0
     6fc:	08 95       	ret
     6fe:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	
	return 1;
}
     700:	08 95       	ret

00000702 <AddUser_Init>:
void AddUser_Init(){
	nokia_lcd_clear();
     702:	1e d5       	rcall	.+2620   	; 0x1140 <nokia_lcd_clear>
	nokia_lcd_write_string("Enter Name",1);
     704:	61 e0       	ldi	r22, 0x01	; 1
     706:	85 e4       	ldi	r24, 0x45	; 69
     708:	91 e0       	ldi	r25, 0x01	; 1
     70a:	00 d6       	rcall	.+3072   	; 0x130c <nokia_lcd_write_string>
	nokia_lcd_set_cursor(0,10);
     70c:	6a e0       	ldi	r22, 0x0A	; 10
     70e:	80 e0       	ldi	r24, 0x00	; 0
     710:	0f d6       	rcall	.+3102   	; 0x1330 <nokia_lcd_set_cursor>
	nokia_lcd_write_string(user_name,1);
     712:	61 e0       	ldi	r22, 0x01	; 1
     714:	85 e0       	ldi	r24, 0x05	; 5
     716:	91 e0       	ldi	r25, 0x01	; 1
	nokia_lcd_render();
     718:	f9 d5       	rcall	.+3058   	; 0x130c <nokia_lcd_write_string>
     71a:	0f d6       	rcall	.+3102   	; 0x133a <nokia_lcd_render>
	adduser_state = username;
     71c:	10 92 1f 0a 	sts	0x0A1F, r1	; 0x800a1f <adduser_state>
     720:	08 95       	ret

00000722 <AddUser_Tick>:
}

void AddUser_Tick(){
     722:	ff 92       	push	r15
     724:	0f 93       	push	r16
     726:	1f 93       	push	r17
     728:	cf 93       	push	r28
     72a:	df 93       	push	r29
	
	//Actions
	switch(adduser_state){
     72c:	80 91 1f 0a 	lds	r24, 0x0A1F	; 0x800a1f <adduser_state>
     730:	82 30       	cpi	r24, 0x02	; 2
     732:	09 f4       	brne	.+2      	; 0x736 <AddUser_Tick+0x14>
     734:	1f c1       	rjmp	.+574    	; 0x974 <AddUser_Tick+0x252>
     736:	30 f4       	brcc	.+12     	; 0x744 <AddUser_Tick+0x22>
     738:	88 23       	and	r24, r24
     73a:	59 f0       	breq	.+22     	; 0x752 <AddUser_Tick+0x30>
     73c:	81 30       	cpi	r24, 0x01	; 1
     73e:	09 f4       	brne	.+2      	; 0x742 <AddUser_Tick+0x20>
     740:	5a c0       	rjmp	.+180    	; 0x7f6 <AddUser_Tick+0xd4>
     742:	f4 c2       	rjmp	.+1512   	; 0xd2c <AddUser_Tick+0x60a>
     744:	83 30       	cpi	r24, 0x03	; 3
     746:	09 f4       	brne	.+2      	; 0x74a <AddUser_Tick+0x28>
     748:	91 c1       	rjmp	.+802    	; 0xa6c <AddUser_Tick+0x34a>
     74a:	84 30       	cpi	r24, 0x04	; 4
     74c:	09 f4       	brne	.+2      	; 0x750 <AddUser_Tick+0x2e>
     74e:	29 c2       	rjmp	.+1106   	; 0xba2 <AddUser_Tick+0x480>
     750:	ed c2       	rjmp	.+1498   	; 0xd2c <AddUser_Tick+0x60a>
		case username:
			keypad_character = AlphaNumPad();
     752:	d1 de       	rcall	.-606    	; 0x4f6 <AlphaNumPad>
     754:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <keypad_character>
			previous_character = '\0';
     758:	10 92 ab 07 	sts	0x07AB, r1	; 0x8007ab <previous_character>
			while(keypad_character != '#'){
     75c:	83 32       	cpi	r24, 0x23	; 35
     75e:	09 f4       	brne	.+2      	; 0x762 <AddUser_Tick+0x40>
     760:	4b c4       	rjmp	.+2198   	; 0xff8 <AddUser_Tick+0x8d6>
				if(keypad_character == '*'){
					if(user_name_size > 0){
						--user_name_size;
						user_name[user_name_size] = '_';
     762:	cf e5       	ldi	r28, 0x5F	; 95
	switch(adduser_state){
		case username:
			keypad_character = AlphaNumPad();
			previous_character = '\0';
			while(keypad_character != '#'){
				if(keypad_character == '*'){
     764:	8a 32       	cpi	r24, 0x2A	; 42
     766:	b1 f4       	brne	.+44     	; 0x794 <AddUser_Tick+0x72>
					if(user_name_size > 0){
     768:	e0 91 c3 07 	lds	r30, 0x07C3	; 0x8007c3 <user_name_size>
     76c:	ee 23       	and	r30, r30
     76e:	71 f0       	breq	.+28     	; 0x78c <AddUser_Tick+0x6a>
						--user_name_size;
     770:	e1 50       	subi	r30, 0x01	; 1
     772:	e0 93 c3 07 	sts	0x07C3, r30	; 0x8007c3 <user_name_size>
						user_name[user_name_size] = '_';
     776:	f0 e0       	ldi	r31, 0x00	; 0
     778:	eb 5f       	subi	r30, 0xFB	; 251
     77a:	fe 4f       	sbci	r31, 0xFE	; 254
     77c:	c0 83       	st	Z, r28
						user_name[user_name_size + 1] = '\0';
     77e:	11 82       	std	Z+1, r1	; 0x01
						previous_character = '\0';
     780:	10 92 ab 07 	sts	0x07AB, r1	; 0x8007ab <previous_character>
						adduser_name_display(user_name);
     784:	85 e0       	ldi	r24, 0x05	; 5
     786:	91 e0       	ldi	r25, 0x01	; 1
     788:	91 df       	rcall	.-222    	; 0x6ac <adduser_name_display>
     78a:	28 c0       	rjmp	.+80     	; 0x7dc <AddUser_Tick+0xba>
					}
					
					else{
						adduser_name_display(user_name);
     78c:	85 e0       	ldi	r24, 0x05	; 5
     78e:	91 e0       	ldi	r25, 0x01	; 1
     790:	8d df       	rcall	.-230    	; 0x6ac <adduser_name_display>
     792:	24 c0       	rjmp	.+72     	; 0x7dc <AddUser_Tick+0xba>
					}
				}
				
				else if(keypad_character != '\0'){
     794:	88 23       	and	r24, r24
     796:	69 f0       	breq	.+26     	; 0x7b2 <AddUser_Tick+0x90>
					user_name[user_name_size] = keypad_character;
     798:	e0 91 c3 07 	lds	r30, 0x07C3	; 0x8007c3 <user_name_size>
     79c:	f0 e0       	ldi	r31, 0x00	; 0
     79e:	eb 5f       	subi	r30, 0xFB	; 251
     7a0:	fe 4f       	sbci	r31, 0xFE	; 254
     7a2:	80 83       	st	Z, r24
					user_name[user_name_size + 1] = '\0';
     7a4:	11 82       	std	Z+1, r1	; 0x01
					previous_character = keypad_character;
     7a6:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <previous_character>
					adduser_name_display(user_name);
     7aa:	85 e0       	ldi	r24, 0x05	; 5
     7ac:	91 e0       	ldi	r25, 0x01	; 1
     7ae:	7e df       	rcall	.-260    	; 0x6ac <adduser_name_display>
     7b0:	15 c0       	rjmp	.+42     	; 0x7dc <AddUser_Tick+0xba>
				}
				
				else{
					if(previous_character !='\0'){
     7b2:	80 91 ab 07 	lds	r24, 0x07AB	; 0x8007ab <previous_character>
     7b6:	88 23       	and	r24, r24
     7b8:	89 f0       	breq	.+34     	; 0x7dc <AddUser_Tick+0xba>
						if(user_name_size < 10){
     7ba:	e0 91 c3 07 	lds	r30, 0x07C3	; 0x8007c3 <user_name_size>
     7be:	ea 30       	cpi	r30, 0x0A	; 10
     7c0:	68 f4       	brcc	.+26     	; 0x7dc <AddUser_Tick+0xba>
							++user_name_size;
     7c2:	ef 5f       	subi	r30, 0xFF	; 255
     7c4:	e0 93 c3 07 	sts	0x07C3, r30	; 0x8007c3 <user_name_size>
							user_name[user_name_size] = '_';
     7c8:	f0 e0       	ldi	r31, 0x00	; 0
     7ca:	eb 5f       	subi	r30, 0xFB	; 251
     7cc:	fe 4f       	sbci	r31, 0xFE	; 254
     7ce:	c0 83       	st	Z, r28
							user_name[user_name_size + 1] = '\0';
     7d0:	11 82       	std	Z+1, r1	; 0x01
							previous_character = '\0';	
     7d2:	10 92 ab 07 	sts	0x07AB, r1	; 0x8007ab <previous_character>
							adduser_name_display(user_name);
     7d6:	85 e0       	ldi	r24, 0x05	; 5
     7d8:	91 e0       	ldi	r25, 0x01	; 1
     7da:	68 df       	rcall	.-304    	; 0x6ac <adduser_name_display>
						}
					}
				}
				keypad_character = AlphaNumPad();
     7dc:	8c de       	rcall	.-744    	; 0x4f6 <AlphaNumPad>
     7de:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <keypad_character>
     7e2:	83 32       	cpi	r24, 0x23	; 35
	//Actions
	switch(adduser_state){
		case username:
			keypad_character = AlphaNumPad();
			previous_character = '\0';
			while(keypad_character != '#'){
     7e4:	09 f0       	breq	.+2      	; 0x7e8 <AddUser_Tick+0xc6>
     7e6:	be cf       	rjmp	.-132    	; 0x764 <AddUser_Tick+0x42>
     7e8:	07 c4       	rjmp	.+2062   	; 0xff8 <AddUser_Tick+0x8d6>
     7ea:	8f e4       	ldi	r24, 0x4F	; 79
     7ec:	93 ec       	ldi	r25, 0xC3	; 195
     7ee:	01 97       	sbiw	r24, 0x01	; 1
     7f0:	f1 f7       	brne	.-4      	; 0x7ee <AddUser_Tick+0xcc>
     7f2:	00 c0       	rjmp	.+0      	; 0x7f4 <AddUser_Tick+0xd2>
     7f4:	00 00       	nop

			
			break;
		
		case userweight:
			while((keypad_character = GetKeypadKey()) == '\0'){ _delay_ms(200); }
     7f6:	1a de       	rcall	.-972    	; 0x42c <GetKeypadKey>
     7f8:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <keypad_character>
     7fc:	88 23       	and	r24, r24
     7fe:	a9 f3       	breq	.-22     	; 0x7ea <AddUser_Tick+0xc8>
     800:	06 c0       	rjmp	.+12     	; 0x80e <AddUser_Tick+0xec>
     802:	ef e4       	ldi	r30, 0x4F	; 79
     804:	f3 ec       	ldi	r31, 0xC3	; 195
     806:	31 97       	sbiw	r30, 0x01	; 1
     808:	f1 f7       	brne	.-4      	; 0x806 <AddUser_Tick+0xe4>
     80a:	00 c0       	rjmp	.+0      	; 0x80c <AddUser_Tick+0xea>
     80c:	00 00       	nop
			while((previous_character = GetKeypadKey()) == keypad_character){ _delay_ms(200); }
     80e:	0e de       	rcall	.-996    	; 0x42c <GetKeypadKey>
     810:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <previous_character>
     814:	90 91 ac 07 	lds	r25, 0x07AC	; 0x8007ac <keypad_character>
     818:	89 17       	cp	r24, r25
     81a:	99 f3       	breq	.-26     	; 0x802 <AddUser_Tick+0xe0>
     81c:	c0 e0       	ldi	r28, 0x00	; 0
					nokia_lcd_render();
				}
				
				else if(keypad_character == '*'){
					user_weight = 0;
					weight_output[0] = '_';
     81e:	d1 e0       	ldi	r29, 0x01	; 1
     820:	1f e5       	ldi	r17, 0x5F	; 95
     822:	9c c0       	rjmp	.+312    	; 0x95c <AddUser_Tick+0x23a>
     824:	88 23       	and	r24, r24
		case userweight:
			while((keypad_character = GetKeypadKey()) == '\0'){ _delay_ms(200); }
			while((previous_character = GetKeypadKey()) == keypad_character){ _delay_ms(200); }

			while(keypad_character != '#'){
				if(keypad_character != '\0' && keypad_character != '*' && user_weight == 0){
     826:	09 f4       	brne	.+2      	; 0x82a <AddUser_Tick+0x108>
     828:	86 c0       	rjmp	.+268    	; 0x936 <AddUser_Tick+0x214>
     82a:	8a 32       	cpi	r24, 0x2A	; 42
     82c:	09 f4       	brne	.+2      	; 0x830 <AddUser_Tick+0x10e>
     82e:	64 c0       	rjmp	.+200    	; 0x8f8 <AddUser_Tick+0x1d6>
     830:	90 91 c2 07 	lds	r25, 0x07C2	; 0x8007c2 <user_weight>
     834:	91 11       	cpse	r25, r1
     836:	19 c0       	rjmp	.+50     	; 0x86a <AddUser_Tick+0x148>
					user_weight = keypad_character - '0';
     838:	90 ed       	ldi	r25, 0xD0	; 208
     83a:	98 0f       	add	r25, r24
     83c:	90 93 c2 07 	sts	0x07C2, r25	; 0x8007c2 <user_weight>
					weight_output[0] =  keypad_character;
					nokia_lcd_clear();
     840:	88 83       	st	Y, r24
					nokia_lcd_write_string("Enter your",1);
     842:	7e d4       	rcall	.+2300   	; 0x1140 <nokia_lcd_clear>
     844:	61 e0       	ldi	r22, 0x01	; 1
     846:	80 e5       	ldi	r24, 0x50	; 80
     848:	91 e0       	ldi	r25, 0x01	; 1
					nokia_lcd_set_cursor(0,10);
     84a:	60 d5       	rcall	.+2752   	; 0x130c <nokia_lcd_write_string>
     84c:	6a e0       	ldi	r22, 0x0A	; 10
     84e:	80 e0       	ldi	r24, 0x00	; 0
					nokia_lcd_write_string("weight in lbs",1);
     850:	6f d5       	rcall	.+2782   	; 0x1330 <nokia_lcd_set_cursor>
     852:	61 e0       	ldi	r22, 0x01	; 1
     854:	8b e5       	ldi	r24, 0x5B	; 91
     856:	91 e0       	ldi	r25, 0x01	; 1
     858:	59 d5       	rcall	.+2738   	; 0x130c <nokia_lcd_write_string>
					nokia_lcd_set_cursor(0,20);
     85a:	64 e1       	ldi	r22, 0x14	; 20
     85c:	80 e0       	ldi	r24, 0x00	; 0
     85e:	68 d5       	rcall	.+2768   	; 0x1330 <nokia_lcd_set_cursor>
     860:	61 e0       	ldi	r22, 0x01	; 1
					nokia_lcd_write_string(weight_output,1);
     862:	ce 01       	movw	r24, r28
     864:	53 d5       	rcall	.+2726   	; 0x130c <nokia_lcd_write_string>
     866:	69 d5       	rcall	.+2770   	; 0x133a <nokia_lcd_render>
     868:	66 c0       	rjmp	.+204    	; 0x936 <AddUser_Tick+0x214>
					nokia_lcd_render();
     86a:	2f ef       	ldi	r18, 0xFF	; 255
     86c:	29 0f       	add	r18, r25
     86e:	29 30       	cpi	r18, 0x09	; 9
				}
				
				else if(keypad_character != '\0' && keypad_character != '*' && user_weight >= 1 && user_weight <= 9){
     870:	f8 f4       	brcc	.+62     	; 0x8b0 <AddUser_Tick+0x18e>
     872:	99 0f       	add	r25, r25
     874:	29 2f       	mov	r18, r25
					user_weight = (user_weight * 10) + keypad_character - '0';
     876:	22 0f       	add	r18, r18
     878:	22 0f       	add	r18, r18
     87a:	92 0f       	add	r25, r18
     87c:	20 ed       	ldi	r18, 0xD0	; 208
     87e:	28 0f       	add	r18, r24
     880:	92 0f       	add	r25, r18
     882:	90 93 c2 07 	sts	0x07C2, r25	; 0x8007c2 <user_weight>
					weight_output[1] =  keypad_character;
					nokia_lcd_clear();
     886:	89 83       	std	Y+1, r24	; 0x01
					nokia_lcd_write_string("Enter your",1);
     888:	5b d4       	rcall	.+2230   	; 0x1140 <nokia_lcd_clear>
     88a:	61 e0       	ldi	r22, 0x01	; 1
     88c:	80 e5       	ldi	r24, 0x50	; 80
					nokia_lcd_set_cursor(0,10);
     88e:	91 e0       	ldi	r25, 0x01	; 1
     890:	3d d5       	rcall	.+2682   	; 0x130c <nokia_lcd_write_string>
     892:	6a e0       	ldi	r22, 0x0A	; 10
     894:	80 e0       	ldi	r24, 0x00	; 0
					nokia_lcd_write_string("weight in lbs",1);
     896:	4c d5       	rcall	.+2712   	; 0x1330 <nokia_lcd_set_cursor>
     898:	61 e0       	ldi	r22, 0x01	; 1
     89a:	8b e5       	ldi	r24, 0x5B	; 91
     89c:	91 e0       	ldi	r25, 0x01	; 1
     89e:	36 d5       	rcall	.+2668   	; 0x130c <nokia_lcd_write_string>
					nokia_lcd_set_cursor(0,20);
     8a0:	64 e1       	ldi	r22, 0x14	; 20
     8a2:	80 e0       	ldi	r24, 0x00	; 0
     8a4:	45 d5       	rcall	.+2698   	; 0x1330 <nokia_lcd_set_cursor>
     8a6:	61 e0       	ldi	r22, 0x01	; 1
					nokia_lcd_write_string(weight_output,1);
     8a8:	ce 01       	movw	r24, r28
     8aa:	30 d5       	rcall	.+2656   	; 0x130c <nokia_lcd_write_string>
     8ac:	46 d5       	rcall	.+2700   	; 0x133a <nokia_lcd_render>
					nokia_lcd_render();
     8ae:	43 c0       	rjmp	.+134    	; 0x936 <AddUser_Tick+0x214>
     8b0:	26 ef       	ldi	r18, 0xF6	; 246
				}
				
				else if(keypad_character != '\0' && keypad_character != '*' && user_weight >= 10 && user_weight <= 99){
     8b2:	29 0f       	add	r18, r25
     8b4:	2a 35       	cpi	r18, 0x5A	; 90
     8b6:	08 f0       	brcs	.+2      	; 0x8ba <AddUser_Tick+0x198>
     8b8:	3e c0       	rjmp	.+124    	; 0x936 <AddUser_Tick+0x214>
					user_weight = (user_weight * 10) + keypad_character - '0';
     8ba:	30 ed       	ldi	r19, 0xD0	; 208
     8bc:	38 0f       	add	r19, r24
     8be:	99 0f       	add	r25, r25
     8c0:	29 2f       	mov	r18, r25
     8c2:	22 0f       	add	r18, r18
     8c4:	22 0f       	add	r18, r18
     8c6:	92 0f       	add	r25, r18
					weight_output[2] = keypad_character;
     8c8:	93 0f       	add	r25, r19
					nokia_lcd_clear();
     8ca:	90 93 c2 07 	sts	0x07C2, r25	; 0x8007c2 <user_weight>
					nokia_lcd_write_string("Enter your",1);
     8ce:	8a 83       	std	Y+2, r24	; 0x02
     8d0:	37 d4       	rcall	.+2158   	; 0x1140 <nokia_lcd_clear>
     8d2:	61 e0       	ldi	r22, 0x01	; 1
     8d4:	80 e5       	ldi	r24, 0x50	; 80
					nokia_lcd_set_cursor(0,10);
     8d6:	91 e0       	ldi	r25, 0x01	; 1
     8d8:	19 d5       	rcall	.+2610   	; 0x130c <nokia_lcd_write_string>
     8da:	6a e0       	ldi	r22, 0x0A	; 10
					nokia_lcd_write_string("weight in lbs",1);
     8dc:	80 e0       	ldi	r24, 0x00	; 0
     8de:	28 d5       	rcall	.+2640   	; 0x1330 <nokia_lcd_set_cursor>
     8e0:	61 e0       	ldi	r22, 0x01	; 1
     8e2:	8b e5       	ldi	r24, 0x5B	; 91
					nokia_lcd_set_cursor(0,20);
     8e4:	91 e0       	ldi	r25, 0x01	; 1
     8e6:	12 d5       	rcall	.+2596   	; 0x130c <nokia_lcd_write_string>
     8e8:	64 e1       	ldi	r22, 0x14	; 20
					nokia_lcd_write_string(weight_output,1);
     8ea:	80 e0       	ldi	r24, 0x00	; 0
     8ec:	21 d5       	rcall	.+2626   	; 0x1330 <nokia_lcd_set_cursor>
					nokia_lcd_render();
     8ee:	61 e0       	ldi	r22, 0x01	; 1
     8f0:	ce 01       	movw	r24, r28
     8f2:	0c d5       	rcall	.+2584   	; 0x130c <nokia_lcd_write_string>
				}
				
				else if(keypad_character == '*'){
					user_weight = 0;
     8f4:	22 d5       	rcall	.+2628   	; 0x133a <nokia_lcd_render>
     8f6:	1f c0       	rjmp	.+62     	; 0x936 <AddUser_Tick+0x214>
					weight_output[0] = '_';
					weight_output[1] = '\0';
     8f8:	10 92 c2 07 	sts	0x07C2, r1	; 0x8007c2 <user_weight>
					weight_output[2] = '\0';
					nokia_lcd_clear();
     8fc:	18 83       	st	Y, r17
     8fe:	19 82       	std	Y+1, r1	; 0x01
					nokia_lcd_write_string("Enter your",1);
     900:	1a 82       	std	Y+2, r1	; 0x02
     902:	1e d4       	rcall	.+2108   	; 0x1140 <nokia_lcd_clear>
     904:	61 e0       	ldi	r22, 0x01	; 1
     906:	80 e5       	ldi	r24, 0x50	; 80
     908:	91 e0       	ldi	r25, 0x01	; 1
					nokia_lcd_set_cursor(0,10);
     90a:	00 d5       	rcall	.+2560   	; 0x130c <nokia_lcd_write_string>
     90c:	6a e0       	ldi	r22, 0x0A	; 10
     90e:	80 e0       	ldi	r24, 0x00	; 0
					nokia_lcd_write_string("weight in lbs",1);
     910:	0f d5       	rcall	.+2590   	; 0x1330 <nokia_lcd_set_cursor>
     912:	61 e0       	ldi	r22, 0x01	; 1
     914:	8b e5       	ldi	r24, 0x5B	; 91
     916:	91 e0       	ldi	r25, 0x01	; 1
     918:	f9 d4       	rcall	.+2546   	; 0x130c <nokia_lcd_write_string>
					nokia_lcd_set_cursor(0,20);
     91a:	64 e1       	ldi	r22, 0x14	; 20
     91c:	80 e0       	ldi	r24, 0x00	; 0
     91e:	08 d5       	rcall	.+2576   	; 0x1330 <nokia_lcd_set_cursor>
     920:	61 e0       	ldi	r22, 0x01	; 1
					nokia_lcd_write_string(weight_output,1);
     922:	ce 01       	movw	r24, r28
     924:	f3 d4       	rcall	.+2534   	; 0x130c <nokia_lcd_write_string>
     926:	09 d5       	rcall	.+2578   	; 0x133a <nokia_lcd_render>
     928:	06 c0       	rjmp	.+12     	; 0x936 <AddUser_Tick+0x214>
					nokia_lcd_render();
     92a:	87 ea       	ldi	r24, 0xA7	; 167
     92c:	91 e6       	ldi	r25, 0x61	; 97
     92e:	01 97       	sbiw	r24, 0x01	; 1
     930:	f1 f7       	brne	.-4      	; 0x92e <AddUser_Tick+0x20c>
     932:	00 c0       	rjmp	.+0      	; 0x934 <AddUser_Tick+0x212>
     934:	00 00       	nop
     936:	7a dd       	rcall	.-1292   	; 0x42c <GetKeypadKey>
     938:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <keypad_character>
				}
				
				while((keypad_character = GetKeypadKey()) == '\0'){ _delay_ms(100); }
     93c:	88 23       	and	r24, r24
     93e:	a9 f3       	breq	.-22     	; 0x92a <AddUser_Tick+0x208>
     940:	06 c0       	rjmp	.+12     	; 0x94e <AddUser_Tick+0x22c>
     942:	e7 ea       	ldi	r30, 0xA7	; 167
     944:	f1 e6       	ldi	r31, 0x61	; 97
     946:	31 97       	sbiw	r30, 0x01	; 1
     948:	f1 f7       	brne	.-4      	; 0x946 <AddUser_Tick+0x224>
     94a:	00 c0       	rjmp	.+0      	; 0x94c <AddUser_Tick+0x22a>
     94c:	00 00       	nop
     94e:	6e dd       	rcall	.-1316   	; 0x42c <GetKeypadKey>
     950:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <previous_character>
				
				while((previous_character = GetKeypadKey()) == keypad_character){ _delay_ms(100); }
     954:	90 91 ac 07 	lds	r25, 0x07AC	; 0x8007ac <keypad_character>
     958:	89 17       	cp	r24, r25
     95a:	99 f3       	breq	.-26     	; 0x942 <AddUser_Tick+0x220>
     95c:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <keypad_character>
     960:	83 32       	cpi	r24, 0x23	; 35
		
		case userweight:
			while((keypad_character = GetKeypadKey()) == '\0'){ _delay_ms(200); }
			while((previous_character = GetKeypadKey()) == keypad_character){ _delay_ms(200); }

			while(keypad_character != '#'){
     962:	09 f0       	breq	.+2      	; 0x966 <AddUser_Tick+0x244>
     964:	5f cf       	rjmp	.-322    	; 0x824 <AddUser_Tick+0x102>
     966:	48 c3       	rjmp	.+1680   	; 0xff8 <AddUser_Tick+0x8d6>
     968:	8f e4       	ldi	r24, 0x4F	; 79
     96a:	93 ec       	ldi	r25, 0xC3	; 195
     96c:	01 97       	sbiw	r24, 0x01	; 1
     96e:	f1 f7       	brne	.-4      	; 0x96c <AddUser_Tick+0x24a>
     970:	00 c0       	rjmp	.+0      	; 0x972 <AddUser_Tick+0x250>
     972:	00 00       	nop
				
			}
			break;
		
		case usergender:
			while((keypad_character = GetKeypadKey()) == '\0'){ _delay_ms(200); }
     974:	5b dd       	rcall	.-1354   	; 0x42c <GetKeypadKey>
     976:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <keypad_character>
     97a:	88 23       	and	r24, r24
     97c:	a9 f3       	breq	.-22     	; 0x968 <AddUser_Tick+0x246>
     97e:	06 c0       	rjmp	.+12     	; 0x98c <AddUser_Tick+0x26a>
     980:	ef e4       	ldi	r30, 0x4F	; 79
     982:	f3 ec       	ldi	r31, 0xC3	; 195
     984:	31 97       	sbiw	r30, 0x01	; 1
     986:	f1 f7       	brne	.-4      	; 0x984 <AddUser_Tick+0x262>
     988:	00 c0       	rjmp	.+0      	; 0x98a <AddUser_Tick+0x268>
			while((previous_character = GetKeypadKey()) == keypad_character){ _delay_ms(200); }
     98a:	00 00       	nop
     98c:	4f dd       	rcall	.-1378   	; 0x42c <GetKeypadKey>
     98e:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <previous_character>
     992:	90 91 ac 07 	lds	r25, 0x07AC	; 0x8007ac <keypad_character>
					nokia_lcd_write_string("Male",1);
					nokia_lcd_render();
				}
				
				if(keypad_character == '2'){
					user_gender = 2;
     996:	89 17       	cp	r24, r25
     998:	99 f3       	breq	.-26     	; 0x980 <AddUser_Tick+0x25e>
		case usergender:
			while((keypad_character = GetKeypadKey()) == '\0'){ _delay_ms(200); }
			while((previous_character = GetKeypadKey()) == keypad_character){ _delay_ms(200); }
			
			while(keypad_character != '#'){
				if(keypad_character == '1'){
     99a:	c1 e0       	ldi	r28, 0x01	; 1
					user_gender = 1;
     99c:	d2 e0       	ldi	r29, 0x02	; 2
     99e:	5a c0       	rjmp	.+180    	; 0xa54 <AddUser_Tick+0x332>
					nokia_lcd_clear();
     9a0:	81 33       	cpi	r24, 0x31	; 49
					nokia_lcd_write_string("Select Gender",1);
     9a2:	e9 f4       	brne	.+58     	; 0x9de <AddUser_Tick+0x2bc>
     9a4:	c0 93 c1 07 	sts	0x07C1, r28	; 0x8007c1 <user_gender>
     9a8:	cb d3       	rcall	.+1942   	; 0x1140 <nokia_lcd_clear>
					nokia_lcd_set_cursor(0,10);
     9aa:	6c 2f       	mov	r22, r28
     9ac:	89 e6       	ldi	r24, 0x69	; 105
     9ae:	91 e0       	ldi	r25, 0x01	; 1
					nokia_lcd_write_string("1: Male",1);
     9b0:	ad d4       	rcall	.+2394   	; 0x130c <nokia_lcd_write_string>
     9b2:	6a e0       	ldi	r22, 0x0A	; 10
     9b4:	80 e0       	ldi	r24, 0x00	; 0
					nokia_lcd_set_cursor(0,20);
     9b6:	bc d4       	rcall	.+2424   	; 0x1330 <nokia_lcd_set_cursor>
     9b8:	6c 2f       	mov	r22, r28
     9ba:	87 e7       	ldi	r24, 0x77	; 119
					nokia_lcd_write_string("2: Female",1);
     9bc:	91 e0       	ldi	r25, 0x01	; 1
     9be:	a6 d4       	rcall	.+2380   	; 0x130c <nokia_lcd_write_string>
     9c0:	64 e1       	ldi	r22, 0x14	; 20
     9c2:	80 e0       	ldi	r24, 0x00	; 0
     9c4:	b5 d4       	rcall	.+2410   	; 0x1330 <nokia_lcd_set_cursor>
					nokia_lcd_set_cursor(0,30);
     9c6:	6c 2f       	mov	r22, r28
     9c8:	8f e7       	ldi	r24, 0x7F	; 127
     9ca:	91 e0       	ldi	r25, 0x01	; 1
					nokia_lcd_write_string("Male",1);
     9cc:	9f d4       	rcall	.+2366   	; 0x130c <nokia_lcd_write_string>
     9ce:	6e e1       	ldi	r22, 0x1E	; 30
     9d0:	80 e0       	ldi	r24, 0x00	; 0
     9d2:	ae d4       	rcall	.+2396   	; 0x1330 <nokia_lcd_set_cursor>
     9d4:	6c 2f       	mov	r22, r28
					nokia_lcd_render();
     9d6:	8a e7       	ldi	r24, 0x7A	; 122
     9d8:	91 e0       	ldi	r25, 0x01	; 1
				}
				
				if(keypad_character == '2'){
     9da:	98 d4       	rcall	.+2352   	; 0x130c <nokia_lcd_write_string>
     9dc:	ae d4       	rcall	.+2396   	; 0x133a <nokia_lcd_render>
     9de:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <keypad_character>
					user_gender = 2;
     9e2:	82 33       	cpi	r24, 0x32	; 50
					nokia_lcd_clear();
     9e4:	21 f5       	brne	.+72     	; 0xa2e <AddUser_Tick+0x30c>
     9e6:	d0 93 c1 07 	sts	0x07C1, r29	; 0x8007c1 <user_gender>
					nokia_lcd_write_string("Select Gender",1);
     9ea:	aa d3       	rcall	.+1876   	; 0x1140 <nokia_lcd_clear>
     9ec:	6c 2f       	mov	r22, r28
     9ee:	89 e6       	ldi	r24, 0x69	; 105
     9f0:	91 e0       	ldi	r25, 0x01	; 1
					nokia_lcd_set_cursor(0,10);
     9f2:	8c d4       	rcall	.+2328   	; 0x130c <nokia_lcd_write_string>
     9f4:	6a e0       	ldi	r22, 0x0A	; 10
     9f6:	80 e0       	ldi	r24, 0x00	; 0
     9f8:	9b d4       	rcall	.+2358   	; 0x1330 <nokia_lcd_set_cursor>
					nokia_lcd_write_string("1: Male",1);
     9fa:	6c 2f       	mov	r22, r28
     9fc:	87 e7       	ldi	r24, 0x77	; 119
     9fe:	91 e0       	ldi	r25, 0x01	; 1
     a00:	85 d4       	rcall	.+2314   	; 0x130c <nokia_lcd_write_string>
     a02:	64 e1       	ldi	r22, 0x14	; 20
					nokia_lcd_set_cursor(0,20);
     a04:	80 e0       	ldi	r24, 0x00	; 0
     a06:	94 d4       	rcall	.+2344   	; 0x1330 <nokia_lcd_set_cursor>
     a08:	6c 2f       	mov	r22, r28
					nokia_lcd_write_string("2: Female",1);
     a0a:	8f e7       	ldi	r24, 0x7F	; 127
     a0c:	91 e0       	ldi	r25, 0x01	; 1
     a0e:	7e d4       	rcall	.+2300   	; 0x130c <nokia_lcd_write_string>
     a10:	6e e1       	ldi	r22, 0x1E	; 30
     a12:	80 e0       	ldi	r24, 0x00	; 0
					nokia_lcd_set_cursor(0,30);
     a14:	8d d4       	rcall	.+2330   	; 0x1330 <nokia_lcd_set_cursor>
     a16:	6c 2f       	mov	r22, r28
     a18:	82 e8       	ldi	r24, 0x82	; 130
					nokia_lcd_write_string("Female",1);
     a1a:	91 e0       	ldi	r25, 0x01	; 1
     a1c:	77 d4       	rcall	.+2286   	; 0x130c <nokia_lcd_write_string>
     a1e:	8d d4       	rcall	.+2330   	; 0x133a <nokia_lcd_render>
     a20:	06 c0       	rjmp	.+12     	; 0xa2e <AddUser_Tick+0x30c>
     a22:	8f e4       	ldi	r24, 0x4F	; 79
					nokia_lcd_render();
     a24:	93 ec       	ldi	r25, 0xC3	; 195
     a26:	01 97       	sbiw	r24, 0x01	; 1
     a28:	f1 f7       	brne	.-4      	; 0xa26 <AddUser_Tick+0x304>
     a2a:	00 c0       	rjmp	.+0      	; 0xa2c <AddUser_Tick+0x30a>
     a2c:	00 00       	nop
     a2e:	fe dc       	rcall	.-1540   	; 0x42c <GetKeypadKey>
     a30:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <keypad_character>
     a34:	88 23       	and	r24, r24
				}
				
				while((keypad_character = GetKeypadKey()) == '\0'){ _delay_ms(200); }
     a36:	a9 f3       	breq	.-22     	; 0xa22 <AddUser_Tick+0x300>
     a38:	06 c0       	rjmp	.+12     	; 0xa46 <AddUser_Tick+0x324>
     a3a:	ef e4       	ldi	r30, 0x4F	; 79
     a3c:	f3 ec       	ldi	r31, 0xC3	; 195
     a3e:	31 97       	sbiw	r30, 0x01	; 1
     a40:	f1 f7       	brne	.-4      	; 0xa3e <AddUser_Tick+0x31c>
     a42:	00 c0       	rjmp	.+0      	; 0xa44 <AddUser_Tick+0x322>
     a44:	00 00       	nop
     a46:	f2 dc       	rcall	.-1564   	; 0x42c <GetKeypadKey>
     a48:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <previous_character>
     a4c:	90 91 ac 07 	lds	r25, 0x07AC	; 0x8007ac <keypad_character>
				
				while((previous_character = GetKeypadKey()) == keypad_character){ _delay_ms(200); }
     a50:	89 17       	cp	r24, r25
     a52:	99 f3       	breq	.-26     	; 0xa3a <AddUser_Tick+0x318>
     a54:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <keypad_character>
     a58:	83 32       	cpi	r24, 0x23	; 35
     a5a:	09 f0       	breq	.+2      	; 0xa5e <AddUser_Tick+0x33c>
     a5c:	a1 cf       	rjmp	.-190    	; 0x9a0 <AddUser_Tick+0x27e>
     a5e:	cc c2       	rjmp	.+1432   	; 0xff8 <AddUser_Tick+0x8d6>
		
		case usergender:
			while((keypad_character = GetKeypadKey()) == '\0'){ _delay_ms(200); }
			while((previous_character = GetKeypadKey()) == keypad_character){ _delay_ms(200); }
			
			while(keypad_character != '#'){
     a60:	8f e4       	ldi	r24, 0x4F	; 79
     a62:	93 ec       	ldi	r25, 0xC3	; 195
     a64:	01 97       	sbiw	r24, 0x01	; 1
     a66:	f1 f7       	brne	.-4      	; 0xa64 <AddUser_Tick+0x342>
     a68:	00 c0       	rjmp	.+0      	; 0xa6a <AddUser_Tick+0x348>
     a6a:	00 00       	nop
     a6c:	df dc       	rcall	.-1602   	; 0x42c <GetKeypadKey>
     a6e:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <keypad_character>
     a72:	88 23       	and	r24, r24
			}	
			
			break;
		
		case userpassword:
			while((keypad_character = GetKeypadKey()) == '\0'){ _delay_ms(200); }
     a74:	a9 f3       	breq	.-22     	; 0xa60 <AddUser_Tick+0x33e>
     a76:	06 c0       	rjmp	.+12     	; 0xa84 <AddUser_Tick+0x362>
     a78:	ef e4       	ldi	r30, 0x4F	; 79
     a7a:	f3 ec       	ldi	r31, 0xC3	; 195
     a7c:	31 97       	sbiw	r30, 0x01	; 1
     a7e:	f1 f7       	brne	.-4      	; 0xa7c <AddUser_Tick+0x35a>
     a80:	00 c0       	rjmp	.+0      	; 0xa82 <AddUser_Tick+0x360>
     a82:	00 00       	nop
     a84:	d3 dc       	rcall	.-1626   	; 0x42c <GetKeypadKey>
			while((previous_character = GetKeypadKey()) == keypad_character){ _delay_ms(200); }
     a86:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <previous_character>
     a8a:	90 91 ac 07 	lds	r25, 0x07AC	; 0x8007ac <keypad_character>
     a8e:	89 17       	cp	r24, r25
     a90:	99 f3       	breq	.-26     	; 0xa78 <AddUser_Tick+0x356>
     a92:	c0 ec       	ldi	r28, 0xC0	; 192
     a94:	d7 e0       	ldi	r29, 0x07	; 7
     a96:	08 eb       	ldi	r16, 0xB8	; 184
     a98:	17 e0       	ldi	r17, 0x07	; 7
				if(keypad_character == '*'){
					password_size = 0;
					for(unsigned char i = 0; i < 8; ++i){
						user_password[i] = '\0';
					}
					user_password[0] = '*';
     a9a:	0f 2e       	mov	r0, r31
     a9c:	fa e2       	ldi	r31, 0x2A	; 42
     a9e:	ff 2e       	mov	r15, r31
     aa0:	f0 2d       	mov	r31, r0
     aa2:	73 c0       	rjmp	.+230    	; 0xb8a <AddUser_Tick+0x468>
     aa4:	88 23       	and	r24, r24
     aa6:	09 f4       	brne	.+2      	; 0xaaa <AddUser_Tick+0x388>
		case userpassword:
			while((keypad_character = GetKeypadKey()) == '\0'){ _delay_ms(200); }
			while((previous_character = GetKeypadKey()) == keypad_character){ _delay_ms(200); }
			
			while(keypad_character != '#'){
				if(keypad_character != '\0' && keypad_character != '*'){
     aa8:	5d c0       	rjmp	.+186    	; 0xb64 <AddUser_Tick+0x442>
     aaa:	8a 32       	cpi	r24, 0x2A	; 42
     aac:	a9 f1       	breq	.+106    	; 0xb18 <AddUser_Tick+0x3f6>
     aae:	20 91 ad 07 	lds	r18, 0x07AD	; 0x8007ad <password_size>
					if(password_size < 8){
     ab2:	30 91 ae 07 	lds	r19, 0x07AE	; 0x8007ae <password_size+0x1>
     ab6:	28 30       	cpi	r18, 0x08	; 8
     ab8:	31 05       	cpc	r19, r1
     aba:	08 f0       	brcs	.+2      	; 0xabe <AddUser_Tick+0x39c>
     abc:	53 c0       	rjmp	.+166    	; 0xb64 <AddUser_Tick+0x442>
     abe:	f9 01       	movw	r30, r18
						user_password[password_size] = keypad_character;
     ac0:	e8 54       	subi	r30, 0x48	; 72
     ac2:	f8 4f       	sbci	r31, 0xF8	; 248
     ac4:	80 83       	st	Z, r24
						if(password_size + 1 < 8){
     ac6:	2f 5f       	subi	r18, 0xFF	; 255
     ac8:	3f 4f       	sbci	r19, 0xFF	; 255
     aca:	28 30       	cpi	r18, 0x08	; 8
     acc:	31 05       	cpc	r19, r1
							user_password[password_size + 1] = '*';
     ace:	20 f4       	brcc	.+8      	; 0xad8 <AddUser_Tick+0x3b6>
     ad0:	f9 01       	movw	r30, r18
     ad2:	e8 54       	subi	r30, 0x48	; 72
						}
						nokia_lcd_clear();
     ad4:	f8 4f       	sbci	r31, 0xF8	; 248
						nokia_lcd_write_string("Create",1);
     ad6:	f0 82       	st	Z, r15
     ad8:	33 d3       	rcall	.+1638   	; 0x1140 <nokia_lcd_clear>
     ada:	61 e0       	ldi	r22, 0x01	; 1
     adc:	89 e8       	ldi	r24, 0x89	; 137
     ade:	91 e0       	ldi	r25, 0x01	; 1
						nokia_lcd_set_cursor(0,10);
     ae0:	15 d4       	rcall	.+2090   	; 0x130c <nokia_lcd_write_string>
     ae2:	6a e0       	ldi	r22, 0x0A	; 10
     ae4:	80 e0       	ldi	r24, 0x00	; 0
						nokia_lcd_write_string("Password",1);
     ae6:	24 d4       	rcall	.+2120   	; 0x1330 <nokia_lcd_set_cursor>
     ae8:	61 e0       	ldi	r22, 0x01	; 1
     aea:	80 e9       	ldi	r24, 0x90	; 144
     aec:	91 e0       	ldi	r25, 0x01	; 1
     aee:	0e d4       	rcall	.+2076   	; 0x130c <nokia_lcd_write_string>
						nokia_lcd_set_cursor(0,20);
     af0:	64 e1       	ldi	r22, 0x14	; 20
     af2:	80 e0       	ldi	r24, 0x00	; 0
     af4:	1d d4       	rcall	.+2106   	; 0x1330 <nokia_lcd_set_cursor>
     af6:	61 e0       	ldi	r22, 0x01	; 1
						nokia_lcd_write_string(user_password,1);
     af8:	c8 01       	movw	r24, r16
     afa:	08 d4       	rcall	.+2064   	; 0x130c <nokia_lcd_write_string>
     afc:	1e d4       	rcall	.+2108   	; 0x133a <nokia_lcd_render>
						nokia_lcd_render();
     afe:	80 91 ad 07 	lds	r24, 0x07AD	; 0x8007ad <password_size>
						
						++password_size;
     b02:	90 91 ae 07 	lds	r25, 0x07AE	; 0x8007ae <password_size+0x1>
     b06:	01 96       	adiw	r24, 0x01	; 1
     b08:	90 93 ae 07 	sts	0x07AE, r25	; 0x8007ae <password_size+0x1>
     b0c:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <password_size>
     b10:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <keypad_character>
					}					
				}
				
				if(keypad_character == '*'){
     b14:	8a 32       	cpi	r24, 0x2A	; 42
     b16:	31 f5       	brne	.+76     	; 0xb64 <AddUser_Tick+0x442>
     b18:	10 92 ae 07 	sts	0x07AE, r1	; 0x8007ae <password_size+0x1>
					password_size = 0;
     b1c:	10 92 ad 07 	sts	0x07AD, r1	; 0x8007ad <password_size>
     b20:	e8 eb       	ldi	r30, 0xB8	; 184
     b22:	f7 e0       	ldi	r31, 0x07	; 7
     b24:	11 92       	st	Z+, r1
					for(unsigned char i = 0; i < 8; ++i){
						user_password[i] = '\0';
     b26:	ce 17       	cp	r28, r30
					}					
				}
				
				if(keypad_character == '*'){
					password_size = 0;
					for(unsigned char i = 0; i < 8; ++i){
     b28:	df 07       	cpc	r29, r31
     b2a:	e1 f7       	brne	.-8      	; 0xb24 <AddUser_Tick+0x402>
     b2c:	f8 01       	movw	r30, r16
						user_password[i] = '\0';
					}
					user_password[0] = '*';
     b2e:	f0 82       	st	Z, r15
     b30:	07 d3       	rcall	.+1550   	; 0x1140 <nokia_lcd_clear>
					nokia_lcd_clear();
     b32:	61 e0       	ldi	r22, 0x01	; 1
					nokia_lcd_write_string("Create",1);
     b34:	89 e8       	ldi	r24, 0x89	; 137
     b36:	91 e0       	ldi	r25, 0x01	; 1
     b38:	e9 d3       	rcall	.+2002   	; 0x130c <nokia_lcd_write_string>
     b3a:	6a e0       	ldi	r22, 0x0A	; 10
     b3c:	80 e0       	ldi	r24, 0x00	; 0
					nokia_lcd_set_cursor(0,10);
     b3e:	f8 d3       	rcall	.+2032   	; 0x1330 <nokia_lcd_set_cursor>
     b40:	61 e0       	ldi	r22, 0x01	; 1
     b42:	80 e9       	ldi	r24, 0x90	; 144
     b44:	91 e0       	ldi	r25, 0x01	; 1
					nokia_lcd_write_string("Password",1);
     b46:	e2 d3       	rcall	.+1988   	; 0x130c <nokia_lcd_write_string>
     b48:	64 e1       	ldi	r22, 0x14	; 20
     b4a:	80 e0       	ldi	r24, 0x00	; 0
     b4c:	f1 d3       	rcall	.+2018   	; 0x1330 <nokia_lcd_set_cursor>
     b4e:	61 e0       	ldi	r22, 0x01	; 1
					nokia_lcd_set_cursor(0,20);
     b50:	c8 01       	movw	r24, r16
     b52:	dc d3       	rcall	.+1976   	; 0x130c <nokia_lcd_write_string>
     b54:	f2 d3       	rcall	.+2020   	; 0x133a <nokia_lcd_render>
     b56:	06 c0       	rjmp	.+12     	; 0xb64 <AddUser_Tick+0x442>
					nokia_lcd_write_string(user_password,1);
     b58:	8f e4       	ldi	r24, 0x4F	; 79
     b5a:	93 ec       	ldi	r25, 0xC3	; 195
     b5c:	01 97       	sbiw	r24, 0x01	; 1
     b5e:	f1 f7       	brne	.-4      	; 0xb5c <AddUser_Tick+0x43a>
					nokia_lcd_render();
     b60:	00 c0       	rjmp	.+0      	; 0xb62 <AddUser_Tick+0x440>
     b62:	00 00       	nop
     b64:	63 dc       	rcall	.-1850   	; 0x42c <GetKeypadKey>
     b66:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <keypad_character>
     b6a:	88 23       	and	r24, r24
     b6c:	a9 f3       	breq	.-22     	; 0xb58 <AddUser_Tick+0x436>
     b6e:	06 c0       	rjmp	.+12     	; 0xb7c <AddUser_Tick+0x45a>
     b70:	ef e4       	ldi	r30, 0x4F	; 79
				}
				
				while((keypad_character = GetKeypadKey()) == '\0'){ _delay_ms(200); }
     b72:	f3 ec       	ldi	r31, 0xC3	; 195
     b74:	31 97       	sbiw	r30, 0x01	; 1
     b76:	f1 f7       	brne	.-4      	; 0xb74 <AddUser_Tick+0x452>
     b78:	00 c0       	rjmp	.+0      	; 0xb7a <AddUser_Tick+0x458>
     b7a:	00 00       	nop
     b7c:	57 dc       	rcall	.-1874   	; 0x42c <GetKeypadKey>
     b7e:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <previous_character>
     b82:	90 91 ac 07 	lds	r25, 0x07AC	; 0x8007ac <keypad_character>
     b86:	89 17       	cp	r24, r25
     b88:	99 f3       	breq	.-26     	; 0xb70 <AddUser_Tick+0x44e>
				
				while((previous_character = GetKeypadKey()) == keypad_character){ _delay_ms(200); }
     b8a:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <keypad_character>
     b8e:	83 32       	cpi	r24, 0x23	; 35
     b90:	09 f0       	breq	.+2      	; 0xb94 <AddUser_Tick+0x472>
     b92:	88 cf       	rjmp	.-240    	; 0xaa4 <AddUser_Tick+0x382>
     b94:	31 c2       	rjmp	.+1122   	; 0xff8 <AddUser_Tick+0x8d6>
		
		case userpassword:
			while((keypad_character = GetKeypadKey()) == '\0'){ _delay_ms(200); }
			while((previous_character = GetKeypadKey()) == keypad_character){ _delay_ms(200); }
			
			while(keypad_character != '#'){
     b96:	8f e4       	ldi	r24, 0x4F	; 79
     b98:	93 ec       	ldi	r25, 0xC3	; 195
     b9a:	01 97       	sbiw	r24, 0x01	; 1
     b9c:	f1 f7       	brne	.-4      	; 0xb9a <AddUser_Tick+0x478>
     b9e:	00 c0       	rjmp	.+0      	; 0xba0 <AddUser_Tick+0x47e>
     ba0:	00 00       	nop
     ba2:	44 dc       	rcall	.-1912   	; 0x42c <GetKeypadKey>
     ba4:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <keypad_character>
			}
						
			break;
				
		case confirmpassword:
			while((keypad_character = GetKeypadKey()) == '\0'){ _delay_ms(200); }
     ba8:	88 23       	and	r24, r24
     baa:	a9 f3       	breq	.-22     	; 0xb96 <AddUser_Tick+0x474>
     bac:	06 c0       	rjmp	.+12     	; 0xbba <AddUser_Tick+0x498>
     bae:	ef e4       	ldi	r30, 0x4F	; 79
     bb0:	f3 ec       	ldi	r31, 0xC3	; 195
     bb2:	31 97       	sbiw	r30, 0x01	; 1
     bb4:	f1 f7       	brne	.-4      	; 0xbb2 <AddUser_Tick+0x490>
     bb6:	00 c0       	rjmp	.+0      	; 0xbb8 <AddUser_Tick+0x496>
     bb8:	00 00       	nop
     bba:	38 dc       	rcall	.-1936   	; 0x42c <GetKeypadKey>
     bbc:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <previous_character>
			while((previous_character = GetKeypadKey()) == keypad_character){ _delay_ms(200); }
     bc0:	90 91 ac 07 	lds	r25, 0x07AC	; 0x8007ac <keypad_character>
     bc4:	89 17       	cp	r24, r25
     bc6:	99 f3       	breq	.-26     	; 0xbae <AddUser_Tick+0x48c>
     bc8:	c7 eb       	ldi	r28, 0xB7	; 183
     bca:	d7 e0       	ldi	r29, 0x07	; 7
     bcc:	0f ea       	ldi	r16, 0xAF	; 175
     bce:	17 e0       	ldi	r17, 0x07	; 7
     bd0:	0f 2e       	mov	r0, r31
				if(keypad_character == '*'){
					password_size = 0;
					for(unsigned char i = 0; i < 8; ++i){
						user_compare_password[i] = '\0';
					}
					user_compare_password[0] = '*';
     bd2:	fa e2       	ldi	r31, 0x2A	; 42
     bd4:	ff 2e       	mov	r15, r31
     bd6:	f0 2d       	mov	r31, r0
     bd8:	84 c0       	rjmp	.+264    	; 0xce2 <AddUser_Tick+0x5c0>
     bda:	88 23       	and	r24, r24
     bdc:	09 f4       	brne	.+2      	; 0xbe0 <AddUser_Tick+0x4be>
		case confirmpassword:
			while((keypad_character = GetKeypadKey()) == '\0'){ _delay_ms(200); }
			while((previous_character = GetKeypadKey()) == keypad_character){ _delay_ms(200); }
			
			while(keypad_character != '#'){
				if(keypad_character != '\0' && keypad_character != '*'){
     bde:	6e c0       	rjmp	.+220    	; 0xcbc <AddUser_Tick+0x59a>
     be0:	8a 32       	cpi	r24, 0x2A	; 42
     be2:	09 f4       	brne	.+2      	; 0xbe6 <AddUser_Tick+0x4c4>
     be4:	3d c0       	rjmp	.+122    	; 0xc60 <AddUser_Tick+0x53e>
     be6:	20 91 ad 07 	lds	r18, 0x07AD	; 0x8007ad <password_size>
					if(password_size < 8){
     bea:	30 91 ae 07 	lds	r19, 0x07AE	; 0x8007ae <password_size+0x1>
     bee:	28 30       	cpi	r18, 0x08	; 8
     bf0:	31 05       	cpc	r19, r1
     bf2:	08 f0       	brcs	.+2      	; 0xbf6 <AddUser_Tick+0x4d4>
						user_compare_password[password_size] = keypad_character;
     bf4:	63 c0       	rjmp	.+198    	; 0xcbc <AddUser_Tick+0x59a>
     bf6:	f9 01       	movw	r30, r18
     bf8:	e1 55       	subi	r30, 0x51	; 81
     bfa:	f8 4f       	sbci	r31, 0xF8	; 248
						if(password_size + 1 < 8){
     bfc:	80 83       	st	Z, r24
     bfe:	2f 5f       	subi	r18, 0xFF	; 255
     c00:	3f 4f       	sbci	r19, 0xFF	; 255
							user_compare_password[password_size + 1] = '*';
     c02:	28 30       	cpi	r18, 0x08	; 8
     c04:	31 05       	cpc	r19, r1
						}
						nokia_lcd_clear();
     c06:	20 f4       	brcc	.+8      	; 0xc10 <AddUser_Tick+0x4ee>
     c08:	f9 01       	movw	r30, r18
						nokia_lcd_write_string("Confirm",1);
     c0a:	e1 55       	subi	r30, 0x51	; 81
     c0c:	f8 4f       	sbci	r31, 0xF8	; 248
     c0e:	f0 82       	st	Z, r15
     c10:	97 d2       	rcall	.+1326   	; 0x1140 <nokia_lcd_clear>
						nokia_lcd_set_cursor(0,10);
     c12:	61 e0       	ldi	r22, 0x01	; 1
     c14:	89 e9       	ldi	r24, 0x99	; 153
     c16:	91 e0       	ldi	r25, 0x01	; 1
     c18:	79 d3       	rcall	.+1778   	; 0x130c <nokia_lcd_write_string>
						nokia_lcd_write_string("Password",1);
     c1a:	6a e0       	ldi	r22, 0x0A	; 10
     c1c:	80 e0       	ldi	r24, 0x00	; 0
     c1e:	88 d3       	rcall	.+1808   	; 0x1330 <nokia_lcd_set_cursor>
     c20:	61 e0       	ldi	r22, 0x01	; 1
     c22:	80 e9       	ldi	r24, 0x90	; 144
						nokia_lcd_set_cursor(60,10);
     c24:	91 e0       	ldi	r25, 0x01	; 1
     c26:	72 d3       	rcall	.+1764   	; 0x130c <nokia_lcd_write_string>
     c28:	6a e0       	ldi	r22, 0x0A	; 10
						nokia_lcd_write_char(password_attempt_fails + '0',1);
     c2a:	8c e3       	ldi	r24, 0x3C	; 60
     c2c:	81 d3       	rcall	.+1794   	; 0x1330 <nokia_lcd_set_cursor>
     c2e:	80 91 aa 07 	lds	r24, 0x07AA	; 0x8007aa <password_attempt_fails>
     c32:	61 e0       	ldi	r22, 0x01	; 1
     c34:	80 5d       	subi	r24, 0xD0	; 208
						nokia_lcd_set_cursor(0,20);
     c36:	c0 d2       	rcall	.+1408   	; 0x11b8 <nokia_lcd_write_char>
     c38:	64 e1       	ldi	r22, 0x14	; 20
     c3a:	80 e0       	ldi	r24, 0x00	; 0
     c3c:	79 d3       	rcall	.+1778   	; 0x1330 <nokia_lcd_set_cursor>
						nokia_lcd_write_string(user_compare_password,1);
     c3e:	61 e0       	ldi	r22, 0x01	; 1
     c40:	c8 01       	movw	r24, r16
     c42:	64 d3       	rcall	.+1736   	; 0x130c <nokia_lcd_write_string>
						nokia_lcd_render();
     c44:	7a d3       	rcall	.+1780   	; 0x133a <nokia_lcd_render>
     c46:	80 91 ad 07 	lds	r24, 0x07AD	; 0x8007ad <password_size>
						
						++password_size;
     c4a:	90 91 ae 07 	lds	r25, 0x07AE	; 0x8007ae <password_size+0x1>
     c4e:	01 96       	adiw	r24, 0x01	; 1
     c50:	90 93 ae 07 	sts	0x07AE, r25	; 0x8007ae <password_size+0x1>
     c54:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <password_size>
     c58:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <keypad_character>
					}
					
					
				}
				
				if(keypad_character == '*'){
     c5c:	8a 32       	cpi	r24, 0x2A	; 42
     c5e:	71 f5       	brne	.+92     	; 0xcbc <AddUser_Tick+0x59a>
     c60:	10 92 ae 07 	sts	0x07AE, r1	; 0x8007ae <password_size+0x1>
					password_size = 0;
     c64:	10 92 ad 07 	sts	0x07AD, r1	; 0x8007ad <password_size>
     c68:	ef ea       	ldi	r30, 0xAF	; 175
     c6a:	f7 e0       	ldi	r31, 0x07	; 7
     c6c:	11 92       	st	Z+, r1
					for(unsigned char i = 0; i < 8; ++i){
						user_compare_password[i] = '\0';
     c6e:	ce 17       	cp	r28, r30
					
				}
				
				if(keypad_character == '*'){
					password_size = 0;
					for(unsigned char i = 0; i < 8; ++i){
     c70:	df 07       	cpc	r29, r31
     c72:	e1 f7       	brne	.-8      	; 0xc6c <AddUser_Tick+0x54a>
     c74:	f8 01       	movw	r30, r16
						user_compare_password[i] = '\0';
					}
					user_compare_password[0] = '*';
     c76:	f0 82       	st	Z, r15
     c78:	63 d2       	rcall	.+1222   	; 0x1140 <nokia_lcd_clear>
					nokia_lcd_clear();
     c7a:	61 e0       	ldi	r22, 0x01	; 1
     c7c:	89 e9       	ldi	r24, 0x99	; 153
					nokia_lcd_write_string("Confirm",1);
     c7e:	91 e0       	ldi	r25, 0x01	; 1
     c80:	45 d3       	rcall	.+1674   	; 0x130c <nokia_lcd_write_string>
     c82:	6a e0       	ldi	r22, 0x0A	; 10
     c84:	80 e0       	ldi	r24, 0x00	; 0
     c86:	54 d3       	rcall	.+1704   	; 0x1330 <nokia_lcd_set_cursor>
					nokia_lcd_set_cursor(0,10);
     c88:	61 e0       	ldi	r22, 0x01	; 1
     c8a:	81 ea       	ldi	r24, 0xA1	; 161
     c8c:	91 e0       	ldi	r25, 0x01	; 1
     c8e:	3e d3       	rcall	.+1660   	; 0x130c <nokia_lcd_write_string>
					nokia_lcd_write_string("Password:",1);
     c90:	6a e0       	ldi	r22, 0x0A	; 10
     c92:	8c e3       	ldi	r24, 0x3C	; 60
     c94:	4d d3       	rcall	.+1690   	; 0x1330 <nokia_lcd_set_cursor>
     c96:	80 91 aa 07 	lds	r24, 0x07AA	; 0x8007aa <password_attempt_fails>
					nokia_lcd_set_cursor(60,10);
     c9a:	61 e0       	ldi	r22, 0x01	; 1
     c9c:	80 5d       	subi	r24, 0xD0	; 208
     c9e:	8c d2       	rcall	.+1304   	; 0x11b8 <nokia_lcd_write_char>
     ca0:	64 e1       	ldi	r22, 0x14	; 20
					nokia_lcd_write_char(password_attempt_fails + '0',1);
     ca2:	80 e0       	ldi	r24, 0x00	; 0
     ca4:	45 d3       	rcall	.+1674   	; 0x1330 <nokia_lcd_set_cursor>
     ca6:	61 e0       	ldi	r22, 0x01	; 1
     ca8:	c8 01       	movw	r24, r16
     caa:	30 d3       	rcall	.+1632   	; 0x130c <nokia_lcd_write_string>
     cac:	46 d3       	rcall	.+1676   	; 0x133a <nokia_lcd_render>
					nokia_lcd_set_cursor(0,20);
     cae:	06 c0       	rjmp	.+12     	; 0xcbc <AddUser_Tick+0x59a>
     cb0:	8f e4       	ldi	r24, 0x4F	; 79
     cb2:	93 ec       	ldi	r25, 0xC3	; 195
     cb4:	01 97       	sbiw	r24, 0x01	; 1
					nokia_lcd_write_string(user_compare_password,1);
     cb6:	f1 f7       	brne	.-4      	; 0xcb4 <AddUser_Tick+0x592>
     cb8:	00 c0       	rjmp	.+0      	; 0xcba <AddUser_Tick+0x598>
     cba:	00 00       	nop
     cbc:	b7 db       	rcall	.-2194   	; 0x42c <GetKeypadKey>
					nokia_lcd_render();
     cbe:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <keypad_character>
     cc2:	88 23       	and	r24, r24
     cc4:	a9 f3       	breq	.-22     	; 0xcb0 <AddUser_Tick+0x58e>
     cc6:	06 c0       	rjmp	.+12     	; 0xcd4 <AddUser_Tick+0x5b2>
     cc8:	ef e4       	ldi	r30, 0x4F	; 79
     cca:	f3 ec       	ldi	r31, 0xC3	; 195
     ccc:	31 97       	sbiw	r30, 0x01	; 1
				}
				
				while((keypad_character = GetKeypadKey()) == '\0'){ _delay_ms(200); }
     cce:	f1 f7       	brne	.-4      	; 0xccc <AddUser_Tick+0x5aa>
     cd0:	00 c0       	rjmp	.+0      	; 0xcd2 <AddUser_Tick+0x5b0>
     cd2:	00 00       	nop
     cd4:	ab db       	rcall	.-2218   	; 0x42c <GetKeypadKey>
     cd6:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <previous_character>
     cda:	90 91 ac 07 	lds	r25, 0x07AC	; 0x8007ac <keypad_character>
     cde:	89 17       	cp	r24, r25
     ce0:	99 f3       	breq	.-26     	; 0xcc8 <AddUser_Tick+0x5a6>
     ce2:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <keypad_character>
				
				while((previous_character = GetKeypadKey()) == keypad_character){ _delay_ms(200); }
     ce6:	83 32       	cpi	r24, 0x23	; 35
     ce8:	09 f0       	breq	.+2      	; 0xcec <AddUser_Tick+0x5ca>
     cea:	77 cf       	rjmp	.-274    	; 0xbda <AddUser_Tick+0x4b8>
     cec:	f1 dc       	rcall	.-1566   	; 0x6d0 <password_verification>
     cee:	81 11       	cpse	r24, r1
				
		case confirmpassword:
			while((keypad_character = GetKeypadKey()) == '\0'){ _delay_ms(200); }
			while((previous_character = GetKeypadKey()) == keypad_character){ _delay_ms(200); }
			
			while(keypad_character != '#'){
     cf0:	06 c0       	rjmp	.+12     	; 0xcfe <AddUser_Tick+0x5dc>
     cf2:	80 91 aa 07 	lds	r24, 0x07AA	; 0x8007aa <password_attempt_fails>
     cf6:	8f 5f       	subi	r24, 0xFF	; 255
				while((previous_character = GetKeypadKey()) == keypad_character){ _delay_ms(200); }
				
			}
			
			
			if(!password_verification()){
     cf8:	80 93 aa 07 	sts	0x07AA, r24	; 0x8007aa <password_attempt_fails>
     cfc:	7d c1       	rjmp	.+762    	; 0xff8 <AddUser_Tick+0x8d6>
     cfe:	10 92 aa 07 	sts	0x07AA, r1	; 0x8007aa <password_attempt_fails>
				++password_attempt_fails;
     d02:	80 91 1f 0a 	lds	r24, 0x0A1F	; 0x800a1f <adduser_state>
     d06:	82 30       	cpi	r24, 0x02	; 2
     d08:	09 f4       	brne	.+2      	; 0xd0c <AddUser_Tick+0x5ea>
			}
			
			else{
				password_attempt_fails = 0;
     d0a:	82 c0       	rjmp	.+260    	; 0xe10 <AddUser_Tick+0x6ee>
     d0c:	30 f4       	brcc	.+12     	; 0xd1a <AddUser_Tick+0x5f8>
		default:
			break;
	}
	
	//Transitions
	switch(adduser_state){
     d0e:	88 23       	and	r24, r24
     d10:	21 f1       	breq	.+72     	; 0xd5a <AddUser_Tick+0x638>
     d12:	81 30       	cpi	r24, 0x01	; 1
     d14:	09 f4       	brne	.+2      	; 0xd18 <AddUser_Tick+0x5f6>
     d16:	51 c0       	rjmp	.+162    	; 0xdba <AddUser_Tick+0x698>
     d18:	6c c1       	rjmp	.+728    	; 0xff2 <AddUser_Tick+0x8d0>
     d1a:	84 30       	cpi	r24, 0x04	; 4
     d1c:	09 f4       	brne	.+2      	; 0xd20 <AddUser_Tick+0x5fe>
     d1e:	e0 c0       	rjmp	.+448    	; 0xee0 <AddUser_Tick+0x7be>
     d20:	08 f4       	brcc	.+2      	; 0xd24 <AddUser_Tick+0x602>
     d22:	a2 c0       	rjmp	.+324    	; 0xe68 <AddUser_Tick+0x746>
     d24:	85 30       	cpi	r24, 0x05	; 5
     d26:	09 f4       	brne	.+2      	; 0xd2a <AddUser_Tick+0x608>
     d28:	7b c1       	rjmp	.+758    	; 0x1020 <AddUser_Tick+0x8fe>
     d2a:	63 c1       	rjmp	.+710    	; 0xff2 <AddUser_Tick+0x8d0>
     d2c:	82 30       	cpi	r24, 0x02	; 2
     d2e:	09 f4       	brne	.+2      	; 0xd32 <AddUser_Tick+0x610>
     d30:	6f c0       	rjmp	.+222    	; 0xe10 <AddUser_Tick+0x6ee>
     d32:	30 f4       	brcc	.+12     	; 0xd40 <AddUser_Tick+0x61e>
     d34:	88 23       	and	r24, r24
     d36:	69 f0       	breq	.+26     	; 0xd52 <AddUser_Tick+0x630>
     d38:	81 30       	cpi	r24, 0x01	; 1
     d3a:	09 f4       	brne	.+2      	; 0xd3e <AddUser_Tick+0x61c>
     d3c:	3e c0       	rjmp	.+124    	; 0xdba <AddUser_Tick+0x698>
     d3e:	59 c1       	rjmp	.+690    	; 0xff2 <AddUser_Tick+0x8d0>
     d40:	84 30       	cpi	r24, 0x04	; 4
     d42:	09 f4       	brne	.+2      	; 0xd46 <AddUser_Tick+0x624>
     d44:	c9 c0       	rjmp	.+402    	; 0xed8 <AddUser_Tick+0x7b6>
     d46:	08 f4       	brcc	.+2      	; 0xd4a <AddUser_Tick+0x628>
     d48:	8f c0       	rjmp	.+286    	; 0xe68 <AddUser_Tick+0x746>
     d4a:	85 30       	cpi	r24, 0x05	; 5
     d4c:	09 f4       	brne	.+2      	; 0xd50 <AddUser_Tick+0x62e>
		case username:
			if(keypad_character == '#' && user_name_size > 0){
     d4e:	68 c1       	rjmp	.+720    	; 0x1020 <AddUser_Tick+0x8fe>
     d50:	50 c1       	rjmp	.+672    	; 0xff2 <AddUser_Tick+0x8d0>
     d52:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <keypad_character>
     d56:	83 32       	cpi	r24, 0x23	; 35
     d58:	31 f5       	brne	.+76     	; 0xda6 <AddUser_Tick+0x684>
     d5a:	80 91 c3 07 	lds	r24, 0x07C3	; 0x8007c3 <user_name_size>
				user_name[user_name_size] = '\0';
     d5e:	88 23       	and	r24, r24
     d60:	31 f1       	breq	.+76     	; 0xdae <AddUser_Tick+0x68c>
     d62:	e8 2f       	mov	r30, r24
     d64:	f0 e0       	ldi	r31, 0x00	; 0
     d66:	eb 5f       	subi	r30, 0xFB	; 251
				user_name_size = user_name_size - 1;
     d68:	fe 4f       	sbci	r31, 0xFE	; 254
     d6a:	10 82       	st	Z, r1
				user_weight = 0;
     d6c:	81 50       	subi	r24, 0x01	; 1
     d6e:	80 93 c3 07 	sts	0x07C3, r24	; 0x8007c3 <user_name_size>
				nokia_lcd_clear();
				nokia_lcd_write_string("Enter your",1);
     d72:	10 92 c2 07 	sts	0x07C2, r1	; 0x8007c2 <user_weight>
     d76:	e4 d1       	rcall	.+968    	; 0x1140 <nokia_lcd_clear>
     d78:	61 e0       	ldi	r22, 0x01	; 1
				nokia_lcd_set_cursor(0,10);
     d7a:	80 e5       	ldi	r24, 0x50	; 80
     d7c:	91 e0       	ldi	r25, 0x01	; 1
     d7e:	c6 d2       	rcall	.+1420   	; 0x130c <nokia_lcd_write_string>
				nokia_lcd_write_string("weight in lbs",1);
     d80:	6a e0       	ldi	r22, 0x0A	; 10
     d82:	80 e0       	ldi	r24, 0x00	; 0
     d84:	d5 d2       	rcall	.+1450   	; 0x1330 <nokia_lcd_set_cursor>
     d86:	61 e0       	ldi	r22, 0x01	; 1
				nokia_lcd_set_cursor(0,20);
     d88:	8b e5       	ldi	r24, 0x5B	; 91
     d8a:	91 e0       	ldi	r25, 0x01	; 1
     d8c:	bf d2       	rcall	.+1406   	; 0x130c <nokia_lcd_write_string>
     d8e:	64 e1       	ldi	r22, 0x14	; 20
				nokia_lcd_write_string("_",1);
     d90:	80 e0       	ldi	r24, 0x00	; 0
     d92:	ce d2       	rcall	.+1436   	; 0x1330 <nokia_lcd_set_cursor>
     d94:	61 e0       	ldi	r22, 0x01	; 1
     d96:	8b ea       	ldi	r24, 0xAB	; 171
     d98:	91 e0       	ldi	r25, 0x01	; 1
				nokia_lcd_render();
     d9a:	b8 d2       	rcall	.+1392   	; 0x130c <nokia_lcd_write_string>
     d9c:	ce d2       	rcall	.+1436   	; 0x133a <nokia_lcd_render>
				adduser_state = userweight;
     d9e:	81 e0       	ldi	r24, 0x01	; 1
     da0:	80 93 1f 0a 	sts	0x0A1F, r24	; 0x800a1f <adduser_state>
			}
			
			else if(user_name_size == 0){
     da4:	3d c1       	rjmp	.+634    	; 0x1020 <AddUser_Tick+0x8fe>
     da6:	80 91 c3 07 	lds	r24, 0x07C3	; 0x8007c3 <user_name_size>
				adduser_name_display("_");
     daa:	81 11       	cpse	r24, r1
     dac:	39 c1       	rjmp	.+626    	; 0x1020 <AddUser_Tick+0x8fe>
     dae:	8b ea       	ldi	r24, 0xAB	; 171
				adduser_state = username;
     db0:	91 e0       	ldi	r25, 0x01	; 1
     db2:	7c dc       	rcall	.-1800   	; 0x6ac <adduser_name_display>
			}
			
			break;
		
		case userweight:
			if(user_weight > 90){
     db4:	10 92 1f 0a 	sts	0x0A1F, r1	; 0x800a1f <adduser_state>
     db8:	33 c1       	rjmp	.+614    	; 0x1020 <AddUser_Tick+0x8fe>
     dba:	80 91 c2 07 	lds	r24, 0x07C2	; 0x8007c2 <user_weight>
				user_gender = 0;
				nokia_lcd_clear();
     dbe:	8b 35       	cpi	r24, 0x5B	; 91
				nokia_lcd_write_string("Select Gender",1);
     dc0:	08 f1       	brcs	.+66     	; 0xe04 <AddUser_Tick+0x6e2>
     dc2:	10 92 c1 07 	sts	0x07C1, r1	; 0x8007c1 <user_gender>
     dc6:	bc d1       	rcall	.+888    	; 0x1140 <nokia_lcd_clear>
				nokia_lcd_set_cursor(0,10);
     dc8:	61 e0       	ldi	r22, 0x01	; 1
     dca:	89 e6       	ldi	r24, 0x69	; 105
     dcc:	91 e0       	ldi	r25, 0x01	; 1
     dce:	9e d2       	rcall	.+1340   	; 0x130c <nokia_lcd_write_string>
				nokia_lcd_write_string("1: Male",1);
     dd0:	6a e0       	ldi	r22, 0x0A	; 10
     dd2:	80 e0       	ldi	r24, 0x00	; 0
     dd4:	ad d2       	rcall	.+1370   	; 0x1330 <nokia_lcd_set_cursor>
     dd6:	61 e0       	ldi	r22, 0x01	; 1
     dd8:	87 e7       	ldi	r24, 0x77	; 119
				nokia_lcd_set_cursor(0,20);
     dda:	91 e0       	ldi	r25, 0x01	; 1
     ddc:	97 d2       	rcall	.+1326   	; 0x130c <nokia_lcd_write_string>
     dde:	64 e1       	ldi	r22, 0x14	; 20
     de0:	80 e0       	ldi	r24, 0x00	; 0
				nokia_lcd_write_string("2: Female",1);
     de2:	a6 d2       	rcall	.+1356   	; 0x1330 <nokia_lcd_set_cursor>
     de4:	61 e0       	ldi	r22, 0x01	; 1
     de6:	8f e7       	ldi	r24, 0x7F	; 127
     de8:	91 e0       	ldi	r25, 0x01	; 1
     dea:	90 d2       	rcall	.+1312   	; 0x130c <nokia_lcd_write_string>
				nokia_lcd_set_cursor(0,30);
     dec:	6e e1       	ldi	r22, 0x1E	; 30
     dee:	80 e0       	ldi	r24, 0x00	; 0
     df0:	9f d2       	rcall	.+1342   	; 0x1330 <nokia_lcd_set_cursor>
     df2:	61 e0       	ldi	r22, 0x01	; 1
				nokia_lcd_write_string("_",1);
     df4:	8b ea       	ldi	r24, 0xAB	; 171
     df6:	91 e0       	ldi	r25, 0x01	; 1
     df8:	89 d2       	rcall	.+1298   	; 0x130c <nokia_lcd_write_string>
     dfa:	9f d2       	rcall	.+1342   	; 0x133a <nokia_lcd_render>
				nokia_lcd_render();
     dfc:	82 e0       	ldi	r24, 0x02	; 2
     dfe:	80 93 1f 0a 	sts	0x0A1F, r24	; 0x800a1f <adduser_state>
			
				adduser_state = usergender;
     e02:	0e c1       	rjmp	.+540    	; 0x1020 <AddUser_Tick+0x8fe>
     e04:	10 92 c2 07 	sts	0x07C2, r1	; 0x8007c2 <user_weight>
			}
			
			else{
				user_weight = 0;
     e08:	81 e0       	ldi	r24, 0x01	; 1
				adduser_state = userweight;
     e0a:	80 93 1f 0a 	sts	0x0A1F, r24	; 0x800a1f <adduser_state>
     e0e:	08 c1       	rjmp	.+528    	; 0x1020 <AddUser_Tick+0x8fe>
			}
			
			break;
		
		case usergender:
			if(user_gender != 0){
     e10:	80 91 c1 07 	lds	r24, 0x07C1	; 0x8007c1 <user_gender>
     e14:	88 23       	and	r24, r24
     e16:	09 f4       	brne	.+2      	; 0xe1a <AddUser_Tick+0x6f8>
				password_size = 0;
     e18:	03 c1       	rjmp	.+518    	; 0x1020 <AddUser_Tick+0x8fe>
     e1a:	10 92 ae 07 	sts	0x07AE, r1	; 0x8007ae <password_size+0x1>
     e1e:	10 92 ad 07 	sts	0x07AD, r1	; 0x8007ad <password_size>
     e22:	e8 eb       	ldi	r30, 0xB8	; 184
     e24:	f7 e0       	ldi	r31, 0x07	; 7
				for(unsigned char i = 0; i < 8; ++i){
					user_password[i] = '\0';
     e26:	80 ec       	ldi	r24, 0xC0	; 192
			break;
		
		case usergender:
			if(user_gender != 0){
				password_size = 0;
				for(unsigned char i = 0; i < 8; ++i){
     e28:	97 e0       	ldi	r25, 0x07	; 7
     e2a:	11 92       	st	Z+, r1
					user_password[i] = '\0';
				}
				user_password[0] = '*';
     e2c:	e8 17       	cp	r30, r24
     e2e:	f9 07       	cpc	r31, r25
     e30:	e1 f7       	brne	.-8      	; 0xe2a <AddUser_Tick+0x708>
				nokia_lcd_clear();
     e32:	8a e2       	ldi	r24, 0x2A	; 42
     e34:	80 93 b8 07 	sts	0x07B8, r24	; 0x8007b8 <user_password>
				nokia_lcd_write_string("Create",1);
     e38:	83 d1       	rcall	.+774    	; 0x1140 <nokia_lcd_clear>
     e3a:	61 e0       	ldi	r22, 0x01	; 1
				nokia_lcd_set_cursor(0,10);
     e3c:	89 e8       	ldi	r24, 0x89	; 137
     e3e:	91 e0       	ldi	r25, 0x01	; 1
     e40:	65 d2       	rcall	.+1226   	; 0x130c <nokia_lcd_write_string>
				nokia_lcd_write_string("Password",1);
     e42:	6a e0       	ldi	r22, 0x0A	; 10
     e44:	80 e0       	ldi	r24, 0x00	; 0
     e46:	74 d2       	rcall	.+1256   	; 0x1330 <nokia_lcd_set_cursor>
     e48:	61 e0       	ldi	r22, 0x01	; 1
				nokia_lcd_set_cursor(0,20);
     e4a:	80 e9       	ldi	r24, 0x90	; 144
     e4c:	91 e0       	ldi	r25, 0x01	; 1
     e4e:	5e d2       	rcall	.+1212   	; 0x130c <nokia_lcd_write_string>
				nokia_lcd_write_string("*",1);
     e50:	64 e1       	ldi	r22, 0x14	; 20
     e52:	80 e0       	ldi	r24, 0x00	; 0
     e54:	6d d2       	rcall	.+1242   	; 0x1330 <nokia_lcd_set_cursor>
     e56:	61 e0       	ldi	r22, 0x01	; 1
				nokia_lcd_render();
     e58:	8d ea       	ldi	r24, 0xAD	; 173
     e5a:	91 e0       	ldi	r25, 0x01	; 1
				
				adduser_state = userpassword;
     e5c:	57 d2       	rcall	.+1198   	; 0x130c <nokia_lcd_write_string>
     e5e:	6d d2       	rcall	.+1242   	; 0x133a <nokia_lcd_render>
			}
			
			break;
		
		case userpassword:
			if(password_size == 8){
     e60:	83 e0       	ldi	r24, 0x03	; 3
     e62:	80 93 1f 0a 	sts	0x0A1F, r24	; 0x800a1f <adduser_state>
     e66:	dc c0       	rjmp	.+440    	; 0x1020 <AddUser_Tick+0x8fe>
     e68:	80 91 ad 07 	lds	r24, 0x07AD	; 0x8007ad <password_size>
     e6c:	90 91 ae 07 	lds	r25, 0x07AE	; 0x8007ae <password_size+0x1>
				nokia_lcd_clear();
     e70:	08 97       	sbiw	r24, 0x08	; 8
				nokia_lcd_write_string("Confirm",1);
     e72:	09 f0       	breq	.+2      	; 0xe76 <AddUser_Tick+0x754>
     e74:	d5 c0       	rjmp	.+426    	; 0x1020 <AddUser_Tick+0x8fe>
     e76:	64 d1       	rcall	.+712    	; 0x1140 <nokia_lcd_clear>
     e78:	61 e0       	ldi	r22, 0x01	; 1
     e7a:	89 e9       	ldi	r24, 0x99	; 153
				nokia_lcd_set_cursor(0,10);
     e7c:	91 e0       	ldi	r25, 0x01	; 1
     e7e:	46 d2       	rcall	.+1164   	; 0x130c <nokia_lcd_write_string>
     e80:	6a e0       	ldi	r22, 0x0A	; 10
     e82:	80 e0       	ldi	r24, 0x00	; 0
				nokia_lcd_write_string("Password: ",1);
     e84:	55 d2       	rcall	.+1194   	; 0x1330 <nokia_lcd_set_cursor>
     e86:	61 e0       	ldi	r22, 0x01	; 1
     e88:	8f ea       	ldi	r24, 0xAF	; 175
     e8a:	91 e0       	ldi	r25, 0x01	; 1
     e8c:	3f d2       	rcall	.+1150   	; 0x130c <nokia_lcd_write_string>
				nokia_lcd_set_cursor(60,10);
     e8e:	6a e0       	ldi	r22, 0x0A	; 10
     e90:	8c e3       	ldi	r24, 0x3C	; 60
     e92:	4e d2       	rcall	.+1180   	; 0x1330 <nokia_lcd_set_cursor>
				nokia_lcd_write_char(password_attempt_fails + '0',1);
     e94:	80 91 aa 07 	lds	r24, 0x07AA	; 0x8007aa <password_attempt_fails>
     e98:	61 e0       	ldi	r22, 0x01	; 1
     e9a:	80 5d       	subi	r24, 0xD0	; 208
     e9c:	8d d1       	rcall	.+794    	; 0x11b8 <nokia_lcd_write_char>
				nokia_lcd_set_cursor(0,20);
     e9e:	64 e1       	ldi	r22, 0x14	; 20
     ea0:	80 e0       	ldi	r24, 0x00	; 0
     ea2:	46 d2       	rcall	.+1164   	; 0x1330 <nokia_lcd_set_cursor>
				nokia_lcd_write_string("*",1);
     ea4:	61 e0       	ldi	r22, 0x01	; 1
     ea6:	8d ea       	ldi	r24, 0xAD	; 173
     ea8:	91 e0       	ldi	r25, 0x01	; 1
     eaa:	30 d2       	rcall	.+1120   	; 0x130c <nokia_lcd_write_string>
				nokia_lcd_render();
     eac:	46 d2       	rcall	.+1164   	; 0x133a <nokia_lcd_render>
     eae:	10 92 ae 07 	sts	0x07AE, r1	; 0x8007ae <password_size+0x1>
				password_size = 0;
     eb2:	10 92 ad 07 	sts	0x07AD, r1	; 0x8007ad <password_size>
				password_attempt_fails = 0;
     eb6:	10 92 aa 07 	sts	0x07AA, r1	; 0x8007aa <password_attempt_fails>
     eba:	ef ea       	ldi	r30, 0xAF	; 175
     ebc:	f7 e0       	ldi	r31, 0x07	; 7
				for(unsigned char i = 0; i < 8; ++i){
					user_compare_password[i] = '\0';
     ebe:	87 eb       	ldi	r24, 0xB7	; 183
				nokia_lcd_set_cursor(0,20);
				nokia_lcd_write_string("*",1);
				nokia_lcd_render();
				password_size = 0;
				password_attempt_fails = 0;
				for(unsigned char i = 0; i < 8; ++i){
     ec0:	97 e0       	ldi	r25, 0x07	; 7
     ec2:	11 92       	st	Z+, r1
     ec4:	8e 17       	cp	r24, r30
					user_compare_password[i] = '\0';
				}
				user_compare_password[0] = '*';
     ec6:	9f 07       	cpc	r25, r31
     ec8:	e1 f7       	brne	.-8      	; 0xec2 <AddUser_Tick+0x7a0>
     eca:	8a e2       	ldi	r24, 0x2A	; 42
				adduser_state = confirmpassword;
     ecc:	80 93 af 07 	sts	0x07AF, r24	; 0x8007af <user_compare_password>
     ed0:	84 e0       	ldi	r24, 0x04	; 4
     ed2:	80 93 1f 0a 	sts	0x0A1F, r24	; 0x800a1f <adduser_state>
			}
			
			break;
		
		case confirmpassword:
			if(password_attempt_fails == 0){
     ed6:	a4 c0       	rjmp	.+328    	; 0x1020 <AddUser_Tick+0x8fe>
     ed8:	80 91 aa 07 	lds	r24, 0x07AA	; 0x8007aa <password_attempt_fails>
				nokia_lcd_clear();
     edc:	81 11       	cpse	r24, r1
     ede:	2a c0       	rjmp	.+84     	; 0xf34 <AddUser_Tick+0x812>
				nokia_lcd_write_string(user_name,1);
     ee0:	2f d1       	rcall	.+606    	; 0x1140 <nokia_lcd_clear>
     ee2:	61 e0       	ldi	r22, 0x01	; 1
     ee4:	85 e0       	ldi	r24, 0x05	; 5
     ee6:	91 e0       	ldi	r25, 0x01	; 1
     ee8:	11 d2       	rcall	.+1058   	; 0x130c <nokia_lcd_write_string>
				nokia_lcd_set_cursor(0,10);
     eea:	6a e0       	ldi	r22, 0x0A	; 10
     eec:	80 e0       	ldi	r24, 0x00	; 0
     eee:	20 d2       	rcall	.+1088   	; 0x1330 <nokia_lcd_set_cursor>
     ef0:	61 e0       	ldi	r22, 0x01	; 1
				nokia_lcd_write_string(weight_output,1);
     ef2:	80 e0       	ldi	r24, 0x00	; 0
     ef4:	91 e0       	ldi	r25, 0x01	; 1
     ef6:	0a d2       	rcall	.+1044   	; 0x130c <nokia_lcd_write_string>
     ef8:	6a e0       	ldi	r22, 0x0A	; 10
     efa:	84 e1       	ldi	r24, 0x14	; 20
				nokia_lcd_set_cursor(20,10);
     efc:	19 d2       	rcall	.+1074   	; 0x1330 <nokia_lcd_set_cursor>
     efe:	61 e0       	ldi	r22, 0x01	; 1
     f00:	85 e6       	ldi	r24, 0x65	; 101
     f02:	91 e0       	ldi	r25, 0x01	; 1
				nokia_lcd_write_string("lbs",1);
     f04:	03 d2       	rcall	.+1030   	; 0x130c <nokia_lcd_write_string>
     f06:	64 e1       	ldi	r22, 0x14	; 20
     f08:	80 e0       	ldi	r24, 0x00	; 0
     f0a:	12 d2       	rcall	.+1060   	; 0x1330 <nokia_lcd_set_cursor>
     f0c:	80 91 c1 07 	lds	r24, 0x07C1	; 0x8007c1 <user_gender>
				nokia_lcd_set_cursor(0,20);
     f10:	81 30       	cpi	r24, 0x01	; 1
     f12:	29 f4       	brne	.+10     	; 0xf1e <AddUser_Tick+0x7fc>
     f14:	61 e0       	ldi	r22, 0x01	; 1
				if(user_gender == 1){
     f16:	8a e7       	ldi	r24, 0x7A	; 122
     f18:	91 e0       	ldi	r25, 0x01	; 1
     f1a:	f8 d1       	rcall	.+1008   	; 0x130c <nokia_lcd_write_string>
     f1c:	06 c0       	rjmp	.+12     	; 0xf2a <AddUser_Tick+0x808>
					nokia_lcd_write_string("Male",1);
     f1e:	82 30       	cpi	r24, 0x02	; 2
     f20:	21 f4       	brne	.+8      	; 0xf2a <AddUser_Tick+0x808>
     f22:	61 e0       	ldi	r22, 0x01	; 1
     f24:	82 e8       	ldi	r24, 0x82	; 130
     f26:	91 e0       	ldi	r25, 0x01	; 1
     f28:	f1 d1       	rcall	.+994    	; 0x130c <nokia_lcd_write_string>
				}
				
				else if(user_gender == 2){
     f2a:	07 d2       	rcall	.+1038   	; 0x133a <nokia_lcd_render>
     f2c:	85 e0       	ldi	r24, 0x05	; 5
					nokia_lcd_write_string("Female",1);
     f2e:	80 93 1f 0a 	sts	0x0A1F, r24	; 0x800a1f <adduser_state>
     f32:	76 c0       	rjmp	.+236    	; 0x1020 <AddUser_Tick+0x8fe>
     f34:	83 30       	cpi	r24, 0x03	; 3
     f36:	71 f5       	brne	.+92     	; 0xf94 <AddUser_Tick+0x872>
				}
				
				nokia_lcd_render();
     f38:	03 d1       	rcall	.+518    	; 0x1140 <nokia_lcd_clear>
     f3a:	61 e0       	ldi	r22, 0x01	; 1
				adduser_state = adduser_finished; 
     f3c:	89 e8       	ldi	r24, 0x89	; 137
     f3e:	91 e0       	ldi	r25, 0x01	; 1
     f40:	e5 d1       	rcall	.+970    	; 0x130c <nokia_lcd_write_string>
     f42:	6a e0       	ldi	r22, 0x0A	; 10
			}
				
			else if(password_attempt_fails == 3){
     f44:	80 e0       	ldi	r24, 0x00	; 0
     f46:	f4 d1       	rcall	.+1000   	; 0x1330 <nokia_lcd_set_cursor>
				nokia_lcd_clear();
     f48:	61 e0       	ldi	r22, 0x01	; 1
     f4a:	80 e9       	ldi	r24, 0x90	; 144
				nokia_lcd_write_string("Create",1);
     f4c:	91 e0       	ldi	r25, 0x01	; 1
     f4e:	de d1       	rcall	.+956    	; 0x130c <nokia_lcd_write_string>
     f50:	64 e1       	ldi	r22, 0x14	; 20
     f52:	80 e0       	ldi	r24, 0x00	; 0
     f54:	ed d1       	rcall	.+986    	; 0x1330 <nokia_lcd_set_cursor>
				nokia_lcd_set_cursor(0,10);
     f56:	61 e0       	ldi	r22, 0x01	; 1
     f58:	8d ea       	ldi	r24, 0xAD	; 173
     f5a:	91 e0       	ldi	r25, 0x01	; 1
     f5c:	d7 d1       	rcall	.+942    	; 0x130c <nokia_lcd_write_string>
				nokia_lcd_write_string("Password",1);
     f5e:	ed d1       	rcall	.+986    	; 0x133a <nokia_lcd_render>
     f60:	10 92 aa 07 	sts	0x07AA, r1	; 0x8007aa <password_attempt_fails>
     f64:	10 92 ae 07 	sts	0x07AE, r1	; 0x8007ae <password_size+0x1>
				nokia_lcd_set_cursor(0,20);
     f68:	10 92 ad 07 	sts	0x07AD, r1	; 0x8007ad <password_size>
     f6c:	e8 eb       	ldi	r30, 0xB8	; 184
     f6e:	f7 e0       	ldi	r31, 0x07	; 7
				nokia_lcd_write_string("*",1);
     f70:	af ea       	ldi	r26, 0xAF	; 175
     f72:	b7 e0       	ldi	r27, 0x07	; 7
     f74:	80 ec       	ldi	r24, 0xC0	; 192
     f76:	97 e0       	ldi	r25, 0x07	; 7
     f78:	11 92       	st	Z+, r1
				nokia_lcd_render();
     f7a:	1d 92       	st	X+, r1
     f7c:	8e 17       	cp	r24, r30
				password_attempt_fails = 0;
     f7e:	9f 07       	cpc	r25, r31
     f80:	d9 f7       	brne	.-10     	; 0xf78 <AddUser_Tick+0x856>
				password_size = 0;
     f82:	8a e2       	ldi	r24, 0x2A	; 42
     f84:	80 93 b8 07 	sts	0x07B8, r24	; 0x8007b8 <user_password>
     f88:	10 92 af 07 	sts	0x07AF, r1	; 0x8007af <user_compare_password>
     f8c:	83 e0       	ldi	r24, 0x03	; 3
     f8e:	80 93 1f 0a 	sts	0x0A1F, r24	; 0x800a1f <adduser_state>
     f92:	46 c0       	rjmp	.+140    	; 0x1020 <AddUser_Tick+0x8fe>
     f94:	d5 d0       	rcall	.+426    	; 0x1140 <nokia_lcd_clear>
				for(unsigned char i = 0; i < 8; ++i){
					user_password[i] = '\0';
     f96:	61 e0       	ldi	r22, 0x01	; 1
					user_compare_password[i] = '\0';
     f98:	89 e9       	ldi	r24, 0x99	; 153
				nokia_lcd_set_cursor(0,20);
				nokia_lcd_write_string("*",1);
				nokia_lcd_render();
				password_attempt_fails = 0;
				password_size = 0;
				for(unsigned char i = 0; i < 8; ++i){
     f9a:	91 e0       	ldi	r25, 0x01	; 1
     f9c:	b7 d1       	rcall	.+878    	; 0x130c <nokia_lcd_write_string>
     f9e:	6a e0       	ldi	r22, 0x0A	; 10
					user_password[i] = '\0';
					user_compare_password[i] = '\0';
				}
				user_password[0] = '*';
     fa0:	80 e0       	ldi	r24, 0x00	; 0
     fa2:	c6 d1       	rcall	.+908    	; 0x1330 <nokia_lcd_set_cursor>
     fa4:	61 e0       	ldi	r22, 0x01	; 1
				user_compare_password[0] = '\0';
     fa6:	8f ea       	ldi	r24, 0xAF	; 175
     fa8:	91 e0       	ldi	r25, 0x01	; 1
				
				adduser_state = userpassword;
     faa:	b0 d1       	rcall	.+864    	; 0x130c <nokia_lcd_write_string>
     fac:	6a e0       	ldi	r22, 0x0A	; 10
     fae:	8c e3       	ldi	r24, 0x3C	; 60
     fb0:	bf d1       	rcall	.+894    	; 0x1330 <nokia_lcd_set_cursor>
			}
			
			else{
				nokia_lcd_clear();
     fb2:	80 91 aa 07 	lds	r24, 0x07AA	; 0x8007aa <password_attempt_fails>
				nokia_lcd_write_string("Confirm",1);
     fb6:	61 e0       	ldi	r22, 0x01	; 1
     fb8:	80 5d       	subi	r24, 0xD0	; 208
     fba:	fe d0       	rcall	.+508    	; 0x11b8 <nokia_lcd_write_char>
     fbc:	64 e1       	ldi	r22, 0x14	; 20
     fbe:	80 e0       	ldi	r24, 0x00	; 0
				nokia_lcd_set_cursor(0,10);
     fc0:	b7 d1       	rcall	.+878    	; 0x1330 <nokia_lcd_set_cursor>
     fc2:	61 e0       	ldi	r22, 0x01	; 1
     fc4:	8d ea       	ldi	r24, 0xAD	; 173
     fc6:	91 e0       	ldi	r25, 0x01	; 1
				nokia_lcd_write_string("Password: ",1);
     fc8:	a1 d1       	rcall	.+834    	; 0x130c <nokia_lcd_write_string>
     fca:	b7 d1       	rcall	.+878    	; 0x133a <nokia_lcd_render>
     fcc:	10 92 ae 07 	sts	0x07AE, r1	; 0x8007ae <password_size+0x1>
     fd0:	10 92 ad 07 	sts	0x07AD, r1	; 0x8007ad <password_size>
				nokia_lcd_set_cursor(60,10);
     fd4:	ef ea       	ldi	r30, 0xAF	; 175
     fd6:	f7 e0       	ldi	r31, 0x07	; 7
     fd8:	87 eb       	ldi	r24, 0xB7	; 183
				nokia_lcd_write_char(password_attempt_fails + '0',1);
     fda:	97 e0       	ldi	r25, 0x07	; 7
     fdc:	11 92       	st	Z+, r1
     fde:	8e 17       	cp	r24, r30
     fe0:	9f 07       	cpc	r25, r31
     fe2:	e1 f7       	brne	.-8      	; 0xfdc <AddUser_Tick+0x8ba>
     fe4:	8a e2       	ldi	r24, 0x2A	; 42
				nokia_lcd_set_cursor(0,20);
     fe6:	80 93 af 07 	sts	0x07AF, r24	; 0x8007af <user_compare_password>
     fea:	84 e0       	ldi	r24, 0x04	; 4
     fec:	80 93 1f 0a 	sts	0x0A1F, r24	; 0x800a1f <adduser_state>
				nokia_lcd_write_string("*",1);
     ff0:	17 c0       	rjmp	.+46     	; 0x1020 <AddUser_Tick+0x8fe>
     ff2:	10 92 1f 0a 	sts	0x0A1F, r1	; 0x800a1f <adduser_state>
     ff6:	14 c0       	rjmp	.+40     	; 0x1020 <AddUser_Tick+0x8fe>
				nokia_lcd_render();
     ff8:	80 91 1f 0a 	lds	r24, 0x0A1F	; 0x800a1f <adduser_state>
				password_size = 0;
     ffc:	82 30       	cpi	r24, 0x02	; 2
     ffe:	09 f4       	brne	.+2      	; 0x1002 <AddUser_Tick+0x8e0>
    1000:	07 cf       	rjmp	.-498    	; 0xe10 <AddUser_Tick+0x6ee>
    1002:	38 f4       	brcc	.+14     	; 0x1012 <AddUser_Tick+0x8f0>
    1004:	88 23       	and	r24, r24
    1006:	09 f4       	brne	.+2      	; 0x100a <AddUser_Tick+0x8e8>
    1008:	a8 ce       	rjmp	.-688    	; 0xd5a <AddUser_Tick+0x638>
    100a:	81 30       	cpi	r24, 0x01	; 1
				for(unsigned char i = 0; i < 8; ++i){
					user_compare_password[i] = '\0';
    100c:	09 f4       	brne	.+2      	; 0x1010 <AddUser_Tick+0x8ee>
				nokia_lcd_write_char(password_attempt_fails + '0',1);
				nokia_lcd_set_cursor(0,20);
				nokia_lcd_write_string("*",1);
				nokia_lcd_render();
				password_size = 0;
				for(unsigned char i = 0; i < 8; ++i){
    100e:	d5 ce       	rjmp	.-598    	; 0xdba <AddUser_Tick+0x698>
    1010:	f0 cf       	rjmp	.-32     	; 0xff2 <AddUser_Tick+0x8d0>
    1012:	84 30       	cpi	r24, 0x04	; 4
					user_compare_password[i] = '\0';
				}
				user_compare_password[0] = '*';
    1014:	09 f4       	brne	.+2      	; 0x1018 <AddUser_Tick+0x8f6>
    1016:	60 cf       	rjmp	.-320    	; 0xed8 <AddUser_Tick+0x7b6>
    1018:	08 f4       	brcc	.+2      	; 0x101c <AddUser_Tick+0x8fa>
				adduser_state = confirmpassword;
    101a:	26 cf       	rjmp	.-436    	; 0xe68 <AddUser_Tick+0x746>
    101c:	85 30       	cpi	r24, 0x05	; 5
    101e:	49 f7       	brne	.-46     	; 0xff2 <AddUser_Tick+0x8d0>
    1020:	df 91       	pop	r29
		case adduser_finished:
			adduser_state = adduser_finished;
			break;
		
		default:
			adduser_state = username;
    1022:	cf 91       	pop	r28
    1024:	1f 91       	pop	r17
			break;
	}
}
    1026:	0f 91       	pop	r16
		default:
			break;
	}
	
	//Transitions
	switch(adduser_state){
    1028:	ff 90       	pop	r15
    102a:	08 95       	ret

0000102c <AddUserTask>:
    102c:	6a db       	rcall	.-2348   	; 0x702 <AddUser_Init>
    102e:	79 db       	rcall	.-2318   	; 0x722 <AddUser_Tick>
    1030:	84 e6       	ldi	r24, 0x64	; 100
    1032:	90 e0       	ldi	r25, 0x00	; 0
    1034:	a1 d5       	rcall	.+2882   	; 0x1b78 <vTaskDelay>
    1036:	fb cf       	rjmp	.-10     	; 0x102e <AddUserTask+0x2>

00001038 <AddUserPulse>:
    1038:	af 92       	push	r10
    103a:	bf 92       	push	r11
    103c:	cf 92       	push	r12
    103e:	df 92       	push	r13
    1040:	ef 92       	push	r14
    1042:	ff 92       	push	r15
    1044:	0f 93       	push	r16
    1046:	a1 2c       	mov	r10, r1
    1048:	b1 2c       	mov	r11, r1
    104a:	c1 2c       	mov	r12, r1
    104c:	d1 2c       	mov	r13, r1
    104e:	e1 2c       	mov	r14, r1
		
		default:
			adduser_state = username;
			break;
	}
}
    1050:	f1 2c       	mov	r15, r1
    1052:	08 2f       	mov	r16, r24
    1054:	20 e0       	ldi	r18, 0x00	; 0
    1056:	30 e0       	ldi	r19, 0x00	; 0
    1058:	45 e5       	ldi	r20, 0x55	; 85
    105a:	50 e0       	ldi	r21, 0x00	; 0
	}
}

void AddUserPulse(unsigned portBASE_TYPE Priority)
{
	xTaskCreate(AddUserTask, (signed portCHAR *)"AddUserTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
    105c:	6a eb       	ldi	r22, 0xBA	; 186
    105e:	71 e0       	ldi	r23, 0x01	; 1
    1060:	86 e1       	ldi	r24, 0x16	; 22
    1062:	98 e0       	ldi	r25, 0x08	; 8
    1064:	11 d3       	rcall	.+1570   	; 0x1688 <xTaskGenericCreate>
}
    1066:	0f 91       	pop	r16
    1068:	ff 90       	pop	r15
    106a:	ef 90       	pop	r14
    106c:	df 90       	pop	r13
    106e:	cf 90       	pop	r12
    1070:	bf 90       	pop	r11
    1072:	af 90       	pop	r10
    1074:	08 95       	ret

00001076 <main>:

int main(void)
{
	DDRC = 0x0F;	//Set PC7...PC3 to input, PC2...PC0 to output [0000 1111]
    1076:	8f e0       	ldi	r24, 0x0F	; 15
    1078:	87 b9       	out	0x07, r24	; 7
	PORTC = 0xF0;	//Init port C to 1s							[1111 0000]
    107a:	80 ef       	ldi	r24, 0xF0	; 240
    107c:	88 b9       	out	0x08, r24	; 8
	DDRD = 0xFF;	//Set Port D to output
    107e:	8f ef       	ldi	r24, 0xFF	; 255
    1080:	8a b9       	out	0x0a, r24	; 10
	PORTD = 0x00;	//Init Port D to 0s
    1082:	1b b8       	out	0x0b, r1	; 11
	nokia_lcd_init();
    1084:	27 d0       	rcall	.+78     	; 0x10d4 <nokia_lcd_init>
    //Start Tasks
    AddUserPulse(1);
    1086:	81 e0       	ldi	r24, 0x01	; 1
    //RunSchedular
    vTaskStartScheduler();
    1088:	d7 df       	rcall	.-82     	; 0x1038 <AddUserPulse>
    108a:	ff d3       	rcall	.+2046   	; 0x188a <vTaskStartScheduler>
}
    108c:	80 e0       	ldi	r24, 0x00	; 0
    108e:	90 e0       	ldi	r25, 0x00	; 0
    1090:	08 95       	ret

00001092 <write>:
		nokia_lcd.screen[i] = 0x00;
}

void nokia_lcd_power(uint8_t on)
{
	write_cmd(on ? 0x20 : 0x24);
    1092:	59 98       	cbi	0x0b, 1	; 11
    1094:	66 23       	and	r22, r22
    1096:	11 f0       	breq	.+4      	; 0x109c <write+0xa>
    1098:	5b 9a       	sbi	0x0b, 3	; 11
    109a:	15 c0       	rjmp	.+42     	; 0x10c6 <write+0x34>
    109c:	5b 98       	cbi	0x0b, 3	; 11
    109e:	13 c0       	rjmp	.+38     	; 0x10c6 <write+0x34>
    10a0:	ac 01       	movw	r20, r24
    10a2:	02 2e       	mov	r0, r18
    10a4:	02 c0       	rjmp	.+4      	; 0x10aa <write+0x18>
    10a6:	55 95       	asr	r21
    10a8:	47 95       	ror	r20
    10aa:	0a 94       	dec	r0
    10ac:	e2 f7       	brpl	.-8      	; 0x10a6 <write+0x14>
    10ae:	40 ff       	sbrs	r20, 0
    10b0:	02 c0       	rjmp	.+4      	; 0x10b6 <write+0x24>
    10b2:	5c 9a       	sbi	0x0b, 4	; 11
    10b4:	01 c0       	rjmp	.+2      	; 0x10b8 <write+0x26>
    10b6:	5c 98       	cbi	0x0b, 4	; 11
    10b8:	5d 9a       	sbi	0x0b, 5	; 11
    10ba:	5d 98       	cbi	0x0b, 5	; 11
    10bc:	21 50       	subi	r18, 0x01	; 1
    10be:	31 09       	sbc	r19, r1
    10c0:	78 f7       	brcc	.-34     	; 0x10a0 <write+0xe>
    10c2:	59 9a       	sbi	0x0b, 1	; 11
    10c4:	08 95       	ret
    10c6:	27 e0       	ldi	r18, 0x07	; 7
    10c8:	30 e0       	ldi	r19, 0x00	; 0
    10ca:	90 e0       	ldi	r25, 0x00	; 0
    10cc:	e9 cf       	rjmp	.-46     	; 0x10a0 <write+0xe>

000010ce <write_cmd>:
    10ce:	60 e0       	ldi	r22, 0x00	; 0
    10d0:	e0 cf       	rjmp	.-64     	; 0x1092 <write>
    10d2:	08 95       	ret

000010d4 <nokia_lcd_init>:
    10d4:	cf 93       	push	r28
    10d6:	df 93       	push	r29
    10d8:	51 9a       	sbi	0x0a, 1	; 10
    10da:	52 9a       	sbi	0x0a, 2	; 10
    10dc:	53 9a       	sbi	0x0a, 3	; 10
    10de:	54 9a       	sbi	0x0a, 4	; 10
    10e0:	55 9a       	sbi	0x0a, 5	; 10
    10e2:	5a 9a       	sbi	0x0b, 2	; 11
    10e4:	59 9a       	sbi	0x0b, 1	; 11
    10e6:	83 ec       	ldi	r24, 0xC3	; 195
    10e8:	99 e0       	ldi	r25, 0x09	; 9
    10ea:	01 97       	sbiw	r24, 0x01	; 1
    10ec:	f1 f7       	brne	.-4      	; 0x10ea <nokia_lcd_init+0x16>
    10ee:	00 c0       	rjmp	.+0      	; 0x10f0 <nokia_lcd_init+0x1c>
    10f0:	00 00       	nop
    10f2:	5a 98       	cbi	0x0b, 2	; 11
    10f4:	8b e5       	ldi	r24, 0x5B	; 91
    10f6:	94 e4       	ldi	r25, 0x44	; 68
    10f8:	01 97       	sbiw	r24, 0x01	; 1
    10fa:	f1 f7       	brne	.-4      	; 0x10f8 <nokia_lcd_init+0x24>
    10fc:	00 c0       	rjmp	.+0      	; 0x10fe <nokia_lcd_init+0x2a>
    10fe:	00 00       	nop
    1100:	5a 9a       	sbi	0x0b, 2	; 11
    1102:	59 98       	cbi	0x0b, 1	; 11
    1104:	81 e2       	ldi	r24, 0x21	; 33
    1106:	e3 df       	rcall	.-58     	; 0x10ce <write_cmd>
    1108:	83 e1       	ldi	r24, 0x13	; 19
    110a:	e1 df       	rcall	.-62     	; 0x10ce <write_cmd>
    110c:	86 e0       	ldi	r24, 0x06	; 6
    110e:	df df       	rcall	.-66     	; 0x10ce <write_cmd>
    1110:	82 ec       	ldi	r24, 0xC2	; 194
    1112:	dd df       	rcall	.-70     	; 0x10ce <write_cmd>
    1114:	80 e2       	ldi	r24, 0x20	; 32
    1116:	db df       	rcall	.-74     	; 0x10ce <write_cmd>
    1118:	89 e0       	ldi	r24, 0x09	; 9
    111a:	d9 df       	rcall	.-78     	; 0x10ce <write_cmd>
    111c:	80 e8       	ldi	r24, 0x80	; 128
    111e:	d7 df       	rcall	.-82     	; 0x10ce <write_cmd>
    1120:	80 e4       	ldi	r24, 0x40	; 64
    1122:	d5 df       	rcall	.-86     	; 0x10ce <write_cmd>
    1124:	c8 ef       	ldi	r28, 0xF8	; 248
    1126:	d1 e0       	ldi	r29, 0x01	; 1
    1128:	61 e0       	ldi	r22, 0x01	; 1
    112a:	80 e0       	ldi	r24, 0x00	; 0
    112c:	b2 df       	rcall	.-156    	; 0x1092 <write>
    112e:	21 97       	sbiw	r28, 0x01	; 1
    1130:	d9 f7       	brne	.-10     	; 0x1128 <nokia_lcd_init+0x54>
    1132:	88 e0       	ldi	r24, 0x08	; 8
    1134:	cc df       	rcall	.-104    	; 0x10ce <write_cmd>
    1136:	8c e0       	ldi	r24, 0x0C	; 12
    1138:	ca df       	rcall	.-108    	; 0x10ce <write_cmd>
    113a:	df 91       	pop	r29
    113c:	cf 91       	pop	r28
    113e:	08 95       	ret

00001140 <nokia_lcd_clear>:
    1140:	80 e8       	ldi	r24, 0x80	; 128
    1142:	c5 df       	rcall	.-118    	; 0x10ce <write_cmd>
    1144:	80 e4       	ldi	r24, 0x40	; 64
    1146:	c3 df       	rcall	.-122    	; 0x10ce <write_cmd>
    1148:	10 92 c3 09 	sts	0x09C3, r1	; 0x8009c3 <nokia_lcd+0x1f8>
    114c:	10 92 c4 09 	sts	0x09C4, r1	; 0x8009c4 <nokia_lcd+0x1f9>
    1150:	eb ec       	ldi	r30, 0xCB	; 203
    1152:	f7 e0       	ldi	r31, 0x07	; 7
    1154:	83 ec       	ldi	r24, 0xC3	; 195
    1156:	99 e0       	ldi	r25, 0x09	; 9
    1158:	11 92       	st	Z+, r1
    115a:	e8 17       	cp	r30, r24
    115c:	f9 07       	cpc	r31, r25
    115e:	e1 f7       	brne	.-8      	; 0x1158 <nokia_lcd_clear+0x18>
    1160:	08 95       	ret

00001162 <nokia_lcd_set_pixel>:
}

void nokia_lcd_set_pixel(uint8_t x, uint8_t y, uint8_t value)
{
	uint8_t *byte = &nokia_lcd.screen[y/8*84+x];
    1162:	26 2f       	mov	r18, r22
    1164:	26 95       	lsr	r18
    1166:	26 95       	lsr	r18
    1168:	26 95       	lsr	r18
    116a:	90 e0       	ldi	r25, 0x00	; 0
    116c:	34 e5       	ldi	r19, 0x54	; 84
    116e:	23 9f       	mul	r18, r19
    1170:	80 0d       	add	r24, r0
    1172:	91 1d       	adc	r25, r1
    1174:	11 24       	eor	r1, r1
	if (value)
    1176:	44 23       	and	r20, r20
    1178:	79 f0       	breq	.+30     	; 0x1198 <nokia_lcd_set_pixel+0x36>
		*byte |= (1 << (y % 8));
    117a:	fc 01       	movw	r30, r24
    117c:	e5 53       	subi	r30, 0x35	; 53
    117e:	f8 4f       	sbci	r31, 0xF8	; 248
    1180:	67 70       	andi	r22, 0x07	; 7
    1182:	81 e0       	ldi	r24, 0x01	; 1
    1184:	90 e0       	ldi	r25, 0x00	; 0
    1186:	02 c0       	rjmp	.+4      	; 0x118c <nokia_lcd_set_pixel+0x2a>
    1188:	88 0f       	add	r24, r24
    118a:	99 1f       	adc	r25, r25
    118c:	6a 95       	dec	r22
    118e:	e2 f7       	brpl	.-8      	; 0x1188 <nokia_lcd_set_pixel+0x26>
    1190:	90 81       	ld	r25, Z
    1192:	89 2b       	or	r24, r25
    1194:	80 83       	st	Z, r24
    1196:	08 95       	ret
	else
		*byte &= ~(1 << (y %8 ));
    1198:	fc 01       	movw	r30, r24
    119a:	e5 53       	subi	r30, 0x35	; 53
    119c:	f8 4f       	sbci	r31, 0xF8	; 248
    119e:	67 70       	andi	r22, 0x07	; 7
    11a0:	81 e0       	ldi	r24, 0x01	; 1
    11a2:	90 e0       	ldi	r25, 0x00	; 0
    11a4:	02 c0       	rjmp	.+4      	; 0x11aa <nokia_lcd_set_pixel+0x48>
    11a6:	88 0f       	add	r24, r24
    11a8:	99 1f       	adc	r25, r25
    11aa:	6a 95       	dec	r22
    11ac:	e2 f7       	brpl	.-8      	; 0x11a6 <nokia_lcd_set_pixel+0x44>
    11ae:	80 95       	com	r24
    11b0:	90 81       	ld	r25, Z
    11b2:	89 23       	and	r24, r25
    11b4:	80 83       	st	Z, r24
    11b6:	08 95       	ret

000011b8 <nokia_lcd_write_char>:
}

void nokia_lcd_write_char(char code, uint8_t scale)
{
    11b8:	5f 92       	push	r5
    11ba:	6f 92       	push	r6
    11bc:	7f 92       	push	r7
    11be:	8f 92       	push	r8
    11c0:	9f 92       	push	r9
    11c2:	af 92       	push	r10
    11c4:	bf 92       	push	r11
    11c6:	cf 92       	push	r12
    11c8:	df 92       	push	r13
    11ca:	ef 92       	push	r14
    11cc:	ff 92       	push	r15
    11ce:	0f 93       	push	r16
    11d0:	1f 93       	push	r17
    11d2:	cf 93       	push	r28
    11d4:	df 93       	push	r29
    11d6:	56 2e       	mov	r5, r22
	register uint8_t x, y;

	for (x = 0; x < 5*scale; x++)
    11d8:	26 2f       	mov	r18, r22
    11da:	30 e0       	ldi	r19, 0x00	; 0
    11dc:	49 01       	movw	r8, r18
    11de:	88 0c       	add	r8, r8
    11e0:	99 1c       	adc	r9, r9
    11e2:	88 0c       	add	r8, r8
    11e4:	99 1c       	adc	r9, r9
    11e6:	82 0e       	add	r8, r18
    11e8:	93 1e       	adc	r9, r19
    11ea:	18 14       	cp	r1, r8
    11ec:	19 04       	cpc	r1, r9
    11ee:	0c f0       	brlt	.+2      	; 0x11f2 <nokia_lcd_write_char+0x3a>
    11f0:	59 c0       	rjmp	.+178    	; 0x12a4 <nokia_lcd_write_char+0xec>
		for (y = 0; y < 7*scale; y++)
    11f2:	89 01       	movw	r16, r18
    11f4:	00 0f       	add	r16, r16
    11f6:	11 1f       	adc	r17, r17
    11f8:	00 0f       	add	r16, r16
    11fa:	11 1f       	adc	r17, r17
    11fc:	00 0f       	add	r16, r16
    11fe:	11 1f       	adc	r17, r17
    1200:	02 1b       	sub	r16, r18
    1202:	13 0b       	sbc	r17, r19
    1204:	61 2c       	mov	r6, r1
			if (pgm_read_byte(&CHARSET[code-32][x/scale]) & (1 << y/scale))
    1206:	a8 2e       	mov	r10, r24
    1208:	b1 2c       	mov	r11, r1
    120a:	c5 01       	movw	r24, r10
    120c:	80 97       	sbiw	r24, 0x20	; 32
    120e:	5c 01       	movw	r10, r24
    1210:	aa 0c       	add	r10, r10
    1212:	bb 1c       	adc	r11, r11
    1214:	aa 0c       	add	r10, r10
    1216:	bb 1c       	adc	r11, r11
    1218:	a8 0e       	add	r10, r24
    121a:	b9 1e       	adc	r11, r25
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 1);
			else
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 0);
    121c:	0f 2e       	mov	r0, r31
    121e:	f4 ec       	ldi	r31, 0xC4	; 196
    1220:	cf 2e       	mov	r12, r31
    1222:	f9 e0       	ldi	r31, 0x09	; 9
    1224:	df 2e       	mov	r13, r31
    1226:	f0 2d       	mov	r31, r0
    1228:	0f 2e       	mov	r0, r31
    122a:	f3 ec       	ldi	r31, 0xC3	; 195
    122c:	ef 2e       	mov	r14, r31
    122e:	f9 e0       	ldi	r31, 0x09	; 9
    1230:	ff 2e       	mov	r15, r31
    1232:	f0 2d       	mov	r31, r0
    1234:	2a c0       	rjmp	.+84     	; 0x128a <nokia_lcd_write_char+0xd2>
{
	register uint8_t x, y;

	for (x = 0; x < 5*scale; x++)
		for (y = 0; y < 7*scale; y++)
			if (pgm_read_byte(&CHARSET[code-32][x/scale]) & (1 << y/scale))
    1236:	fe 01       	movw	r30, r28
    1238:	24 91       	lpm	r18, Z
    123a:	30 e0       	ldi	r19, 0x00	; 0
    123c:	87 2d       	mov	r24, r7
    123e:	65 2d       	mov	r22, r5
    1240:	5c d5       	rcall	.+2744   	; 0x1cfa <__udivmodqi4>
    1242:	02 c0       	rjmp	.+4      	; 0x1248 <nokia_lcd_write_char+0x90>
    1244:	35 95       	asr	r19
    1246:	27 95       	ror	r18
    1248:	8a 95       	dec	r24
    124a:	e2 f7       	brpl	.-8      	; 0x1244 <nokia_lcd_write_char+0x8c>
    124c:	20 ff       	sbrs	r18, 0
    124e:	09 c0       	rjmp	.+18     	; 0x1262 <nokia_lcd_write_char+0xaa>
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 1);
    1250:	f6 01       	movw	r30, r12
    1252:	60 81       	ld	r22, Z
    1254:	67 0d       	add	r22, r7
    1256:	f7 01       	movw	r30, r14
    1258:	80 81       	ld	r24, Z
    125a:	41 e0       	ldi	r20, 0x01	; 1
    125c:	86 0d       	add	r24, r6
    125e:	81 df       	rcall	.-254    	; 0x1162 <nokia_lcd_set_pixel>
    1260:	08 c0       	rjmp	.+16     	; 0x1272 <nokia_lcd_write_char+0xba>
			else
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 0);
    1262:	f6 01       	movw	r30, r12
    1264:	60 81       	ld	r22, Z
    1266:	67 0d       	add	r22, r7
    1268:	f7 01       	movw	r30, r14
    126a:	80 81       	ld	r24, Z
    126c:	40 e0       	ldi	r20, 0x00	; 0
    126e:	86 0d       	add	r24, r6
    1270:	78 df       	rcall	.-272    	; 0x1162 <nokia_lcd_set_pixel>
void nokia_lcd_write_char(char code, uint8_t scale)
{
	register uint8_t x, y;

	for (x = 0; x < 5*scale; x++)
		for (y = 0; y < 7*scale; y++)
    1272:	73 94       	inc	r7
    1274:	87 2d       	mov	r24, r7
    1276:	90 e0       	ldi	r25, 0x00	; 0
    1278:	80 17       	cp	r24, r16
    127a:	91 07       	cpc	r25, r17
    127c:	e4 f2       	brlt	.-72     	; 0x1236 <nokia_lcd_write_char+0x7e>

void nokia_lcd_write_char(char code, uint8_t scale)
{
	register uint8_t x, y;

	for (x = 0; x < 5*scale; x++)
    127e:	63 94       	inc	r6
    1280:	86 2d       	mov	r24, r6
    1282:	90 e0       	ldi	r25, 0x00	; 0
    1284:	88 15       	cp	r24, r8
    1286:	99 05       	cpc	r25, r9
    1288:	6c f4       	brge	.+26     	; 0x12a4 <nokia_lcd_write_char+0xec>
		for (y = 0; y < 7*scale; y++)
    128a:	10 16       	cp	r1, r16
    128c:	11 06       	cpc	r1, r17
			if (pgm_read_byte(&CHARSET[code-32][x/scale]) & (1 << y/scale))
    128e:	bc f7       	brge	.-18     	; 0x127e <nokia_lcd_write_char+0xc6>
    1290:	86 2d       	mov	r24, r6
    1292:	65 2d       	mov	r22, r5
    1294:	32 d5       	rcall	.+2660   	; 0x1cfa <__udivmodqi4>
    1296:	e5 01       	movw	r28, r10
    1298:	c8 0f       	add	r28, r24
    129a:	d1 1d       	adc	r29, r1
    129c:	c4 57       	subi	r28, 0x74	; 116
    129e:	df 4f       	sbci	r29, 0xFF	; 255
    12a0:	71 2c       	mov	r7, r1
    12a2:	c9 cf       	rjmp	.-110    	; 0x1236 <nokia_lcd_write_char+0x7e>
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 1);
			else
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 0);

	nokia_lcd.cursor_x += 5*scale + 1;
    12a4:	80 91 c3 09 	lds	r24, 0x09C3	; 0x8009c3 <nokia_lcd+0x1f8>
    12a8:	91 e0       	ldi	r25, 0x01	; 1
    12aa:	98 0f       	add	r25, r24
    12ac:	85 2d       	mov	r24, r5
    12ae:	88 0f       	add	r24, r24
    12b0:	88 0f       	add	r24, r24
    12b2:	85 0d       	add	r24, r5
    12b4:	89 0f       	add	r24, r25
	if (nokia_lcd.cursor_x >= 84) {
    12b6:	84 35       	cpi	r24, 0x54	; 84
    12b8:	18 f4       	brcc	.+6      	; 0x12c0 <nokia_lcd_write_char+0x108>
			if (pgm_read_byte(&CHARSET[code-32][x/scale]) & (1 << y/scale))
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 1);
			else
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 0);

	nokia_lcd.cursor_x += 5*scale + 1;
    12ba:	80 93 c3 09 	sts	0x09C3, r24	; 0x8009c3 <nokia_lcd+0x1f8>
    12be:	0e c0       	rjmp	.+28     	; 0x12dc <nokia_lcd_write_char+0x124>
	if (nokia_lcd.cursor_x >= 84) {
		nokia_lcd.cursor_x = 0;
    12c0:	10 92 c3 09 	sts	0x09C3, r1	; 0x8009c3 <nokia_lcd+0x1f8>
		nokia_lcd.cursor_y += 7*scale + 1;
    12c4:	e4 ec       	ldi	r30, 0xC4	; 196
    12c6:	f9 e0       	ldi	r31, 0x09	; 9
    12c8:	80 81       	ld	r24, Z
    12ca:	91 e0       	ldi	r25, 0x01	; 1
    12cc:	98 0f       	add	r25, r24
    12ce:	85 2d       	mov	r24, r5
    12d0:	88 0f       	add	r24, r24
    12d2:	88 0f       	add	r24, r24
    12d4:	88 0f       	add	r24, r24
    12d6:	85 19       	sub	r24, r5
    12d8:	89 0f       	add	r24, r25
    12da:	80 83       	st	Z, r24
	}
	if (nokia_lcd.cursor_y >= 48) {
    12dc:	80 91 c4 09 	lds	r24, 0x09C4	; 0x8009c4 <nokia_lcd+0x1f9>
    12e0:	80 33       	cpi	r24, 0x30	; 48
    12e2:	20 f0       	brcs	.+8      	; 0x12ec <nokia_lcd_write_char+0x134>
		nokia_lcd.cursor_x = 0;
    12e4:	10 92 c3 09 	sts	0x09C3, r1	; 0x8009c3 <nokia_lcd+0x1f8>
		nokia_lcd.cursor_y = 0;
    12e8:	10 92 c4 09 	sts	0x09C4, r1	; 0x8009c4 <nokia_lcd+0x1f9>
	}
}
    12ec:	df 91       	pop	r29
    12ee:	cf 91       	pop	r28
    12f0:	1f 91       	pop	r17
    12f2:	0f 91       	pop	r16
    12f4:	ff 90       	pop	r15
    12f6:	ef 90       	pop	r14
    12f8:	df 90       	pop	r13
    12fa:	cf 90       	pop	r12
    12fc:	bf 90       	pop	r11
    12fe:	af 90       	pop	r10
    1300:	9f 90       	pop	r9
    1302:	8f 90       	pop	r8
    1304:	7f 90       	pop	r7
    1306:	6f 90       	pop	r6
    1308:	5f 90       	pop	r5
    130a:	08 95       	ret

0000130c <nokia_lcd_write_string>:

void nokia_lcd_write_string(const char *str, uint8_t scale)
{
    130c:	1f 93       	push	r17
    130e:	cf 93       	push	r28
    1310:	df 93       	push	r29
    1312:	ec 01       	movw	r28, r24
	while(*str)
    1314:	88 81       	ld	r24, Y
    1316:	88 23       	and	r24, r24
    1318:	39 f0       	breq	.+14     	; 0x1328 <nokia_lcd_write_string+0x1c>
    131a:	16 2f       	mov	r17, r22
    131c:	21 96       	adiw	r28, 0x01	; 1
		nokia_lcd_write_char(*str++, scale);
    131e:	61 2f       	mov	r22, r17
    1320:	4b df       	rcall	.-362    	; 0x11b8 <nokia_lcd_write_char>
	}
}

void nokia_lcd_write_string(const char *str, uint8_t scale)
{
	while(*str)
    1322:	89 91       	ld	r24, Y+
    1324:	81 11       	cpse	r24, r1
    1326:	fb cf       	rjmp	.-10     	; 0x131e <nokia_lcd_write_string+0x12>
		nokia_lcd_write_char(*str++, scale);
}
    1328:	df 91       	pop	r29
    132a:	cf 91       	pop	r28
    132c:	1f 91       	pop	r17
    132e:	08 95       	ret

00001330 <nokia_lcd_set_cursor>:

void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
	nokia_lcd.cursor_x = x;
    1330:	80 93 c3 09 	sts	0x09C3, r24	; 0x8009c3 <nokia_lcd+0x1f8>
	nokia_lcd.cursor_y = y;
    1334:	60 93 c4 09 	sts	0x09C4, r22	; 0x8009c4 <nokia_lcd+0x1f9>
    1338:	08 95       	ret

0000133a <nokia_lcd_render>:
}

void nokia_lcd_render(void)
{
    133a:	0f 93       	push	r16
    133c:	1f 93       	push	r17
    133e:	cf 93       	push	r28
    1340:	df 93       	push	r29
	register unsigned i;
	/* Set column and row to 0 */
	write_cmd(0x80);
    1342:	80 e8       	ldi	r24, 0x80	; 128
    1344:	c4 de       	rcall	.-632    	; 0x10ce <write_cmd>
	write_cmd(0x40);
    1346:	80 e4       	ldi	r24, 0x40	; 64
    1348:	c2 de       	rcall	.-636    	; 0x10ce <write_cmd>
    134a:	cb ec       	ldi	r28, 0xCB	; 203
    134c:	d7 e0       	ldi	r29, 0x07	; 7
    134e:	03 ec       	ldi	r16, 0xC3	; 195
    1350:	19 e0       	ldi	r17, 0x09	; 9
	write(cmd, 0);
}

static void write_data(uint8_t data)
{
	write(data, 1);
    1352:	61 e0       	ldi	r22, 0x01	; 1
    1354:	89 91       	ld	r24, Y+
    1356:	9d de       	rcall	.-710    	; 0x1092 <write>
	/* Set column and row to 0 */
	write_cmd(0x80);
	write_cmd(0x40);

	/* Write screen to display */
	for (i = 0; i < 504; i++)
    1358:	c0 17       	cp	r28, r16
    135a:	d1 07       	cpc	r29, r17
    135c:	d1 f7       	brne	.-12     	; 0x1352 <nokia_lcd_render+0x18>
		write_data(nokia_lcd.screen[i]);
}
    135e:	df 91       	pop	r29
    1360:	cf 91       	pop	r28
    1362:	1f 91       	pop	r17
    1364:	0f 91       	pop	r16
    1366:	08 95       	ret

00001368 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1368:	31 e1       	ldi	r19, 0x11	; 17
    136a:	fc 01       	movw	r30, r24
    136c:	30 83       	st	Z, r19
    136e:	31 97       	sbiw	r30, 0x01	; 1
    1370:	22 e2       	ldi	r18, 0x22	; 34
    1372:	20 83       	st	Z, r18
    1374:	31 97       	sbiw	r30, 0x01	; 1
    1376:	a3 e3       	ldi	r26, 0x33	; 51
    1378:	a0 83       	st	Z, r26
    137a:	31 97       	sbiw	r30, 0x01	; 1
    137c:	60 83       	st	Z, r22
    137e:	31 97       	sbiw	r30, 0x01	; 1
    1380:	70 83       	st	Z, r23
    1382:	31 97       	sbiw	r30, 0x01	; 1
    1384:	10 82       	st	Z, r1
    1386:	31 97       	sbiw	r30, 0x01	; 1
    1388:	60 e8       	ldi	r22, 0x80	; 128
    138a:	60 83       	st	Z, r22
    138c:	31 97       	sbiw	r30, 0x01	; 1
    138e:	10 82       	st	Z, r1
    1390:	31 97       	sbiw	r30, 0x01	; 1
    1392:	62 e0       	ldi	r22, 0x02	; 2
    1394:	60 83       	st	Z, r22
    1396:	31 97       	sbiw	r30, 0x01	; 1
    1398:	63 e0       	ldi	r22, 0x03	; 3
    139a:	60 83       	st	Z, r22
    139c:	31 97       	sbiw	r30, 0x01	; 1
    139e:	64 e0       	ldi	r22, 0x04	; 4
    13a0:	60 83       	st	Z, r22
    13a2:	31 97       	sbiw	r30, 0x01	; 1
    13a4:	65 e0       	ldi	r22, 0x05	; 5
    13a6:	60 83       	st	Z, r22
    13a8:	31 97       	sbiw	r30, 0x01	; 1
    13aa:	66 e0       	ldi	r22, 0x06	; 6
    13ac:	60 83       	st	Z, r22
    13ae:	31 97       	sbiw	r30, 0x01	; 1
    13b0:	67 e0       	ldi	r22, 0x07	; 7
    13b2:	60 83       	st	Z, r22
    13b4:	31 97       	sbiw	r30, 0x01	; 1
    13b6:	68 e0       	ldi	r22, 0x08	; 8
    13b8:	60 83       	st	Z, r22
    13ba:	31 97       	sbiw	r30, 0x01	; 1
    13bc:	69 e0       	ldi	r22, 0x09	; 9
    13be:	60 83       	st	Z, r22
    13c0:	31 97       	sbiw	r30, 0x01	; 1
    13c2:	60 e1       	ldi	r22, 0x10	; 16
    13c4:	60 83       	st	Z, r22
    13c6:	31 97       	sbiw	r30, 0x01	; 1
    13c8:	30 83       	st	Z, r19
    13ca:	31 97       	sbiw	r30, 0x01	; 1
    13cc:	32 e1       	ldi	r19, 0x12	; 18
    13ce:	30 83       	st	Z, r19
    13d0:	31 97       	sbiw	r30, 0x01	; 1
    13d2:	33 e1       	ldi	r19, 0x13	; 19
    13d4:	30 83       	st	Z, r19
    13d6:	31 97       	sbiw	r30, 0x01	; 1
    13d8:	34 e1       	ldi	r19, 0x14	; 20
    13da:	30 83       	st	Z, r19
    13dc:	31 97       	sbiw	r30, 0x01	; 1
    13de:	35 e1       	ldi	r19, 0x15	; 21
    13e0:	30 83       	st	Z, r19
    13e2:	31 97       	sbiw	r30, 0x01	; 1
    13e4:	36 e1       	ldi	r19, 0x16	; 22
    13e6:	30 83       	st	Z, r19
    13e8:	31 97       	sbiw	r30, 0x01	; 1
    13ea:	37 e1       	ldi	r19, 0x17	; 23
    13ec:	30 83       	st	Z, r19
    13ee:	31 97       	sbiw	r30, 0x01	; 1
    13f0:	38 e1       	ldi	r19, 0x18	; 24
    13f2:	30 83       	st	Z, r19
    13f4:	31 97       	sbiw	r30, 0x01	; 1
    13f6:	39 e1       	ldi	r19, 0x19	; 25
    13f8:	30 83       	st	Z, r19
    13fa:	31 97       	sbiw	r30, 0x01	; 1
    13fc:	30 e2       	ldi	r19, 0x20	; 32
    13fe:	30 83       	st	Z, r19
    1400:	31 97       	sbiw	r30, 0x01	; 1
    1402:	31 e2       	ldi	r19, 0x21	; 33
    1404:	30 83       	st	Z, r19
    1406:	31 97       	sbiw	r30, 0x01	; 1
    1408:	20 83       	st	Z, r18
    140a:	31 97       	sbiw	r30, 0x01	; 1
    140c:	23 e2       	ldi	r18, 0x23	; 35
    140e:	20 83       	st	Z, r18
    1410:	31 97       	sbiw	r30, 0x01	; 1
    1412:	40 83       	st	Z, r20
    1414:	31 97       	sbiw	r30, 0x01	; 1
    1416:	50 83       	st	Z, r21
    1418:	31 97       	sbiw	r30, 0x01	; 1
    141a:	26 e2       	ldi	r18, 0x26	; 38
    141c:	20 83       	st	Z, r18
    141e:	31 97       	sbiw	r30, 0x01	; 1
    1420:	27 e2       	ldi	r18, 0x27	; 39
    1422:	20 83       	st	Z, r18
    1424:	31 97       	sbiw	r30, 0x01	; 1
    1426:	28 e2       	ldi	r18, 0x28	; 40
    1428:	20 83       	st	Z, r18
    142a:	31 97       	sbiw	r30, 0x01	; 1
    142c:	29 e2       	ldi	r18, 0x29	; 41
    142e:	20 83       	st	Z, r18
    1430:	31 97       	sbiw	r30, 0x01	; 1
    1432:	20 e3       	ldi	r18, 0x30	; 48
    1434:	20 83       	st	Z, r18
    1436:	31 97       	sbiw	r30, 0x01	; 1
    1438:	21 e3       	ldi	r18, 0x31	; 49
    143a:	20 83       	st	Z, r18
    143c:	86 97       	sbiw	r24, 0x26	; 38
    143e:	08 95       	ret

00001440 <xPortStartScheduler>:
    1440:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    1444:	8c e7       	ldi	r24, 0x7C	; 124
    1446:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    144a:	8b e0       	ldi	r24, 0x0B	; 11
    144c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
    1450:	ef e6       	ldi	r30, 0x6F	; 111
    1452:	f0 e0       	ldi	r31, 0x00	; 0
    1454:	80 81       	ld	r24, Z
    1456:	82 60       	ori	r24, 0x02	; 2
    1458:	80 83       	st	Z, r24
    145a:	a0 91 1d 0a 	lds	r26, 0x0A1D	; 0x800a1d <pxCurrentTCB>
    145e:	b0 91 1e 0a 	lds	r27, 0x0A1E	; 0x800a1e <pxCurrentTCB+0x1>
    1462:	cd 91       	ld	r28, X+
    1464:	cd bf       	out	0x3d, r28	; 61
    1466:	dd 91       	ld	r29, X+
    1468:	de bf       	out	0x3e, r29	; 62
    146a:	ff 91       	pop	r31
    146c:	ef 91       	pop	r30
    146e:	df 91       	pop	r29
    1470:	cf 91       	pop	r28
    1472:	bf 91       	pop	r27
    1474:	af 91       	pop	r26
    1476:	9f 91       	pop	r25
    1478:	8f 91       	pop	r24
    147a:	7f 91       	pop	r23
    147c:	6f 91       	pop	r22
    147e:	5f 91       	pop	r21
    1480:	4f 91       	pop	r20
    1482:	3f 91       	pop	r19
    1484:	2f 91       	pop	r18
    1486:	1f 91       	pop	r17
    1488:	0f 91       	pop	r16
    148a:	ff 90       	pop	r15
    148c:	ef 90       	pop	r14
    148e:	df 90       	pop	r13
    1490:	cf 90       	pop	r12
    1492:	bf 90       	pop	r11
    1494:	af 90       	pop	r10
    1496:	9f 90       	pop	r9
    1498:	8f 90       	pop	r8
    149a:	7f 90       	pop	r7
    149c:	6f 90       	pop	r6
    149e:	5f 90       	pop	r5
    14a0:	4f 90       	pop	r4
    14a2:	3f 90       	pop	r3
    14a4:	2f 90       	pop	r2
    14a6:	1f 90       	pop	r1
    14a8:	0f 90       	pop	r0
    14aa:	0f be       	out	0x3f, r0	; 63
    14ac:	0f 90       	pop	r0
    14ae:	08 95       	ret
    14b0:	81 e0       	ldi	r24, 0x01	; 1
    14b2:	08 95       	ret

000014b4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    14b4:	0f 92       	push	r0
    14b6:	0f b6       	in	r0, 0x3f	; 63
    14b8:	f8 94       	cli
    14ba:	0f 92       	push	r0
    14bc:	1f 92       	push	r1
    14be:	11 24       	eor	r1, r1
    14c0:	2f 92       	push	r2
    14c2:	3f 92       	push	r3
    14c4:	4f 92       	push	r4
    14c6:	5f 92       	push	r5
    14c8:	6f 92       	push	r6
    14ca:	7f 92       	push	r7
    14cc:	8f 92       	push	r8
    14ce:	9f 92       	push	r9
    14d0:	af 92       	push	r10
    14d2:	bf 92       	push	r11
    14d4:	cf 92       	push	r12
    14d6:	df 92       	push	r13
    14d8:	ef 92       	push	r14
    14da:	ff 92       	push	r15
    14dc:	0f 93       	push	r16
    14de:	1f 93       	push	r17
    14e0:	2f 93       	push	r18
    14e2:	3f 93       	push	r19
    14e4:	4f 93       	push	r20
    14e6:	5f 93       	push	r21
    14e8:	6f 93       	push	r22
    14ea:	7f 93       	push	r23
    14ec:	8f 93       	push	r24
    14ee:	9f 93       	push	r25
    14f0:	af 93       	push	r26
    14f2:	bf 93       	push	r27
    14f4:	cf 93       	push	r28
    14f6:	df 93       	push	r29
    14f8:	ef 93       	push	r30
    14fa:	ff 93       	push	r31
    14fc:	a0 91 1d 0a 	lds	r26, 0x0A1D	; 0x800a1d <pxCurrentTCB>
    1500:	b0 91 1e 0a 	lds	r27, 0x0A1E	; 0x800a1e <pxCurrentTCB+0x1>
    1504:	0d b6       	in	r0, 0x3d	; 61
    1506:	0d 92       	st	X+, r0
    1508:	0e b6       	in	r0, 0x3e	; 62
    150a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    150c:	8a d3       	rcall	.+1812   	; 0x1c22 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    150e:	a0 91 1d 0a 	lds	r26, 0x0A1D	; 0x800a1d <pxCurrentTCB>
    1512:	b0 91 1e 0a 	lds	r27, 0x0A1E	; 0x800a1e <pxCurrentTCB+0x1>
    1516:	cd 91       	ld	r28, X+
    1518:	cd bf       	out	0x3d, r28	; 61
    151a:	dd 91       	ld	r29, X+
    151c:	de bf       	out	0x3e, r29	; 62
    151e:	ff 91       	pop	r31
    1520:	ef 91       	pop	r30
    1522:	df 91       	pop	r29
    1524:	cf 91       	pop	r28
    1526:	bf 91       	pop	r27
    1528:	af 91       	pop	r26
    152a:	9f 91       	pop	r25
    152c:	8f 91       	pop	r24
    152e:	7f 91       	pop	r23
    1530:	6f 91       	pop	r22
    1532:	5f 91       	pop	r21
    1534:	4f 91       	pop	r20
    1536:	3f 91       	pop	r19
    1538:	2f 91       	pop	r18
    153a:	1f 91       	pop	r17
    153c:	0f 91       	pop	r16
    153e:	ff 90       	pop	r15
    1540:	ef 90       	pop	r14
    1542:	df 90       	pop	r13
    1544:	cf 90       	pop	r12
    1546:	bf 90       	pop	r11
    1548:	af 90       	pop	r10
    154a:	9f 90       	pop	r9
    154c:	8f 90       	pop	r8
    154e:	7f 90       	pop	r7
    1550:	6f 90       	pop	r6
    1552:	5f 90       	pop	r5
    1554:	4f 90       	pop	r4
    1556:	3f 90       	pop	r3
    1558:	2f 90       	pop	r2
    155a:	1f 90       	pop	r1
    155c:	0f 90       	pop	r0
    155e:	0f be       	out	0x3f, r0	; 63
    1560:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1562:	08 95       	ret

00001564 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1564:	0f 92       	push	r0
    1566:	0f b6       	in	r0, 0x3f	; 63
    1568:	f8 94       	cli
    156a:	0f 92       	push	r0
    156c:	1f 92       	push	r1
    156e:	11 24       	eor	r1, r1
    1570:	2f 92       	push	r2
    1572:	3f 92       	push	r3
    1574:	4f 92       	push	r4
    1576:	5f 92       	push	r5
    1578:	6f 92       	push	r6
    157a:	7f 92       	push	r7
    157c:	8f 92       	push	r8
    157e:	9f 92       	push	r9
    1580:	af 92       	push	r10
    1582:	bf 92       	push	r11
    1584:	cf 92       	push	r12
    1586:	df 92       	push	r13
    1588:	ef 92       	push	r14
    158a:	ff 92       	push	r15
    158c:	0f 93       	push	r16
    158e:	1f 93       	push	r17
    1590:	2f 93       	push	r18
    1592:	3f 93       	push	r19
    1594:	4f 93       	push	r20
    1596:	5f 93       	push	r21
    1598:	6f 93       	push	r22
    159a:	7f 93       	push	r23
    159c:	8f 93       	push	r24
    159e:	9f 93       	push	r25
    15a0:	af 93       	push	r26
    15a2:	bf 93       	push	r27
    15a4:	cf 93       	push	r28
    15a6:	df 93       	push	r29
    15a8:	ef 93       	push	r30
    15aa:	ff 93       	push	r31
    15ac:	a0 91 1d 0a 	lds	r26, 0x0A1D	; 0x800a1d <pxCurrentTCB>
    15b0:	b0 91 1e 0a 	lds	r27, 0x0A1E	; 0x800a1e <pxCurrentTCB+0x1>
    15b4:	0d b6       	in	r0, 0x3d	; 61
    15b6:	0d 92       	st	X+, r0
    15b8:	0e b6       	in	r0, 0x3e	; 62
    15ba:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    15bc:	95 d1       	rcall	.+810    	; 0x18e8 <vTaskIncrementTick>
	vTaskSwitchContext();
    15be:	31 d3       	rcall	.+1634   	; 0x1c22 <vTaskSwitchContext>
    15c0:	a0 91 1d 0a 	lds	r26, 0x0A1D	; 0x800a1d <pxCurrentTCB>
	portRESTORE_CONTEXT();
    15c4:	b0 91 1e 0a 	lds	r27, 0x0A1E	; 0x800a1e <pxCurrentTCB+0x1>
    15c8:	cd 91       	ld	r28, X+
    15ca:	cd bf       	out	0x3d, r28	; 61
    15cc:	dd 91       	ld	r29, X+
    15ce:	de bf       	out	0x3e, r29	; 62
    15d0:	ff 91       	pop	r31
    15d2:	ef 91       	pop	r30
    15d4:	df 91       	pop	r29
    15d6:	cf 91       	pop	r28
    15d8:	bf 91       	pop	r27
    15da:	af 91       	pop	r26
    15dc:	9f 91       	pop	r25
    15de:	8f 91       	pop	r24
    15e0:	7f 91       	pop	r23
    15e2:	6f 91       	pop	r22
    15e4:	5f 91       	pop	r21
    15e6:	4f 91       	pop	r20
    15e8:	3f 91       	pop	r19
    15ea:	2f 91       	pop	r18
    15ec:	1f 91       	pop	r17
    15ee:	0f 91       	pop	r16
    15f0:	ff 90       	pop	r15
    15f2:	ef 90       	pop	r14
    15f4:	df 90       	pop	r13
    15f6:	cf 90       	pop	r12
    15f8:	bf 90       	pop	r11
    15fa:	af 90       	pop	r10
    15fc:	9f 90       	pop	r9
    15fe:	8f 90       	pop	r8
    1600:	7f 90       	pop	r7
    1602:	6f 90       	pop	r6
    1604:	5f 90       	pop	r5
    1606:	4f 90       	pop	r4
    1608:	3f 90       	pop	r3
    160a:	2f 90       	pop	r2
    160c:	1f 90       	pop	r1
    160e:	0f 90       	pop	r0
    1610:	0f be       	out	0x3f, r0	; 63
    1612:	0f 90       	pop	r0
    1614:	08 95       	ret

00001616 <__vector_13>:

	asm volatile ( "ret" );
    1616:	a6 df       	rcall	.-180    	; 0x1564 <vPortYieldFromTick>
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    1618:	18 95       	reti

0000161a <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    161a:	cf 93       	push	r28
    161c:	df 93       	push	r29
    161e:	ec 01       	movw	r28, r24
    1620:	e0 91 1d 0a 	lds	r30, 0x0A1D	; 0x800a1d <pxCurrentTCB>
    1624:	f0 91 1e 0a 	lds	r31, 0x0A1E	; 0x800a1e <pxCurrentTCB+0x1>
    1628:	93 83       	std	Z+3, r25	; 0x03
    162a:	82 83       	std	Z+2, r24	; 0x02
    162c:	80 91 cd 09 	lds	r24, 0x09CD	; 0x8009cd <xTickCount>
    1630:	90 91 ce 09 	lds	r25, 0x09CE	; 0x8009ce <xTickCount+0x1>
    1634:	c8 17       	cp	r28, r24
    1636:	d9 07       	cpc	r29, r25
    1638:	68 f4       	brcc	.+26     	; 0x1654 <prvAddCurrentTaskToDelayedList+0x3a>
    163a:	60 91 1d 0a 	lds	r22, 0x0A1D	; 0x800a1d <pxCurrentTCB>
    163e:	70 91 1e 0a 	lds	r23, 0x0A1E	; 0x800a1e <pxCurrentTCB+0x1>
    1642:	80 91 e3 09 	lds	r24, 0x09E3	; 0x8009e3 <pxOverflowDelayedTaskList>
    1646:	90 91 e4 09 	lds	r25, 0x09E4	; 0x8009e4 <pxOverflowDelayedTaskList+0x1>
    164a:	6e 5f       	subi	r22, 0xFE	; 254
    164c:	7f 4f       	sbci	r23, 0xFF	; 255
    164e:	0e 94 b5 01 	call	0x36a	; 0x36a <vListInsert>
    1652:	17 c0       	rjmp	.+46     	; 0x1682 <prvAddCurrentTaskToDelayedList+0x68>
    1654:	60 91 1d 0a 	lds	r22, 0x0A1D	; 0x800a1d <pxCurrentTCB>
    1658:	70 91 1e 0a 	lds	r23, 0x0A1E	; 0x800a1e <pxCurrentTCB+0x1>
    165c:	80 91 e5 09 	lds	r24, 0x09E5	; 0x8009e5 <pxDelayedTaskList>
    1660:	90 91 e6 09 	lds	r25, 0x09E6	; 0x8009e6 <pxDelayedTaskList+0x1>
    1664:	6e 5f       	subi	r22, 0xFE	; 254
    1666:	7f 4f       	sbci	r23, 0xFF	; 255
    1668:	0e 94 b5 01 	call	0x36a	; 0x36a <vListInsert>
    166c:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <xNextTaskUnblockTime>
    1670:	90 91 44 01 	lds	r25, 0x0144	; 0x800144 <xNextTaskUnblockTime+0x1>
    1674:	c8 17       	cp	r28, r24
    1676:	d9 07       	cpc	r29, r25
    1678:	20 f4       	brcc	.+8      	; 0x1682 <prvAddCurrentTaskToDelayedList+0x68>
    167a:	d0 93 44 01 	sts	0x0144, r29	; 0x800144 <xNextTaskUnblockTime+0x1>
    167e:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <xNextTaskUnblockTime>
    1682:	df 91       	pop	r29
    1684:	cf 91       	pop	r28
    1686:	08 95       	ret

00001688 <xTaskGenericCreate>:
    1688:	4f 92       	push	r4
    168a:	5f 92       	push	r5
    168c:	6f 92       	push	r6
    168e:	7f 92       	push	r7
    1690:	8f 92       	push	r8
    1692:	9f 92       	push	r9
    1694:	af 92       	push	r10
    1696:	bf 92       	push	r11
    1698:	cf 92       	push	r12
    169a:	df 92       	push	r13
    169c:	ef 92       	push	r14
    169e:	ff 92       	push	r15
    16a0:	0f 93       	push	r16
    16a2:	1f 93       	push	r17
    16a4:	cf 93       	push	r28
    16a6:	df 93       	push	r29
    16a8:	5c 01       	movw	r10, r24
    16aa:	4b 01       	movw	r8, r22
    16ac:	3a 01       	movw	r6, r20
    16ae:	29 01       	movw	r4, r18
    16b0:	81 e2       	ldi	r24, 0x21	; 33
    16b2:	90 e0       	ldi	r25, 0x00	; 0
    16b4:	0e 94 55 01 	call	0x2aa	; 0x2aa <pvPortMalloc>
    16b8:	ec 01       	movw	r28, r24
    16ba:	89 2b       	or	r24, r25
    16bc:	09 f4       	brne	.+2      	; 0x16c0 <xTaskGenericCreate+0x38>
    16be:	d3 c0       	rjmp	.+422    	; 0x1866 <xTaskGenericCreate+0x1de>
    16c0:	c1 14       	cp	r12, r1
    16c2:	d1 04       	cpc	r13, r1
    16c4:	09 f0       	breq	.+2      	; 0x16c8 <xTaskGenericCreate+0x40>
    16c6:	cb c0       	rjmp	.+406    	; 0x185e <xTaskGenericCreate+0x1d6>
    16c8:	c3 01       	movw	r24, r6
    16ca:	0e 94 55 01 	call	0x2aa	; 0x2aa <pvPortMalloc>
    16ce:	98 8f       	std	Y+24, r25	; 0x18
    16d0:	8f 8b       	std	Y+23, r24	; 0x17
    16d2:	00 97       	sbiw	r24, 0x00	; 0
    16d4:	21 f4       	brne	.+8      	; 0x16de <xTaskGenericCreate+0x56>
    16d6:	ce 01       	movw	r24, r28
    16d8:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <vPortFree>
    16dc:	c4 c0       	rjmp	.+392    	; 0x1866 <xTaskGenericCreate+0x1de>
    16de:	a3 01       	movw	r20, r6
    16e0:	65 ea       	ldi	r22, 0xA5	; 165
    16e2:	70 e0       	ldi	r23, 0x00	; 0
    16e4:	16 d3       	rcall	.+1580   	; 0x1d12 <memset>
    16e6:	93 01       	movw	r18, r6
    16e8:	21 50       	subi	r18, 0x01	; 1
    16ea:	31 09       	sbc	r19, r1
    16ec:	8f 89       	ldd	r24, Y+23	; 0x17
    16ee:	98 8d       	ldd	r25, Y+24	; 0x18
    16f0:	3c 01       	movw	r6, r24
    16f2:	62 0e       	add	r6, r18
    16f4:	73 1e       	adc	r7, r19
    16f6:	48 e0       	ldi	r20, 0x08	; 8
    16f8:	50 e0       	ldi	r21, 0x00	; 0
    16fa:	b4 01       	movw	r22, r8
    16fc:	ce 01       	movw	r24, r28
    16fe:	49 96       	adiw	r24, 0x19	; 25
    1700:	0f d3       	rcall	.+1566   	; 0x1d20 <strncpy>
    1702:	18 a2       	std	Y+32, r1	; 0x20
    1704:	10 2f       	mov	r17, r16
    1706:	04 30       	cpi	r16, 0x04	; 4
    1708:	08 f0       	brcs	.+2      	; 0x170c <xTaskGenericCreate+0x84>
    170a:	13 e0       	ldi	r17, 0x03	; 3
    170c:	1e 8b       	std	Y+22, r17	; 0x16
    170e:	6e 01       	movw	r12, r28
    1710:	82 e0       	ldi	r24, 0x02	; 2
    1712:	c8 0e       	add	r12, r24
    1714:	d1 1c       	adc	r13, r1
    1716:	c6 01       	movw	r24, r12
    1718:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialiseItem>
    171c:	ce 01       	movw	r24, r28
    171e:	0c 96       	adiw	r24, 0x0c	; 12
    1720:	0e 94 8a 01 	call	0x314	; 0x314 <vListInitialiseItem>
    1724:	d9 87       	std	Y+9, r29	; 0x09
    1726:	c8 87       	std	Y+8, r28	; 0x08
    1728:	84 e0       	ldi	r24, 0x04	; 4
    172a:	90 e0       	ldi	r25, 0x00	; 0
    172c:	81 1b       	sub	r24, r17
    172e:	91 09       	sbc	r25, r1
    1730:	9d 87       	std	Y+13, r25	; 0x0d
    1732:	8c 87       	std	Y+12, r24	; 0x0c
    1734:	db 8b       	std	Y+19, r29	; 0x13
    1736:	ca 8b       	std	Y+18, r28	; 0x12
    1738:	a2 01       	movw	r20, r4
    173a:	b5 01       	movw	r22, r10
    173c:	c3 01       	movw	r24, r6
    173e:	14 de       	rcall	.-984    	; 0x1368 <pxPortInitialiseStack>
    1740:	99 83       	std	Y+1, r25	; 0x01
    1742:	88 83       	st	Y, r24
    1744:	e1 14       	cp	r14, r1
    1746:	f1 04       	cpc	r15, r1
    1748:	19 f0       	breq	.+6      	; 0x1750 <xTaskGenericCreate+0xc8>
    174a:	f7 01       	movw	r30, r14
    174c:	d1 83       	std	Z+1, r29	; 0x01
    174e:	c0 83       	st	Z, r28
    1750:	0f b6       	in	r0, 0x3f	; 63
    1752:	f8 94       	cli
    1754:	0f 92       	push	r0
    1756:	80 91 cf 09 	lds	r24, 0x09CF	; 0x8009cf <uxCurrentNumberOfTasks>
    175a:	8f 5f       	subi	r24, 0xFF	; 255
    175c:	80 93 cf 09 	sts	0x09CF, r24	; 0x8009cf <uxCurrentNumberOfTasks>
    1760:	80 91 1d 0a 	lds	r24, 0x0A1D	; 0x800a1d <pxCurrentTCB>
    1764:	90 91 1e 0a 	lds	r25, 0x0A1E	; 0x800a1e <pxCurrentTCB+0x1>
    1768:	89 2b       	or	r24, r25
    176a:	a9 f5       	brne	.+106    	; 0x17d6 <xTaskGenericCreate+0x14e>
    176c:	d0 93 1e 0a 	sts	0x0A1E, r29	; 0x800a1e <pxCurrentTCB+0x1>
    1770:	c0 93 1d 0a 	sts	0x0A1D, r28	; 0x800a1d <pxCurrentTCB>
    1774:	80 91 cf 09 	lds	r24, 0x09CF	; 0x8009cf <uxCurrentNumberOfTasks>
    1778:	81 30       	cpi	r24, 0x01	; 1
    177a:	e1 f5       	brne	.+120    	; 0x17f4 <xTaskGenericCreate+0x16c>
    177c:	89 ef       	ldi	r24, 0xF9	; 249
    177e:	99 e0       	ldi	r25, 0x09	; 9
    1780:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <vListInitialise>
    1784:	82 e0       	ldi	r24, 0x02	; 2
    1786:	9a e0       	ldi	r25, 0x0A	; 10
    1788:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <vListInitialise>
    178c:	8b e0       	ldi	r24, 0x0B	; 11
    178e:	9a e0       	ldi	r25, 0x0A	; 10
    1790:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <vListInitialise>
    1794:	84 e1       	ldi	r24, 0x14	; 20
    1796:	9a e0       	ldi	r25, 0x0A	; 10
    1798:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <vListInitialise>
    179c:	80 ef       	ldi	r24, 0xF0	; 240
    179e:	99 e0       	ldi	r25, 0x09	; 9
    17a0:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <vListInitialise>
    17a4:	87 ee       	ldi	r24, 0xE7	; 231
    17a6:	99 e0       	ldi	r25, 0x09	; 9
    17a8:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <vListInitialise>
    17ac:	8a ed       	ldi	r24, 0xDA	; 218
    17ae:	99 e0       	ldi	r25, 0x09	; 9
    17b0:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <vListInitialise>
    17b4:	81 ed       	ldi	r24, 0xD1	; 209
    17b6:	99 e0       	ldi	r25, 0x09	; 9
    17b8:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <vListInitialise>
    17bc:	80 ef       	ldi	r24, 0xF0	; 240
    17be:	99 e0       	ldi	r25, 0x09	; 9
    17c0:	90 93 e6 09 	sts	0x09E6, r25	; 0x8009e6 <pxDelayedTaskList+0x1>
    17c4:	80 93 e5 09 	sts	0x09E5, r24	; 0x8009e5 <pxDelayedTaskList>
    17c8:	87 ee       	ldi	r24, 0xE7	; 231
    17ca:	99 e0       	ldi	r25, 0x09	; 9
    17cc:	90 93 e4 09 	sts	0x09E4, r25	; 0x8009e4 <pxOverflowDelayedTaskList+0x1>
    17d0:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <pxOverflowDelayedTaskList>
    17d4:	0f c0       	rjmp	.+30     	; 0x17f4 <xTaskGenericCreate+0x16c>
    17d6:	80 91 ca 09 	lds	r24, 0x09CA	; 0x8009ca <xSchedulerRunning>
    17da:	81 11       	cpse	r24, r1
    17dc:	0b c0       	rjmp	.+22     	; 0x17f4 <xTaskGenericCreate+0x16c>
    17de:	e0 91 1d 0a 	lds	r30, 0x0A1D	; 0x800a1d <pxCurrentTCB>
    17e2:	f0 91 1e 0a 	lds	r31, 0x0A1E	; 0x800a1e <pxCurrentTCB+0x1>
    17e6:	86 89       	ldd	r24, Z+22	; 0x16
    17e8:	08 17       	cp	r16, r24
    17ea:	20 f0       	brcs	.+8      	; 0x17f4 <xTaskGenericCreate+0x16c>
    17ec:	d0 93 1e 0a 	sts	0x0A1E, r29	; 0x800a1e <pxCurrentTCB+0x1>
    17f0:	c0 93 1d 0a 	sts	0x0A1D, r28	; 0x800a1d <pxCurrentTCB>
    17f4:	8e 89       	ldd	r24, Y+22	; 0x16
    17f6:	90 91 cc 09 	lds	r25, 0x09CC	; 0x8009cc <uxTopUsedPriority>
    17fa:	98 17       	cp	r25, r24
    17fc:	10 f4       	brcc	.+4      	; 0x1802 <xTaskGenericCreate+0x17a>
    17fe:	80 93 cc 09 	sts	0x09CC, r24	; 0x8009cc <uxTopUsedPriority>
    1802:	90 91 c5 09 	lds	r25, 0x09C5	; 0x8009c5 <uxTaskNumber>
    1806:	9f 5f       	subi	r25, 0xFF	; 255
    1808:	90 93 c5 09 	sts	0x09C5, r25	; 0x8009c5 <uxTaskNumber>
    180c:	90 91 cb 09 	lds	r25, 0x09CB	; 0x8009cb <uxTopReadyPriority>
    1810:	98 17       	cp	r25, r24
    1812:	10 f4       	brcc	.+4      	; 0x1818 <xTaskGenericCreate+0x190>
    1814:	80 93 cb 09 	sts	0x09CB, r24	; 0x8009cb <uxTopReadyPriority>
    1818:	90 e0       	ldi	r25, 0x00	; 0
    181a:	9c 01       	movw	r18, r24
    181c:	22 0f       	add	r18, r18
    181e:	33 1f       	adc	r19, r19
    1820:	22 0f       	add	r18, r18
    1822:	33 1f       	adc	r19, r19
    1824:	22 0f       	add	r18, r18
    1826:	33 1f       	adc	r19, r19
    1828:	82 0f       	add	r24, r18
    182a:	93 1f       	adc	r25, r19
    182c:	b6 01       	movw	r22, r12
    182e:	87 50       	subi	r24, 0x07	; 7
    1830:	96 4f       	sbci	r25, 0xF6	; 246
    1832:	0e 94 8e 01 	call	0x31c	; 0x31c <vListInsertEnd>
    1836:	0f 90       	pop	r0
    1838:	0f be       	out	0x3f, r0	; 63
    183a:	80 91 ca 09 	lds	r24, 0x09CA	; 0x8009ca <xSchedulerRunning>
    183e:	88 23       	and	r24, r24
    1840:	51 f0       	breq	.+20     	; 0x1856 <xTaskGenericCreate+0x1ce>
    1842:	e0 91 1d 0a 	lds	r30, 0x0A1D	; 0x800a1d <pxCurrentTCB>
    1846:	f0 91 1e 0a 	lds	r31, 0x0A1E	; 0x800a1e <pxCurrentTCB+0x1>
    184a:	86 89       	ldd	r24, Z+22	; 0x16
    184c:	80 17       	cp	r24, r16
    184e:	28 f4       	brcc	.+10     	; 0x185a <xTaskGenericCreate+0x1d2>
    1850:	31 de       	rcall	.-926    	; 0x14b4 <vPortYield>
    1852:	81 e0       	ldi	r24, 0x01	; 1
    1854:	09 c0       	rjmp	.+18     	; 0x1868 <xTaskGenericCreate+0x1e0>
    1856:	81 e0       	ldi	r24, 0x01	; 1
    1858:	07 c0       	rjmp	.+14     	; 0x1868 <xTaskGenericCreate+0x1e0>
    185a:	81 e0       	ldi	r24, 0x01	; 1
    185c:	05 c0       	rjmp	.+10     	; 0x1868 <xTaskGenericCreate+0x1e0>
    185e:	d8 8e       	std	Y+24, r13	; 0x18
    1860:	cf 8a       	std	Y+23, r12	; 0x17
    1862:	c6 01       	movw	r24, r12
    1864:	3c cf       	rjmp	.-392    	; 0x16de <xTaskGenericCreate+0x56>
    1866:	8f ef       	ldi	r24, 0xFF	; 255
    1868:	df 91       	pop	r29
    186a:	cf 91       	pop	r28
    186c:	1f 91       	pop	r17
    186e:	0f 91       	pop	r16
    1870:	ff 90       	pop	r15
    1872:	ef 90       	pop	r14
    1874:	df 90       	pop	r13
    1876:	cf 90       	pop	r12
    1878:	bf 90       	pop	r11
    187a:	af 90       	pop	r10
    187c:	9f 90       	pop	r9
    187e:	8f 90       	pop	r8
    1880:	7f 90       	pop	r7
    1882:	6f 90       	pop	r6
    1884:	5f 90       	pop	r5
    1886:	4f 90       	pop	r4
    1888:	08 95       	ret

0000188a <vTaskStartScheduler>:
    188a:	af 92       	push	r10
    188c:	bf 92       	push	r11
    188e:	cf 92       	push	r12
    1890:	df 92       	push	r13
    1892:	ef 92       	push	r14
    1894:	ff 92       	push	r15
    1896:	0f 93       	push	r16
    1898:	a1 2c       	mov	r10, r1
    189a:	b1 2c       	mov	r11, r1
    189c:	c1 2c       	mov	r12, r1
    189e:	d1 2c       	mov	r13, r1
    18a0:	e1 2c       	mov	r14, r1
    18a2:	f1 2c       	mov	r15, r1
    18a4:	00 e0       	ldi	r16, 0x00	; 0
    18a6:	20 e0       	ldi	r18, 0x00	; 0
    18a8:	30 e0       	ldi	r19, 0x00	; 0
    18aa:	45 e5       	ldi	r20, 0x55	; 85
    18ac:	50 e0       	ldi	r21, 0x00	; 0
    18ae:	66 ec       	ldi	r22, 0xC6	; 198
    18b0:	71 e0       	ldi	r23, 0x01	; 1
    18b2:	88 ed       	ldi	r24, 0xD8	; 216
    18b4:	9d e0       	ldi	r25, 0x0D	; 13
    18b6:	e8 de       	rcall	.-560    	; 0x1688 <xTaskGenericCreate>
    18b8:	81 30       	cpi	r24, 0x01	; 1
    18ba:	41 f4       	brne	.+16     	; 0x18cc <vTaskStartScheduler+0x42>
    18bc:	f8 94       	cli
    18be:	80 93 ca 09 	sts	0x09CA, r24	; 0x8009ca <xSchedulerRunning>
    18c2:	10 92 ce 09 	sts	0x09CE, r1	; 0x8009ce <xTickCount+0x1>
    18c6:	10 92 cd 09 	sts	0x09CD, r1	; 0x8009cd <xTickCount>
    18ca:	ba dd       	rcall	.-1164   	; 0x1440 <xPortStartScheduler>
    18cc:	0f 91       	pop	r16
    18ce:	ff 90       	pop	r15
    18d0:	ef 90       	pop	r14
    18d2:	df 90       	pop	r13
    18d4:	cf 90       	pop	r12
    18d6:	bf 90       	pop	r11
    18d8:	af 90       	pop	r10
    18da:	08 95       	ret

000018dc <vTaskSuspendAll>:
    18dc:	80 91 c9 09 	lds	r24, 0x09C9	; 0x8009c9 <uxSchedulerSuspended>
    18e0:	8f 5f       	subi	r24, 0xFF	; 255
    18e2:	80 93 c9 09 	sts	0x09C9, r24	; 0x8009c9 <uxSchedulerSuspended>
    18e6:	08 95       	ret

000018e8 <vTaskIncrementTick>:
    18e8:	0f 93       	push	r16
    18ea:	1f 93       	push	r17
    18ec:	cf 93       	push	r28
    18ee:	df 93       	push	r29
    18f0:	80 91 c9 09 	lds	r24, 0x09C9	; 0x8009c9 <uxSchedulerSuspended>
    18f4:	81 11       	cpse	r24, r1
    18f6:	b2 c0       	rjmp	.+356    	; 0x1a5c <vTaskIncrementTick+0x174>
    18f8:	80 91 cd 09 	lds	r24, 0x09CD	; 0x8009cd <xTickCount>
    18fc:	90 91 ce 09 	lds	r25, 0x09CE	; 0x8009ce <xTickCount+0x1>
    1900:	01 96       	adiw	r24, 0x01	; 1
    1902:	90 93 ce 09 	sts	0x09CE, r25	; 0x8009ce <xTickCount+0x1>
    1906:	80 93 cd 09 	sts	0x09CD, r24	; 0x8009cd <xTickCount>
    190a:	80 91 cd 09 	lds	r24, 0x09CD	; 0x8009cd <xTickCount>
    190e:	90 91 ce 09 	lds	r25, 0x09CE	; 0x8009ce <xTickCount+0x1>
    1912:	89 2b       	or	r24, r25
    1914:	99 f5       	brne	.+102    	; 0x197c <vTaskIncrementTick+0x94>
    1916:	80 91 e5 09 	lds	r24, 0x09E5	; 0x8009e5 <pxDelayedTaskList>
    191a:	90 91 e6 09 	lds	r25, 0x09E6	; 0x8009e6 <pxDelayedTaskList+0x1>
    191e:	20 91 e3 09 	lds	r18, 0x09E3	; 0x8009e3 <pxOverflowDelayedTaskList>
    1922:	30 91 e4 09 	lds	r19, 0x09E4	; 0x8009e4 <pxOverflowDelayedTaskList+0x1>
    1926:	30 93 e6 09 	sts	0x09E6, r19	; 0x8009e6 <pxDelayedTaskList+0x1>
    192a:	20 93 e5 09 	sts	0x09E5, r18	; 0x8009e5 <pxDelayedTaskList>
    192e:	90 93 e4 09 	sts	0x09E4, r25	; 0x8009e4 <pxOverflowDelayedTaskList+0x1>
    1932:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <pxOverflowDelayedTaskList>
    1936:	80 91 c6 09 	lds	r24, 0x09C6	; 0x8009c6 <xNumOfOverflows>
    193a:	8f 5f       	subi	r24, 0xFF	; 255
    193c:	80 93 c6 09 	sts	0x09C6, r24	; 0x8009c6 <xNumOfOverflows>
    1940:	e0 91 e5 09 	lds	r30, 0x09E5	; 0x8009e5 <pxDelayedTaskList>
    1944:	f0 91 e6 09 	lds	r31, 0x09E6	; 0x8009e6 <pxDelayedTaskList+0x1>
    1948:	80 81       	ld	r24, Z
    194a:	81 11       	cpse	r24, r1
    194c:	07 c0       	rjmp	.+14     	; 0x195c <vTaskIncrementTick+0x74>
    194e:	8f ef       	ldi	r24, 0xFF	; 255
    1950:	9f ef       	ldi	r25, 0xFF	; 255
    1952:	90 93 44 01 	sts	0x0144, r25	; 0x800144 <xNextTaskUnblockTime+0x1>
    1956:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <xNextTaskUnblockTime>
    195a:	10 c0       	rjmp	.+32     	; 0x197c <vTaskIncrementTick+0x94>
    195c:	e0 91 e5 09 	lds	r30, 0x09E5	; 0x8009e5 <pxDelayedTaskList>
    1960:	f0 91 e6 09 	lds	r31, 0x09E6	; 0x8009e6 <pxDelayedTaskList+0x1>
    1964:	05 80       	ldd	r0, Z+5	; 0x05
    1966:	f6 81       	ldd	r31, Z+6	; 0x06
    1968:	e0 2d       	mov	r30, r0
    196a:	06 80       	ldd	r0, Z+6	; 0x06
    196c:	f7 81       	ldd	r31, Z+7	; 0x07
    196e:	e0 2d       	mov	r30, r0
    1970:	82 81       	ldd	r24, Z+2	; 0x02
    1972:	93 81       	ldd	r25, Z+3	; 0x03
    1974:	90 93 44 01 	sts	0x0144, r25	; 0x800144 <xNextTaskUnblockTime+0x1>
    1978:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <xNextTaskUnblockTime>
    197c:	20 91 cd 09 	lds	r18, 0x09CD	; 0x8009cd <xTickCount>
    1980:	30 91 ce 09 	lds	r19, 0x09CE	; 0x8009ce <xTickCount+0x1>
    1984:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <xNextTaskUnblockTime>
    1988:	90 91 44 01 	lds	r25, 0x0144	; 0x800144 <xNextTaskUnblockTime+0x1>
    198c:	28 17       	cp	r18, r24
    198e:	39 07       	cpc	r19, r25
    1990:	08 f4       	brcc	.+2      	; 0x1994 <vTaskIncrementTick+0xac>
    1992:	69 c0       	rjmp	.+210    	; 0x1a66 <vTaskIncrementTick+0x17e>
    1994:	e0 91 e5 09 	lds	r30, 0x09E5	; 0x8009e5 <pxDelayedTaskList>
    1998:	f0 91 e6 09 	lds	r31, 0x09E6	; 0x8009e6 <pxDelayedTaskList+0x1>
    199c:	80 81       	ld	r24, Z
    199e:	88 23       	and	r24, r24
    19a0:	99 f0       	breq	.+38     	; 0x19c8 <vTaskIncrementTick+0xe0>
    19a2:	e0 91 e5 09 	lds	r30, 0x09E5	; 0x8009e5 <pxDelayedTaskList>
    19a6:	f0 91 e6 09 	lds	r31, 0x09E6	; 0x8009e6 <pxDelayedTaskList+0x1>
    19aa:	05 80       	ldd	r0, Z+5	; 0x05
    19ac:	f6 81       	ldd	r31, Z+6	; 0x06
    19ae:	e0 2d       	mov	r30, r0
    19b0:	c6 81       	ldd	r28, Z+6	; 0x06
    19b2:	d7 81       	ldd	r29, Z+7	; 0x07
    19b4:	8a 81       	ldd	r24, Y+2	; 0x02
    19b6:	9b 81       	ldd	r25, Y+3	; 0x03
    19b8:	20 91 cd 09 	lds	r18, 0x09CD	; 0x8009cd <xTickCount>
    19bc:	30 91 ce 09 	lds	r19, 0x09CE	; 0x8009ce <xTickCount+0x1>
    19c0:	28 17       	cp	r18, r24
    19c2:	39 07       	cpc	r19, r25
    19c4:	f8 f4       	brcc	.+62     	; 0x1a04 <vTaskIncrementTick+0x11c>
    19c6:	19 c0       	rjmp	.+50     	; 0x19fa <vTaskIncrementTick+0x112>
    19c8:	8f ef       	ldi	r24, 0xFF	; 255
    19ca:	9f ef       	ldi	r25, 0xFF	; 255
    19cc:	90 93 44 01 	sts	0x0144, r25	; 0x800144 <xNextTaskUnblockTime+0x1>
    19d0:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <xNextTaskUnblockTime>
    19d4:	48 c0       	rjmp	.+144    	; 0x1a66 <vTaskIncrementTick+0x17e>
    19d6:	e0 91 e5 09 	lds	r30, 0x09E5	; 0x8009e5 <pxDelayedTaskList>
    19da:	f0 91 e6 09 	lds	r31, 0x09E6	; 0x8009e6 <pxDelayedTaskList+0x1>
    19de:	05 80       	ldd	r0, Z+5	; 0x05
    19e0:	f6 81       	ldd	r31, Z+6	; 0x06
    19e2:	e0 2d       	mov	r30, r0
    19e4:	c6 81       	ldd	r28, Z+6	; 0x06
    19e6:	d7 81       	ldd	r29, Z+7	; 0x07
    19e8:	8a 81       	ldd	r24, Y+2	; 0x02
    19ea:	9b 81       	ldd	r25, Y+3	; 0x03
    19ec:	20 91 cd 09 	lds	r18, 0x09CD	; 0x8009cd <xTickCount>
    19f0:	30 91 ce 09 	lds	r19, 0x09CE	; 0x8009ce <xTickCount+0x1>
    19f4:	28 17       	cp	r18, r24
    19f6:	39 07       	cpc	r19, r25
    19f8:	28 f4       	brcc	.+10     	; 0x1a04 <vTaskIncrementTick+0x11c>
    19fa:	90 93 44 01 	sts	0x0144, r25	; 0x800144 <xNextTaskUnblockTime+0x1>
    19fe:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <xNextTaskUnblockTime>
    1a02:	31 c0       	rjmp	.+98     	; 0x1a66 <vTaskIncrementTick+0x17e>
    1a04:	8e 01       	movw	r16, r28
    1a06:	0e 5f       	subi	r16, 0xFE	; 254
    1a08:	1f 4f       	sbci	r17, 0xFF	; 255
    1a0a:	c8 01       	movw	r24, r16
    1a0c:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <vListRemove>
    1a10:	8c 89       	ldd	r24, Y+20	; 0x14
    1a12:	9d 89       	ldd	r25, Y+21	; 0x15
    1a14:	89 2b       	or	r24, r25
    1a16:	21 f0       	breq	.+8      	; 0x1a20 <vTaskIncrementTick+0x138>
    1a18:	ce 01       	movw	r24, r28
    1a1a:	0c 96       	adiw	r24, 0x0c	; 12
    1a1c:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <vListRemove>
    1a20:	8e 89       	ldd	r24, Y+22	; 0x16
    1a22:	90 91 cb 09 	lds	r25, 0x09CB	; 0x8009cb <uxTopReadyPriority>
    1a26:	98 17       	cp	r25, r24
    1a28:	10 f4       	brcc	.+4      	; 0x1a2e <vTaskIncrementTick+0x146>
    1a2a:	80 93 cb 09 	sts	0x09CB, r24	; 0x8009cb <uxTopReadyPriority>
    1a2e:	90 e0       	ldi	r25, 0x00	; 0
    1a30:	9c 01       	movw	r18, r24
    1a32:	22 0f       	add	r18, r18
    1a34:	33 1f       	adc	r19, r19
    1a36:	22 0f       	add	r18, r18
    1a38:	33 1f       	adc	r19, r19
    1a3a:	22 0f       	add	r18, r18
    1a3c:	33 1f       	adc	r19, r19
    1a3e:	82 0f       	add	r24, r18
    1a40:	93 1f       	adc	r25, r19
    1a42:	b8 01       	movw	r22, r16
    1a44:	87 50       	subi	r24, 0x07	; 7
    1a46:	96 4f       	sbci	r25, 0xF6	; 246
    1a48:	0e 94 8e 01 	call	0x31c	; 0x31c <vListInsertEnd>
    1a4c:	e0 91 e5 09 	lds	r30, 0x09E5	; 0x8009e5 <pxDelayedTaskList>
    1a50:	f0 91 e6 09 	lds	r31, 0x09E6	; 0x8009e6 <pxDelayedTaskList+0x1>
    1a54:	80 81       	ld	r24, Z
    1a56:	81 11       	cpse	r24, r1
    1a58:	be cf       	rjmp	.-132    	; 0x19d6 <vTaskIncrementTick+0xee>
    1a5a:	b6 cf       	rjmp	.-148    	; 0x19c8 <vTaskIncrementTick+0xe0>
    1a5c:	80 91 c8 09 	lds	r24, 0x09C8	; 0x8009c8 <uxMissedTicks>
    1a60:	8f 5f       	subi	r24, 0xFF	; 255
    1a62:	80 93 c8 09 	sts	0x09C8, r24	; 0x8009c8 <uxMissedTicks>
    1a66:	df 91       	pop	r29
    1a68:	cf 91       	pop	r28
    1a6a:	1f 91       	pop	r17
    1a6c:	0f 91       	pop	r16
    1a6e:	08 95       	ret

00001a70 <xTaskResumeAll>:
    1a70:	cf 92       	push	r12
    1a72:	df 92       	push	r13
    1a74:	ef 92       	push	r14
    1a76:	ff 92       	push	r15
    1a78:	0f 93       	push	r16
    1a7a:	1f 93       	push	r17
    1a7c:	cf 93       	push	r28
    1a7e:	df 93       	push	r29
    1a80:	0f b6       	in	r0, 0x3f	; 63
    1a82:	f8 94       	cli
    1a84:	0f 92       	push	r0
    1a86:	80 91 c9 09 	lds	r24, 0x09C9	; 0x8009c9 <uxSchedulerSuspended>
    1a8a:	81 50       	subi	r24, 0x01	; 1
    1a8c:	80 93 c9 09 	sts	0x09C9, r24	; 0x8009c9 <uxSchedulerSuspended>
    1a90:	80 91 c9 09 	lds	r24, 0x09C9	; 0x8009c9 <uxSchedulerSuspended>
    1a94:	81 11       	cpse	r24, r1
    1a96:	62 c0       	rjmp	.+196    	; 0x1b5c <xTaskResumeAll+0xec>
    1a98:	80 91 cf 09 	lds	r24, 0x09CF	; 0x8009cf <uxCurrentNumberOfTasks>
    1a9c:	81 11       	cpse	r24, r1
    1a9e:	32 c0       	rjmp	.+100    	; 0x1b04 <xTaskResumeAll+0x94>
    1aa0:	60 c0       	rjmp	.+192    	; 0x1b62 <xTaskResumeAll+0xf2>
    1aa2:	d7 01       	movw	r26, r14
    1aa4:	15 96       	adiw	r26, 0x05	; 5
    1aa6:	ed 91       	ld	r30, X+
    1aa8:	fc 91       	ld	r31, X
    1aaa:	16 97       	sbiw	r26, 0x06	; 6
    1aac:	c6 81       	ldd	r28, Z+6	; 0x06
    1aae:	d7 81       	ldd	r29, Z+7	; 0x07
    1ab0:	ce 01       	movw	r24, r28
    1ab2:	0c 96       	adiw	r24, 0x0c	; 12
    1ab4:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <vListRemove>
    1ab8:	8e 01       	movw	r16, r28
    1aba:	0e 5f       	subi	r16, 0xFE	; 254
    1abc:	1f 4f       	sbci	r17, 0xFF	; 255
    1abe:	c8 01       	movw	r24, r16
    1ac0:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <vListRemove>
    1ac4:	8e 89       	ldd	r24, Y+22	; 0x16
    1ac6:	90 91 cb 09 	lds	r25, 0x09CB	; 0x8009cb <uxTopReadyPriority>
    1aca:	98 17       	cp	r25, r24
    1acc:	10 f4       	brcc	.+4      	; 0x1ad2 <xTaskResumeAll+0x62>
    1ace:	80 93 cb 09 	sts	0x09CB, r24	; 0x8009cb <uxTopReadyPriority>
    1ad2:	90 e0       	ldi	r25, 0x00	; 0
    1ad4:	9c 01       	movw	r18, r24
    1ad6:	22 0f       	add	r18, r18
    1ad8:	33 1f       	adc	r19, r19
    1ada:	22 0f       	add	r18, r18
    1adc:	33 1f       	adc	r19, r19
    1ade:	22 0f       	add	r18, r18
    1ae0:	33 1f       	adc	r19, r19
    1ae2:	82 0f       	add	r24, r18
    1ae4:	93 1f       	adc	r25, r19
    1ae6:	b8 01       	movw	r22, r16
    1ae8:	87 50       	subi	r24, 0x07	; 7
    1aea:	96 4f       	sbci	r25, 0xF6	; 246
    1aec:	0e 94 8e 01 	call	0x31c	; 0x31c <vListInsertEnd>
    1af0:	e0 91 1d 0a 	lds	r30, 0x0A1D	; 0x800a1d <pxCurrentTCB>
    1af4:	f0 91 1e 0a 	lds	r31, 0x0A1E	; 0x800a1e <pxCurrentTCB+0x1>
    1af8:	9e 89       	ldd	r25, Y+22	; 0x16
    1afa:	86 89       	ldd	r24, Z+22	; 0x16
    1afc:	98 17       	cp	r25, r24
    1afe:	58 f0       	brcs	.+22     	; 0x1b16 <xTaskResumeAll+0xa6>
    1b00:	dc 2c       	mov	r13, r12
    1b02:	09 c0       	rjmp	.+18     	; 0x1b16 <xTaskResumeAll+0xa6>
    1b04:	d1 2c       	mov	r13, r1
    1b06:	0f 2e       	mov	r0, r31
    1b08:	fa ed       	ldi	r31, 0xDA	; 218
    1b0a:	ef 2e       	mov	r14, r31
    1b0c:	f9 e0       	ldi	r31, 0x09	; 9
    1b0e:	ff 2e       	mov	r15, r31
    1b10:	f0 2d       	mov	r31, r0
    1b12:	cc 24       	eor	r12, r12
    1b14:	c3 94       	inc	r12
    1b16:	f7 01       	movw	r30, r14
    1b18:	80 81       	ld	r24, Z
    1b1a:	81 11       	cpse	r24, r1
    1b1c:	c2 cf       	rjmp	.-124    	; 0x1aa2 <xTaskResumeAll+0x32>
    1b1e:	80 91 c8 09 	lds	r24, 0x09C8	; 0x8009c8 <uxMissedTicks>
    1b22:	88 23       	and	r24, r24
    1b24:	79 f0       	breq	.+30     	; 0x1b44 <xTaskResumeAll+0xd4>
    1b26:	80 91 c8 09 	lds	r24, 0x09C8	; 0x8009c8 <uxMissedTicks>
    1b2a:	88 23       	and	r24, r24
    1b2c:	91 f0       	breq	.+36     	; 0x1b52 <xTaskResumeAll+0xe2>
    1b2e:	dc de       	rcall	.-584    	; 0x18e8 <vTaskIncrementTick>
    1b30:	80 91 c8 09 	lds	r24, 0x09C8	; 0x8009c8 <uxMissedTicks>
    1b34:	81 50       	subi	r24, 0x01	; 1
    1b36:	80 93 c8 09 	sts	0x09C8, r24	; 0x8009c8 <uxMissedTicks>
    1b3a:	80 91 c8 09 	lds	r24, 0x09C8	; 0x8009c8 <uxMissedTicks>
    1b3e:	81 11       	cpse	r24, r1
    1b40:	f6 cf       	rjmp	.-20     	; 0x1b2e <xTaskResumeAll+0xbe>
    1b42:	07 c0       	rjmp	.+14     	; 0x1b52 <xTaskResumeAll+0xe2>
    1b44:	f1 e0       	ldi	r31, 0x01	; 1
    1b46:	df 16       	cp	r13, r31
    1b48:	21 f0       	breq	.+8      	; 0x1b52 <xTaskResumeAll+0xe2>
    1b4a:	80 91 c7 09 	lds	r24, 0x09C7	; 0x8009c7 <xMissedYield>
    1b4e:	81 30       	cpi	r24, 0x01	; 1
    1b50:	39 f4       	brne	.+14     	; 0x1b60 <xTaskResumeAll+0xf0>
    1b52:	10 92 c7 09 	sts	0x09C7, r1	; 0x8009c7 <xMissedYield>
    1b56:	ae dc       	rcall	.-1700   	; 0x14b4 <vPortYield>
    1b58:	81 e0       	ldi	r24, 0x01	; 1
    1b5a:	03 c0       	rjmp	.+6      	; 0x1b62 <xTaskResumeAll+0xf2>
    1b5c:	80 e0       	ldi	r24, 0x00	; 0
    1b5e:	01 c0       	rjmp	.+2      	; 0x1b62 <xTaskResumeAll+0xf2>
    1b60:	80 e0       	ldi	r24, 0x00	; 0
    1b62:	0f 90       	pop	r0
    1b64:	0f be       	out	0x3f, r0	; 63
    1b66:	df 91       	pop	r29
    1b68:	cf 91       	pop	r28
    1b6a:	1f 91       	pop	r17
    1b6c:	0f 91       	pop	r16
    1b6e:	ff 90       	pop	r15
    1b70:	ef 90       	pop	r14
    1b72:	df 90       	pop	r13
    1b74:	cf 90       	pop	r12
    1b76:	08 95       	ret

00001b78 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1b78:	cf 93       	push	r28
    1b7a:	df 93       	push	r29
    1b7c:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1b7e:	89 2b       	or	r24, r25
    1b80:	99 f0       	breq	.+38     	; 0x1ba8 <vTaskDelay+0x30>
		{
			vTaskSuspendAll();
    1b82:	ac de       	rcall	.-680    	; 0x18dc <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1b84:	80 91 cd 09 	lds	r24, 0x09CD	; 0x8009cd <xTickCount>
    1b88:	90 91 ce 09 	lds	r25, 0x09CE	; 0x8009ce <xTickCount+0x1>
    1b8c:	c8 0f       	add	r28, r24
    1b8e:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1b90:	80 91 1d 0a 	lds	r24, 0x0A1D	; 0x800a1d <pxCurrentTCB>
    1b94:	90 91 1e 0a 	lds	r25, 0x0A1E	; 0x800a1e <pxCurrentTCB+0x1>
    1b98:	02 96       	adiw	r24, 0x02	; 2
    1b9a:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1b9e:	ce 01       	movw	r24, r28
			}
			xAlreadyYielded = xTaskResumeAll();
    1ba0:	3c dd       	rcall	.-1416   	; 0x161a <prvAddCurrentTaskToDelayedList>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1ba2:	66 df       	rcall	.-308    	; 0x1a70 <xTaskResumeAll>
    1ba4:	81 11       	cpse	r24, r1
		{
			portYIELD_WITHIN_API();
    1ba6:	01 c0       	rjmp	.+2      	; 0x1baa <vTaskDelay+0x32>
    1ba8:	85 dc       	rcall	.-1782   	; 0x14b4 <vPortYield>
		}
	}
    1baa:	df 91       	pop	r29
    1bac:	cf 91       	pop	r28
    1bae:	08 95       	ret

00001bb0 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1bb0:	0f 2e       	mov	r0, r31
    1bb2:	f1 ed       	ldi	r31, 0xD1	; 209
    1bb4:	ef 2e       	mov	r14, r31
    1bb6:	f9 e0       	ldi	r31, 0x09	; 9
    1bb8:	ff 2e       	mov	r15, r31
    1bba:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1bbc:	c9 ef       	ldi	r28, 0xF9	; 249
    1bbe:	d9 e0       	ldi	r29, 0x09	; 9
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    1bc0:	80 91 d0 09 	lds	r24, 0x09D0	; 0x8009d0 <uxTasksDeleted>
    1bc4:	88 23       	and	r24, r24
    1bc6:	41 f1       	breq	.+80     	; 0x1c18 <prvIdleTask+0x68>
		{
			vTaskSuspendAll();
    1bc8:	89 de       	rcall	.-750    	; 0x18dc <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1bca:	d7 01       	movw	r26, r14
			xTaskResumeAll();
    1bcc:	1c 91       	ld	r17, X
    1bce:	50 df       	rcall	.-352    	; 0x1a70 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1bd0:	11 23       	and	r17, r17
    1bd2:	11 f1       	breq	.+68     	; 0x1c18 <prvIdleTask+0x68>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    1bd4:	0f b6       	in	r0, 0x3f	; 63
    1bd6:	f8 94       	cli
    1bd8:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    1bda:	d7 01       	movw	r26, r14
    1bdc:	15 96       	adiw	r26, 0x05	; 5
    1bde:	ed 91       	ld	r30, X+
    1be0:	fc 91       	ld	r31, X
    1be2:	16 97       	sbiw	r26, 0x06	; 6
    1be4:	06 81       	ldd	r16, Z+6	; 0x06
    1be6:	17 81       	ldd	r17, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    1be8:	c8 01       	movw	r24, r16
    1bea:	02 96       	adiw	r24, 0x02	; 2
    1bec:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <vListRemove>
					--uxCurrentNumberOfTasks;
    1bf0:	80 91 cf 09 	lds	r24, 0x09CF	; 0x8009cf <uxCurrentNumberOfTasks>
    1bf4:	81 50       	subi	r24, 0x01	; 1
    1bf6:	80 93 cf 09 	sts	0x09CF, r24	; 0x8009cf <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    1bfa:	80 91 d0 09 	lds	r24, 0x09D0	; 0x8009d0 <uxTasksDeleted>
    1bfe:	81 50       	subi	r24, 0x01	; 1
    1c00:	80 93 d0 09 	sts	0x09D0, r24	; 0x8009d0 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    1c04:	0f 90       	pop	r0
    1c06:	0f be       	out	0x3f, r0	; 63
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    1c08:	f8 01       	movw	r30, r16
    1c0a:	87 89       	ldd	r24, Z+23	; 0x17
    1c0c:	90 8d       	ldd	r25, Z+24	; 0x18
    1c0e:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <vPortFree>
		vPortFree( pxTCB );
    1c12:	c8 01       	movw	r24, r16
    1c14:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1c18:	88 81       	ld	r24, Y
    1c1a:	82 30       	cpi	r24, 0x02	; 2
			{
				taskYIELD();
    1c1c:	88 f2       	brcs	.-94     	; 0x1bc0 <prvIdleTask+0x10>
    1c1e:	4a dc       	rcall	.-1900   	; 0x14b4 <vPortYield>
    1c20:	cf cf       	rjmp	.-98     	; 0x1bc0 <prvIdleTask+0x10>

00001c22 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1c22:	80 91 c9 09 	lds	r24, 0x09C9	; 0x8009c9 <uxSchedulerSuspended>
    1c26:	81 11       	cpse	r24, r1
    1c28:	13 c0       	rjmp	.+38     	; 0x1c50 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1c2a:	80 91 cb 09 	lds	r24, 0x09CB	; 0x8009cb <uxTopReadyPriority>
    1c2e:	90 e0       	ldi	r25, 0x00	; 0
    1c30:	fc 01       	movw	r30, r24
    1c32:	ee 0f       	add	r30, r30
    1c34:	ff 1f       	adc	r31, r31
    1c36:	ee 0f       	add	r30, r30
    1c38:	ff 1f       	adc	r31, r31
    1c3a:	ee 0f       	add	r30, r30
    1c3c:	ff 1f       	adc	r31, r31
    1c3e:	8e 0f       	add	r24, r30
    1c40:	9f 1f       	adc	r25, r31
    1c42:	fc 01       	movw	r30, r24
    1c44:	e7 50       	subi	r30, 0x07	; 7
    1c46:	f6 4f       	sbci	r31, 0xF6	; 246
    1c48:	80 81       	ld	r24, Z
    1c4a:	88 23       	and	r24, r24
    1c4c:	29 f0       	breq	.+10     	; 0x1c58 <vTaskSwitchContext+0x36>
    1c4e:	1b c0       	rjmp	.+54     	; 0x1c86 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1c50:	81 e0       	ldi	r24, 0x01	; 1
    1c52:	80 93 c7 09 	sts	0x09C7, r24	; 0x8009c7 <xMissedYield>
    1c56:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1c58:	80 91 cb 09 	lds	r24, 0x09CB	; 0x8009cb <uxTopReadyPriority>
    1c5c:	81 50       	subi	r24, 0x01	; 1
    1c5e:	80 93 cb 09 	sts	0x09CB, r24	; 0x8009cb <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1c62:	80 91 cb 09 	lds	r24, 0x09CB	; 0x8009cb <uxTopReadyPriority>
    1c66:	90 e0       	ldi	r25, 0x00	; 0
    1c68:	fc 01       	movw	r30, r24
    1c6a:	ee 0f       	add	r30, r30
    1c6c:	ff 1f       	adc	r31, r31
    1c6e:	ee 0f       	add	r30, r30
    1c70:	ff 1f       	adc	r31, r31
    1c72:	ee 0f       	add	r30, r30
    1c74:	ff 1f       	adc	r31, r31
    1c76:	8e 0f       	add	r24, r30
    1c78:	9f 1f       	adc	r25, r31
    1c7a:	fc 01       	movw	r30, r24
    1c7c:	e7 50       	subi	r30, 0x07	; 7
    1c7e:	f6 4f       	sbci	r31, 0xF6	; 246
    1c80:	80 81       	ld	r24, Z
    1c82:	88 23       	and	r24, r24
    1c84:	49 f3       	breq	.-46     	; 0x1c58 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1c86:	80 91 cb 09 	lds	r24, 0x09CB	; 0x8009cb <uxTopReadyPriority>
    1c8a:	90 e0       	ldi	r25, 0x00	; 0
    1c8c:	9c 01       	movw	r18, r24
    1c8e:	22 0f       	add	r18, r18
    1c90:	33 1f       	adc	r19, r19
    1c92:	22 0f       	add	r18, r18
    1c94:	33 1f       	adc	r19, r19
    1c96:	22 0f       	add	r18, r18
    1c98:	33 1f       	adc	r19, r19
    1c9a:	28 0f       	add	r18, r24
    1c9c:	39 1f       	adc	r19, r25
    1c9e:	d9 01       	movw	r26, r18
    1ca0:	a7 50       	subi	r26, 0x07	; 7
    1ca2:	b6 4f       	sbci	r27, 0xF6	; 246
    1ca4:	11 96       	adiw	r26, 0x01	; 1
    1ca6:	ed 91       	ld	r30, X+
    1ca8:	fc 91       	ld	r31, X
    1caa:	12 97       	sbiw	r26, 0x02	; 2
    1cac:	02 80       	ldd	r0, Z+2	; 0x02
    1cae:	f3 81       	ldd	r31, Z+3	; 0x03
    1cb0:	e0 2d       	mov	r30, r0
    1cb2:	12 96       	adiw	r26, 0x02	; 2
    1cb4:	fc 93       	st	X, r31
    1cb6:	ee 93       	st	-X, r30
    1cb8:	11 97       	sbiw	r26, 0x01	; 1
    1cba:	24 50       	subi	r18, 0x04	; 4
    1cbc:	36 4f       	sbci	r19, 0xF6	; 246
    1cbe:	e2 17       	cp	r30, r18
    1cc0:	f3 07       	cpc	r31, r19
    1cc2:	29 f4       	brne	.+10     	; 0x1cce <vTaskSwitchContext+0xac>
    1cc4:	22 81       	ldd	r18, Z+2	; 0x02
    1cc6:	33 81       	ldd	r19, Z+3	; 0x03
    1cc8:	fd 01       	movw	r30, r26
    1cca:	32 83       	std	Z+2, r19	; 0x02
    1ccc:	21 83       	std	Z+1, r18	; 0x01
    1cce:	fc 01       	movw	r30, r24
    1cd0:	ee 0f       	add	r30, r30
    1cd2:	ff 1f       	adc	r31, r31
    1cd4:	ee 0f       	add	r30, r30
    1cd6:	ff 1f       	adc	r31, r31
    1cd8:	ee 0f       	add	r30, r30
    1cda:	ff 1f       	adc	r31, r31
    1cdc:	8e 0f       	add	r24, r30
    1cde:	9f 1f       	adc	r25, r31
    1ce0:	fc 01       	movw	r30, r24
    1ce2:	e7 50       	subi	r30, 0x07	; 7
    1ce4:	f6 4f       	sbci	r31, 0xF6	; 246
    1ce6:	01 80       	ldd	r0, Z+1	; 0x01
    1ce8:	f2 81       	ldd	r31, Z+2	; 0x02
    1cea:	e0 2d       	mov	r30, r0
    1cec:	86 81       	ldd	r24, Z+6	; 0x06
    1cee:	97 81       	ldd	r25, Z+7	; 0x07
    1cf0:	90 93 1e 0a 	sts	0x0A1E, r25	; 0x800a1e <pxCurrentTCB+0x1>
    1cf4:	80 93 1d 0a 	sts	0x0A1D, r24	; 0x800a1d <pxCurrentTCB>
    1cf8:	08 95       	ret

00001cfa <__udivmodqi4>:
    1cfa:	99 1b       	sub	r25, r25
    1cfc:	79 e0       	ldi	r23, 0x09	; 9
    1cfe:	04 c0       	rjmp	.+8      	; 0x1d08 <__udivmodqi4_ep>

00001d00 <__udivmodqi4_loop>:
    1d00:	99 1f       	adc	r25, r25
    1d02:	96 17       	cp	r25, r22
    1d04:	08 f0       	brcs	.+2      	; 0x1d08 <__udivmodqi4_ep>
    1d06:	96 1b       	sub	r25, r22

00001d08 <__udivmodqi4_ep>:
    1d08:	88 1f       	adc	r24, r24
    1d0a:	7a 95       	dec	r23
    1d0c:	c9 f7       	brne	.-14     	; 0x1d00 <__udivmodqi4_loop>
    1d0e:	80 95       	com	r24
    1d10:	08 95       	ret

00001d12 <memset>:
    1d12:	dc 01       	movw	r26, r24
    1d14:	01 c0       	rjmp	.+2      	; 0x1d18 <memset+0x6>
    1d16:	6d 93       	st	X+, r22
    1d18:	41 50       	subi	r20, 0x01	; 1
    1d1a:	50 40       	sbci	r21, 0x00	; 0
    1d1c:	e0 f7       	brcc	.-8      	; 0x1d16 <memset+0x4>
    1d1e:	08 95       	ret

00001d20 <strncpy>:
    1d20:	fb 01       	movw	r30, r22
    1d22:	dc 01       	movw	r26, r24
    1d24:	41 50       	subi	r20, 0x01	; 1
    1d26:	50 40       	sbci	r21, 0x00	; 0
    1d28:	48 f0       	brcs	.+18     	; 0x1d3c <strncpy+0x1c>
    1d2a:	01 90       	ld	r0, Z+
    1d2c:	0d 92       	st	X+, r0
    1d2e:	00 20       	and	r0, r0
    1d30:	c9 f7       	brne	.-14     	; 0x1d24 <strncpy+0x4>
    1d32:	01 c0       	rjmp	.+2      	; 0x1d36 <strncpy+0x16>
    1d34:	1d 92       	st	X+, r1
    1d36:	41 50       	subi	r20, 0x01	; 1
    1d38:	50 40       	sbci	r21, 0x00	; 0
    1d3a:	e0 f7       	brcc	.-8      	; 0x1d34 <strncpy+0x14>
    1d3c:	08 95       	ret

00001d3e <_exit>:
    1d3e:	f8 94       	cli

00001d40 <__stop_program>:
    1d40:	ff cf       	rjmp	.-2      	; 0x1d40 <__stop_program>
