
UserVerification.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000106  00800100  000016fc  00001790  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000016fc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000841  00800206  00800206  00001896  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001896  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000018c8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000248  00000000  00000000  00001908  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000034d9  00000000  00000000  00001b50  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000122e  00000000  00000000  00005029  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001d7f  00000000  00000000  00006257  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000005e4  00000000  00000000  00007fd8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000f50  00000000  00000000  000085bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001aea  00000000  00000000  0000950c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000268  00000000  00000000  0000aff6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	35 c1       	rjmp	.+618    	; 0x26c <__ctors_end>
       2:	00 00       	nop
       4:	51 c1       	rjmp	.+674    	; 0x2a8 <__bad_interrupt>
       6:	00 00       	nop
       8:	4f c1       	rjmp	.+670    	; 0x2a8 <__bad_interrupt>
       a:	00 00       	nop
       c:	4d c1       	rjmp	.+666    	; 0x2a8 <__bad_interrupt>
       e:	00 00       	nop
      10:	4b c1       	rjmp	.+662    	; 0x2a8 <__bad_interrupt>
      12:	00 00       	nop
      14:	49 c1       	rjmp	.+658    	; 0x2a8 <__bad_interrupt>
      16:	00 00       	nop
      18:	47 c1       	rjmp	.+654    	; 0x2a8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	45 c1       	rjmp	.+650    	; 0x2a8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	43 c1       	rjmp	.+646    	; 0x2a8 <__bad_interrupt>
      22:	00 00       	nop
      24:	41 c1       	rjmp	.+642    	; 0x2a8 <__bad_interrupt>
      26:	00 00       	nop
      28:	3f c1       	rjmp	.+638    	; 0x2a8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	3d c1       	rjmp	.+634    	; 0x2a8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	3b c1       	rjmp	.+630    	; 0x2a8 <__bad_interrupt>
      32:	00 00       	nop
      34:	df c7       	rjmp	.+4030   	; 0xff4 <__vector_13>
      36:	00 00       	nop
      38:	37 c1       	rjmp	.+622    	; 0x2a8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	35 c1       	rjmp	.+618    	; 0x2a8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	33 c1       	rjmp	.+614    	; 0x2a8 <__bad_interrupt>
      42:	00 00       	nop
      44:	31 c1       	rjmp	.+610    	; 0x2a8 <__bad_interrupt>
      46:	00 00       	nop
      48:	2f c1       	rjmp	.+606    	; 0x2a8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	2d c1       	rjmp	.+602    	; 0x2a8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	2b c1       	rjmp	.+598    	; 0x2a8 <__bad_interrupt>
      52:	00 00       	nop
      54:	29 c1       	rjmp	.+594    	; 0x2a8 <__bad_interrupt>
      56:	00 00       	nop
      58:	27 c1       	rjmp	.+590    	; 0x2a8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	25 c1       	rjmp	.+586    	; 0x2a8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	23 c1       	rjmp	.+582    	; 0x2a8 <__bad_interrupt>
      62:	00 00       	nop
      64:	21 c1       	rjmp	.+578    	; 0x2a8 <__bad_interrupt>
      66:	00 00       	nop
      68:	1f c1       	rjmp	.+574    	; 0x2a8 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	1d c1       	rjmp	.+570    	; 0x2a8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	1b c1       	rjmp	.+566    	; 0x2a8 <__bad_interrupt>
      72:	00 00       	nop
      74:	19 c1       	rjmp	.+562    	; 0x2a8 <__bad_interrupt>
      76:	00 00       	nop
      78:	17 c1       	rjmp	.+558    	; 0x2a8 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	15 c1       	rjmp	.+554    	; 0x2a8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	13 c1       	rjmp	.+550    	; 0x2a8 <__bad_interrupt>
      82:	00 00       	nop
      84:	11 c1       	rjmp	.+546    	; 0x2a8 <__bad_interrupt>
      86:	00 00       	nop
      88:	0f c1       	rjmp	.+542    	; 0x2a8 <__bad_interrupt>
	...

0000008c <CHARSET>:
      8c:	00 00 00 00 00 00 00 5f 00 00 00 07 00 07 00 14     ......._........
      9c:	7f 14 7f 14 24 2a 7f 2a 12 23 13 08 64 62 36 49     ....$*.*.#..db6I
      ac:	55 22 50 00 05 03 00 00 00 1c 22 41 00 00 41 22     U"P......."A..A"
      bc:	1c 00 14 08 3e 08 14 08 08 3e 08 08 00 50 30 00     ....>....>...P0.
      cc:	00 08 08 08 08 08 00 60 60 00 00 20 10 08 04 02     .......``.. ....
      dc:	3e 51 49 45 3e 00 42 7f 40 00 42 61 51 49 46 21     >QIE>.B.@.BaQIF!
      ec:	41 45 4b 31 18 14 12 7f 10 27 45 45 45 39 3c 4a     AEK1.....'EEE9<J
      fc:	49 49 30 01 71 09 05 03 36 49 49 49 36 06 49 49     II0.q...6III6.II
     10c:	29 1e 00 36 36 00 00 00 56 36 00 00 08 14 22 41     )..66...V6...."A
     11c:	00 14 14 14 14 14 00 41 22 14 08 02 01 51 09 06     .......A"....Q..
     12c:	32 49 79 41 3e 7e 11 11 11 7e 7f 49 49 49 36 3e     2IyA>~...~.III6>
     13c:	41 41 41 22 7f 41 41 22 1c 7f 49 49 49 41 7f 09     AAA".AA"..IIIA..
     14c:	09 09 01 3e 41 49 49 7a 7f 08 08 08 7f 00 41 7f     ...>AIIz......A.
     15c:	41 00 20 40 41 3f 01 7f 08 14 22 41 7f 40 40 40     A. @A?...."A.@@@
     16c:	40 7f 02 0c 02 7f 7f 04 08 10 7f 3e 41 41 41 3e     @..........>AAA>
     17c:	7f 09 09 09 06 3e 41 51 21 5e 7f 09 19 29 46 46     .....>AQ!^...)FF
     18c:	49 49 49 31 01 01 7f 01 01 3f 40 40 40 3f 1f 20     III1.....?@@@?. 
     19c:	40 20 1f 3f 40 38 40 3f 63 14 08 14 63 07 08 70     @ .?@8@?c...c..p
     1ac:	08 07 61 51 49 45 43 00 7f 41 41 00 02 04 08 10     ..aQIEC..AA.....
     1bc:	20 00 41 41 7f 00 04 02 01 02 04 40 40 40 40 40      .AA.......@@@@@
     1cc:	00 01 02 04 00 20 54 54 54 78 7f 48 44 44 38 38     ..... TTTx.HDD88
     1dc:	44 44 44 20 38 44 44 48 7f 38 54 54 54 18 08 7e     DDD 8DDH.8TTT..~
     1ec:	09 01 02 0c 52 52 52 3e 7f 08 04 04 78 00 44 7d     ....RRR>....x.D}
     1fc:	40 00 20 40 44 3d 00 7f 10 28 44 00 00 41 7f 40     @. @D=...(D..A.@
     20c:	00 7c 04 18 04 78 7c 08 04 04 78 38 44 44 44 38     .|...x|...x8DDD8
     21c:	7c 14 14 14 08 08 14 14 18 7c 7c 08 04 04 08 48     |........||....H
     22c:	54 54 54 20 04 3f 44 40 20 3c 40 40 20 7c 1c 20     TTT .?D@ <@@ |. 
     23c:	40 20 1c 3c 40 30 40 3c 44 28 10 28 44 0c 50 50     @ .<@0@<D(.(D.PP
     24c:	50 3c 44 64 54 4c 44 00 08 36 41 00 00 00 7f 00     P<DdTLD..6A.....
     25c:	00 00 41 36 08 00 10 08 08 10 08 00 00 00 00 00     ..A6............

0000026c <__ctors_end>:
     26c:	11 24       	eor	r1, r1
     26e:	1f be       	out	0x3f, r1	; 63
     270:	cf ef       	ldi	r28, 0xFF	; 255
     272:	d0 e4       	ldi	r29, 0x40	; 64
     274:	de bf       	out	0x3e, r29	; 62
     276:	cd bf       	out	0x3d, r28	; 61

00000278 <__do_copy_data>:
     278:	12 e0       	ldi	r17, 0x02	; 2
     27a:	a0 e0       	ldi	r26, 0x00	; 0
     27c:	b1 e0       	ldi	r27, 0x01	; 1
     27e:	ec ef       	ldi	r30, 0xFC	; 252
     280:	f6 e1       	ldi	r31, 0x16	; 22
     282:	00 e0       	ldi	r16, 0x00	; 0
     284:	0b bf       	out	0x3b, r16	; 59
     286:	02 c0       	rjmp	.+4      	; 0x28c <__do_copy_data+0x14>
     288:	07 90       	elpm	r0, Z+
     28a:	0d 92       	st	X+, r0
     28c:	a6 30       	cpi	r26, 0x06	; 6
     28e:	b1 07       	cpc	r27, r17
     290:	d9 f7       	brne	.-10     	; 0x288 <__do_copy_data+0x10>

00000292 <__do_clear_bss>:
     292:	2a e0       	ldi	r18, 0x0A	; 10
     294:	a6 e0       	ldi	r26, 0x06	; 6
     296:	b2 e0       	ldi	r27, 0x02	; 2
     298:	01 c0       	rjmp	.+2      	; 0x29c <.do_clear_bss_start>

0000029a <.do_clear_bss_loop>:
     29a:	1d 92       	st	X+, r1

0000029c <.do_clear_bss_start>:
     29c:	a7 34       	cpi	r26, 0x47	; 71
     29e:	b2 07       	cpc	r27, r18
     2a0:	e1 f7       	brne	.-8      	; 0x29a <.do_clear_bss_loop>
     2a2:	d6 d3       	rcall	.+1964   	; 0xa50 <main>
     2a4:	0c 94 7c 0b 	jmp	0x16f8	; 0x16f8 <_exit>

000002a8 <__bad_interrupt>:
     2a8:	ab ce       	rjmp	.-682    	; 0x0 <__vectors>

000002aa <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     2aa:	cf 93       	push	r28
     2ac:	df 93       	push	r29
     2ae:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     2b0:	f4 d7       	rcall	.+4072   	; 0x129a <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     2b2:	20 91 06 02 	lds	r18, 0x0206	; 0x800206 <__data_end>
     2b6:	30 91 07 02 	lds	r19, 0x0207	; 0x800207 <__data_end+0x1>
     2ba:	c9 01       	movw	r24, r18
     2bc:	8c 0f       	add	r24, r28
     2be:	9d 1f       	adc	r25, r29
     2c0:	8c 3d       	cpi	r24, 0xDC	; 220
     2c2:	45 e0       	ldi	r20, 0x05	; 5
     2c4:	94 07       	cpc	r25, r20
     2c6:	58 f4       	brcc	.+22     	; 0x2de <pvPortMalloc+0x34>
     2c8:	28 17       	cp	r18, r24
     2ca:	39 07       	cpc	r19, r25
     2cc:	58 f4       	brcc	.+22     	; 0x2e4 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     2ce:	e9 01       	movw	r28, r18
     2d0:	c8 5f       	subi	r28, 0xF8	; 248
     2d2:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
     2d4:	90 93 07 02 	sts	0x0207, r25	; 0x800207 <__data_end+0x1>
     2d8:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <__data_end>
     2dc:	05 c0       	rjmp	.+10     	; 0x2e8 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     2de:	c0 e0       	ldi	r28, 0x00	; 0
     2e0:	d0 e0       	ldi	r29, 0x00	; 0
     2e2:	02 c0       	rjmp	.+4      	; 0x2e8 <pvPortMalloc+0x3e>
     2e4:	c0 e0       	ldi	r28, 0x00	; 0
     2e6:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     2e8:	0e 94 15 0a 	call	0x142a	; 0x142a <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     2ec:	ce 01       	movw	r24, r28
     2ee:	df 91       	pop	r29
     2f0:	cf 91       	pop	r28
     2f2:	08 95       	ret

000002f4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     2f4:	08 95       	ret

000002f6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     2f6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     2f8:	03 96       	adiw	r24, 0x03	; 3
     2fa:	92 83       	std	Z+2, r25	; 0x02
     2fc:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     2fe:	2f ef       	ldi	r18, 0xFF	; 255
     300:	3f ef       	ldi	r19, 0xFF	; 255
     302:	34 83       	std	Z+4, r19	; 0x04
     304:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     306:	96 83       	std	Z+6, r25	; 0x06
     308:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     30a:	90 87       	std	Z+8, r25	; 0x08
     30c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     30e:	10 82       	st	Z, r1
     310:	08 95       	ret

00000312 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     312:	fc 01       	movw	r30, r24
     314:	11 86       	std	Z+9, r1	; 0x09
     316:	10 86       	std	Z+8, r1	; 0x08
     318:	08 95       	ret

0000031a <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     31a:	cf 93       	push	r28
     31c:	df 93       	push	r29
     31e:	fc 01       	movw	r30, r24
     320:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     322:	21 81       	ldd	r18, Z+1	; 0x01
     324:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     326:	e9 01       	movw	r28, r18
     328:	8a 81       	ldd	r24, Y+2	; 0x02
     32a:	9b 81       	ldd	r25, Y+3	; 0x03
     32c:	13 96       	adiw	r26, 0x03	; 3
     32e:	9c 93       	st	X, r25
     330:	8e 93       	st	-X, r24
     332:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     334:	81 81       	ldd	r24, Z+1	; 0x01
     336:	92 81       	ldd	r25, Z+2	; 0x02
     338:	15 96       	adiw	r26, 0x05	; 5
     33a:	9c 93       	st	X, r25
     33c:	8e 93       	st	-X, r24
     33e:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     340:	8a 81       	ldd	r24, Y+2	; 0x02
     342:	9b 81       	ldd	r25, Y+3	; 0x03
     344:	ec 01       	movw	r28, r24
     346:	7d 83       	std	Y+5, r23	; 0x05
     348:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     34a:	e9 01       	movw	r28, r18
     34c:	7b 83       	std	Y+3, r23	; 0x03
     34e:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     350:	72 83       	std	Z+2, r23	; 0x02
     352:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     354:	19 96       	adiw	r26, 0x09	; 9
     356:	fc 93       	st	X, r31
     358:	ee 93       	st	-X, r30
     35a:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     35c:	80 81       	ld	r24, Z
     35e:	8f 5f       	subi	r24, 0xFF	; 255
     360:	80 83       	st	Z, r24
}
     362:	df 91       	pop	r29
     364:	cf 91       	pop	r28
     366:	08 95       	ret

00000368 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     368:	cf 93       	push	r28
     36a:	df 93       	push	r29
     36c:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     36e:	48 81       	ld	r20, Y
     370:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     372:	4f 3f       	cpi	r20, 0xFF	; 255
     374:	2f ef       	ldi	r18, 0xFF	; 255
     376:	52 07       	cpc	r21, r18
     378:	31 f4       	brne	.+12     	; 0x386 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     37a:	dc 01       	movw	r26, r24
     37c:	17 96       	adiw	r26, 0x07	; 7
     37e:	ed 91       	ld	r30, X+
     380:	fc 91       	ld	r31, X
     382:	18 97       	sbiw	r26, 0x08	; 8
     384:	17 c0       	rjmp	.+46     	; 0x3b4 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     386:	fc 01       	movw	r30, r24
     388:	33 96       	adiw	r30, 0x03	; 3
     38a:	dc 01       	movw	r26, r24
     38c:	15 96       	adiw	r26, 0x05	; 5
     38e:	2d 91       	ld	r18, X+
     390:	3c 91       	ld	r19, X
     392:	16 97       	sbiw	r26, 0x06	; 6
     394:	d9 01       	movw	r26, r18
     396:	2d 91       	ld	r18, X+
     398:	3c 91       	ld	r19, X
     39a:	42 17       	cp	r20, r18
     39c:	53 07       	cpc	r21, r19
     39e:	50 f0       	brcs	.+20     	; 0x3b4 <vListInsert+0x4c>
     3a0:	02 80       	ldd	r0, Z+2	; 0x02
     3a2:	f3 81       	ldd	r31, Z+3	; 0x03
     3a4:	e0 2d       	mov	r30, r0
     3a6:	a2 81       	ldd	r26, Z+2	; 0x02
     3a8:	b3 81       	ldd	r27, Z+3	; 0x03
     3aa:	2d 91       	ld	r18, X+
     3ac:	3c 91       	ld	r19, X
     3ae:	42 17       	cp	r20, r18
     3b0:	53 07       	cpc	r21, r19
     3b2:	b0 f7       	brcc	.-20     	; 0x3a0 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     3b4:	a2 81       	ldd	r26, Z+2	; 0x02
     3b6:	b3 81       	ldd	r27, Z+3	; 0x03
     3b8:	bb 83       	std	Y+3, r27	; 0x03
     3ba:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     3bc:	15 96       	adiw	r26, 0x05	; 5
     3be:	dc 93       	st	X, r29
     3c0:	ce 93       	st	-X, r28
     3c2:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     3c4:	fd 83       	std	Y+5, r31	; 0x05
     3c6:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     3c8:	d3 83       	std	Z+3, r29	; 0x03
     3ca:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3cc:	99 87       	std	Y+9, r25	; 0x09
     3ce:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     3d0:	fc 01       	movw	r30, r24
     3d2:	20 81       	ld	r18, Z
     3d4:	2f 5f       	subi	r18, 0xFF	; 255
     3d6:	20 83       	st	Z, r18
}
     3d8:	df 91       	pop	r29
     3da:	cf 91       	pop	r28
     3dc:	08 95       	ret

000003de <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     3de:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     3e0:	a2 81       	ldd	r26, Z+2	; 0x02
     3e2:	b3 81       	ldd	r27, Z+3	; 0x03
     3e4:	84 81       	ldd	r24, Z+4	; 0x04
     3e6:	95 81       	ldd	r25, Z+5	; 0x05
     3e8:	15 96       	adiw	r26, 0x05	; 5
     3ea:	9c 93       	st	X, r25
     3ec:	8e 93       	st	-X, r24
     3ee:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     3f0:	a4 81       	ldd	r26, Z+4	; 0x04
     3f2:	b5 81       	ldd	r27, Z+5	; 0x05
     3f4:	82 81       	ldd	r24, Z+2	; 0x02
     3f6:	93 81       	ldd	r25, Z+3	; 0x03
     3f8:	13 96       	adiw	r26, 0x03	; 3
     3fa:	9c 93       	st	X, r25
     3fc:	8e 93       	st	-X, r24
     3fe:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     400:	a0 85       	ldd	r26, Z+8	; 0x08
     402:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     404:	11 96       	adiw	r26, 0x01	; 1
     406:	8d 91       	ld	r24, X+
     408:	9c 91       	ld	r25, X
     40a:	12 97       	sbiw	r26, 0x02	; 2
     40c:	e8 17       	cp	r30, r24
     40e:	f9 07       	cpc	r31, r25
     410:	31 f4       	brne	.+12     	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     412:	84 81       	ldd	r24, Z+4	; 0x04
     414:	95 81       	ldd	r25, Z+5	; 0x05
     416:	12 96       	adiw	r26, 0x02	; 2
     418:	9c 93       	st	X, r25
     41a:	8e 93       	st	-X, r24
     41c:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     41e:	11 86       	std	Z+9, r1	; 0x09
     420:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     422:	8c 91       	ld	r24, X
     424:	81 50       	subi	r24, 0x01	; 1
     426:	8c 93       	st	X, r24
     428:	08 95       	ret

0000042a <GetKeypadKey>:
unsigned char uv_password_fails = 0;
										
enum UserVerifyState {uv_init,uv_display,uv_password,} user_verify_state;

void UserVerify_Init(){
	user_verify_state = uv_init;
     42a:	8e ef       	ldi	r24, 0xFE	; 254
     42c:	88 b9       	out	0x08, r24	; 8
     42e:	00 00       	nop
     430:	86 b1       	in	r24, 0x06	; 6
     432:	80 95       	com	r24
     434:	84 fd       	sbrc	r24, 4
     436:	46 c0       	rjmp	.+140    	; 0x4c4 <GetKeypadKey+0x9a>
     438:	86 b1       	in	r24, 0x06	; 6
     43a:	80 95       	com	r24
     43c:	85 fd       	sbrc	r24, 5
     43e:	44 c0       	rjmp	.+136    	; 0x4c8 <GetKeypadKey+0x9e>
     440:	86 b1       	in	r24, 0x06	; 6
     442:	80 95       	com	r24
     444:	86 fd       	sbrc	r24, 6
     446:	42 c0       	rjmp	.+132    	; 0x4cc <GetKeypadKey+0xa2>
     448:	86 b1       	in	r24, 0x06	; 6
     44a:	80 95       	com	r24
     44c:	90 e0       	ldi	r25, 0x00	; 0
     44e:	88 0f       	add	r24, r24
     450:	89 2f       	mov	r24, r25
     452:	88 1f       	adc	r24, r24
     454:	99 0b       	sbc	r25, r25
     456:	91 95       	neg	r25
     458:	89 2b       	or	r24, r25
     45a:	d1 f5       	brne	.+116    	; 0x4d0 <GetKeypadKey+0xa6>
     45c:	8d ef       	ldi	r24, 0xFD	; 253
     45e:	88 b9       	out	0x08, r24	; 8
     460:	00 00       	nop
     462:	86 b1       	in	r24, 0x06	; 6
     464:	80 95       	com	r24
     466:	84 fd       	sbrc	r24, 4
     468:	35 c0       	rjmp	.+106    	; 0x4d4 <GetKeypadKey+0xaa>
     46a:	86 b1       	in	r24, 0x06	; 6
     46c:	80 95       	com	r24
     46e:	85 fd       	sbrc	r24, 5
     470:	33 c0       	rjmp	.+102    	; 0x4d8 <GetKeypadKey+0xae>
     472:	86 b1       	in	r24, 0x06	; 6
     474:	80 95       	com	r24
     476:	86 fd       	sbrc	r24, 6
     478:	31 c0       	rjmp	.+98     	; 0x4dc <GetKeypadKey+0xb2>
     47a:	86 b1       	in	r24, 0x06	; 6
     47c:	80 95       	com	r24
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	88 0f       	add	r24, r24
     482:	89 2f       	mov	r24, r25
     484:	88 1f       	adc	r24, r24
     486:	99 0b       	sbc	r25, r25
     488:	91 95       	neg	r25
     48a:	89 2b       	or	r24, r25
     48c:	49 f5       	brne	.+82     	; 0x4e0 <GetKeypadKey+0xb6>
     48e:	8b ef       	ldi	r24, 0xFB	; 251
     490:	88 b9       	out	0x08, r24	; 8
     492:	00 00       	nop
     494:	86 b1       	in	r24, 0x06	; 6
     496:	80 95       	com	r24
     498:	84 fd       	sbrc	r24, 4
     49a:	24 c0       	rjmp	.+72     	; 0x4e4 <GetKeypadKey+0xba>
     49c:	86 b1       	in	r24, 0x06	; 6
     49e:	80 95       	com	r24
     4a0:	85 fd       	sbrc	r24, 5
     4a2:	22 c0       	rjmp	.+68     	; 0x4e8 <GetKeypadKey+0xbe>
     4a4:	86 b1       	in	r24, 0x06	; 6
     4a6:	80 95       	com	r24
     4a8:	86 fd       	sbrc	r24, 6
     4aa:	20 c0       	rjmp	.+64     	; 0x4ec <GetKeypadKey+0xc2>
     4ac:	86 b1       	in	r24, 0x06	; 6
     4ae:	80 95       	com	r24
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	88 0f       	add	r24, r24
     4b4:	89 2f       	mov	r24, r25
     4b6:	88 1f       	adc	r24, r24
     4b8:	99 0b       	sbc	r25, r25
     4ba:	91 95       	neg	r25
     4bc:	89 2b       	or	r24, r25
     4be:	c1 f4       	brne	.+48     	; 0x4f0 <GetKeypadKey+0xc6>
     4c0:	80 e0       	ldi	r24, 0x00	; 0
     4c2:	08 95       	ret
     4c4:	81 e3       	ldi	r24, 0x31	; 49
     4c6:	08 95       	ret
     4c8:	84 e3       	ldi	r24, 0x34	; 52
     4ca:	08 95       	ret
     4cc:	87 e3       	ldi	r24, 0x37	; 55
     4ce:	08 95       	ret
     4d0:	8a e2       	ldi	r24, 0x2A	; 42
     4d2:	08 95       	ret
     4d4:	82 e3       	ldi	r24, 0x32	; 50
     4d6:	08 95       	ret
     4d8:	85 e3       	ldi	r24, 0x35	; 53
     4da:	08 95       	ret
     4dc:	88 e3       	ldi	r24, 0x38	; 56
     4de:	08 95       	ret
     4e0:	80 e3       	ldi	r24, 0x30	; 48
     4e2:	08 95       	ret
     4e4:	83 e3       	ldi	r24, 0x33	; 51
     4e6:	08 95       	ret
     4e8:	86 e3       	ldi	r24, 0x36	; 54
     4ea:	08 95       	ret
     4ec:	89 e3       	ldi	r24, 0x39	; 57
     4ee:	08 95       	ret
     4f0:	83 e2       	ldi	r24, 0x23	; 35
     4f2:	08 95       	ret

000004f4 <removeusers_intro>:
     4f4:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <number_of_users>
     4f8:	81 30       	cpi	r24, 0x01	; 1
     4fa:	91 f4       	brne	.+36     	; 0x520 <removeusers_intro+0x2c>
     4fc:	10 d3       	rcall	.+1568   	; 0xb1e <nokia_lcd_clear>
     4fe:	61 e0       	ldi	r22, 0x01	; 1
     500:	8d e6       	ldi	r24, 0x6D	; 109
     502:	91 e0       	ldi	r25, 0x01	; 1
     504:	f2 d3       	rcall	.+2020   	; 0xcea <nokia_lcd_write_string>
     506:	6a e0       	ldi	r22, 0x0A	; 10
     508:	80 e0       	ldi	r24, 0x00	; 0
     50a:	01 d4       	rcall	.+2050   	; 0xd0e <nokia_lcd_set_cursor>
     50c:	61 e0       	ldi	r22, 0x01	; 1
     50e:	89 e7       	ldi	r24, 0x79	; 121
     510:	91 e0       	ldi	r25, 0x01	; 1
     512:	eb d3       	rcall	.+2006   	; 0xcea <nokia_lcd_write_string>
     514:	61 e0       	ldi	r22, 0x01	; 1
     516:	81 e0       	ldi	r24, 0x01	; 1
     518:	91 e0       	ldi	r25, 0x01	; 1
     51a:	e7 d3       	rcall	.+1998   	; 0xcea <nokia_lcd_write_string>
     51c:	fd c3       	rjmp	.+2042   	; 0xd18 <nokia_lcd_render>
     51e:	08 95       	ret
     520:	82 30       	cpi	r24, 0x02	; 2
     522:	e9 f4       	brne	.+58     	; 0x55e <removeusers_intro+0x6a>
     524:	fc d2       	rcall	.+1528   	; 0xb1e <nokia_lcd_clear>
     526:	61 e0       	ldi	r22, 0x01	; 1
     528:	8d e6       	ldi	r24, 0x6D	; 109
     52a:	91 e0       	ldi	r25, 0x01	; 1
     52c:	de d3       	rcall	.+1980   	; 0xcea <nokia_lcd_write_string>
     52e:	6a e0       	ldi	r22, 0x0A	; 10
     530:	80 e0       	ldi	r24, 0x00	; 0
     532:	ed d3       	rcall	.+2010   	; 0xd0e <nokia_lcd_set_cursor>
     534:	61 e0       	ldi	r22, 0x01	; 1
     536:	89 e7       	ldi	r24, 0x79	; 121
     538:	91 e0       	ldi	r25, 0x01	; 1
     53a:	d7 d3       	rcall	.+1966   	; 0xcea <nokia_lcd_write_string>
     53c:	61 e0       	ldi	r22, 0x01	; 1
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	91 e0       	ldi	r25, 0x01	; 1
     542:	d3 d3       	rcall	.+1958   	; 0xcea <nokia_lcd_write_string>
     544:	64 e1       	ldi	r22, 0x14	; 20
     546:	80 e0       	ldi	r24, 0x00	; 0
     548:	e2 d3       	rcall	.+1988   	; 0xd0e <nokia_lcd_set_cursor>
     54a:	61 e0       	ldi	r22, 0x01	; 1
     54c:	8d e7       	ldi	r24, 0x7D	; 125
     54e:	91 e0       	ldi	r25, 0x01	; 1
     550:	cc d3       	rcall	.+1944   	; 0xcea <nokia_lcd_write_string>
     552:	61 e0       	ldi	r22, 0x01	; 1
     554:	8b e1       	ldi	r24, 0x1B	; 27
     556:	91 e0       	ldi	r25, 0x01	; 1
     558:	c8 d3       	rcall	.+1936   	; 0xcea <nokia_lcd_write_string>
     55a:	de c3       	rjmp	.+1980   	; 0xd18 <nokia_lcd_render>
     55c:	08 95       	ret
     55e:	83 30       	cpi	r24, 0x03	; 3
     560:	41 f5       	brne	.+80     	; 0x5b2 <removeusers_intro+0xbe>
     562:	dd d2       	rcall	.+1466   	; 0xb1e <nokia_lcd_clear>
     564:	61 e0       	ldi	r22, 0x01	; 1
     566:	8d e6       	ldi	r24, 0x6D	; 109
     568:	91 e0       	ldi	r25, 0x01	; 1
     56a:	bf d3       	rcall	.+1918   	; 0xcea <nokia_lcd_write_string>
     56c:	6a e0       	ldi	r22, 0x0A	; 10
     56e:	80 e0       	ldi	r24, 0x00	; 0
     570:	ce d3       	rcall	.+1948   	; 0xd0e <nokia_lcd_set_cursor>
     572:	61 e0       	ldi	r22, 0x01	; 1
     574:	89 e7       	ldi	r24, 0x79	; 121
     576:	91 e0       	ldi	r25, 0x01	; 1
     578:	b8 d3       	rcall	.+1904   	; 0xcea <nokia_lcd_write_string>
     57a:	61 e0       	ldi	r22, 0x01	; 1
     57c:	81 e0       	ldi	r24, 0x01	; 1
     57e:	91 e0       	ldi	r25, 0x01	; 1
     580:	b4 d3       	rcall	.+1896   	; 0xcea <nokia_lcd_write_string>
     582:	64 e1       	ldi	r22, 0x14	; 20
     584:	80 e0       	ldi	r24, 0x00	; 0
     586:	c3 d3       	rcall	.+1926   	; 0xd0e <nokia_lcd_set_cursor>
     588:	61 e0       	ldi	r22, 0x01	; 1
     58a:	8d e7       	ldi	r24, 0x7D	; 125
     58c:	91 e0       	ldi	r25, 0x01	; 1
     58e:	ad d3       	rcall	.+1882   	; 0xcea <nokia_lcd_write_string>
     590:	61 e0       	ldi	r22, 0x01	; 1
     592:	8b e1       	ldi	r24, 0x1B	; 27
     594:	91 e0       	ldi	r25, 0x01	; 1
     596:	a9 d3       	rcall	.+1874   	; 0xcea <nokia_lcd_write_string>
     598:	6e e1       	ldi	r22, 0x1E	; 30
     59a:	80 e0       	ldi	r24, 0x00	; 0
     59c:	b8 d3       	rcall	.+1904   	; 0xd0e <nokia_lcd_set_cursor>
     59e:	61 e0       	ldi	r22, 0x01	; 1
     5a0:	81 e8       	ldi	r24, 0x81	; 129
     5a2:	91 e0       	ldi	r25, 0x01	; 1
     5a4:	a2 d3       	rcall	.+1860   	; 0xcea <nokia_lcd_write_string>
     5a6:	61 e0       	ldi	r22, 0x01	; 1
     5a8:	85 e3       	ldi	r24, 0x35	; 53
     5aa:	91 e0       	ldi	r25, 0x01	; 1
     5ac:	9e d3       	rcall	.+1852   	; 0xcea <nokia_lcd_write_string>
     5ae:	b4 c3       	rjmp	.+1896   	; 0xd18 <nokia_lcd_render>
     5b0:	08 95       	ret
     5b2:	84 30       	cpi	r24, 0x04	; 4
     5b4:	09 f0       	breq	.+2      	; 0x5b8 <removeusers_intro+0xc4>
     5b6:	33 c0       	rjmp	.+102    	; 0x61e <removeusers_intro+0x12a>
     5b8:	b2 d2       	rcall	.+1380   	; 0xb1e <nokia_lcd_clear>
     5ba:	61 e0       	ldi	r22, 0x01	; 1
     5bc:	8d e6       	ldi	r24, 0x6D	; 109
     5be:	91 e0       	ldi	r25, 0x01	; 1
     5c0:	94 d3       	rcall	.+1832   	; 0xcea <nokia_lcd_write_string>
     5c2:	6a e0       	ldi	r22, 0x0A	; 10
     5c4:	80 e0       	ldi	r24, 0x00	; 0
     5c6:	a3 d3       	rcall	.+1862   	; 0xd0e <nokia_lcd_set_cursor>
     5c8:	61 e0       	ldi	r22, 0x01	; 1
     5ca:	89 e7       	ldi	r24, 0x79	; 121
     5cc:	91 e0       	ldi	r25, 0x01	; 1
     5ce:	8d d3       	rcall	.+1818   	; 0xcea <nokia_lcd_write_string>
     5d0:	61 e0       	ldi	r22, 0x01	; 1
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	91 e0       	ldi	r25, 0x01	; 1
     5d6:	89 d3       	rcall	.+1810   	; 0xcea <nokia_lcd_write_string>
     5d8:	64 e1       	ldi	r22, 0x14	; 20
     5da:	80 e0       	ldi	r24, 0x00	; 0
     5dc:	98 d3       	rcall	.+1840   	; 0xd0e <nokia_lcd_set_cursor>
     5de:	61 e0       	ldi	r22, 0x01	; 1
     5e0:	8d e7       	ldi	r24, 0x7D	; 125
     5e2:	91 e0       	ldi	r25, 0x01	; 1
     5e4:	82 d3       	rcall	.+1796   	; 0xcea <nokia_lcd_write_string>
     5e6:	61 e0       	ldi	r22, 0x01	; 1
     5e8:	8b e1       	ldi	r24, 0x1B	; 27
     5ea:	91 e0       	ldi	r25, 0x01	; 1
     5ec:	7e d3       	rcall	.+1788   	; 0xcea <nokia_lcd_write_string>
     5ee:	6e e1       	ldi	r22, 0x1E	; 30
     5f0:	80 e0       	ldi	r24, 0x00	; 0
     5f2:	8d d3       	rcall	.+1818   	; 0xd0e <nokia_lcd_set_cursor>
     5f4:	61 e0       	ldi	r22, 0x01	; 1
     5f6:	81 e8       	ldi	r24, 0x81	; 129
     5f8:	91 e0       	ldi	r25, 0x01	; 1
     5fa:	77 d3       	rcall	.+1774   	; 0xcea <nokia_lcd_write_string>
     5fc:	61 e0       	ldi	r22, 0x01	; 1
     5fe:	85 e3       	ldi	r24, 0x35	; 53
     600:	91 e0       	ldi	r25, 0x01	; 1
     602:	73 d3       	rcall	.+1766   	; 0xcea <nokia_lcd_write_string>
     604:	68 e2       	ldi	r22, 0x28	; 40
     606:	80 e0       	ldi	r24, 0x00	; 0
     608:	82 d3       	rcall	.+1796   	; 0xd0e <nokia_lcd_set_cursor>
     60a:	61 e0       	ldi	r22, 0x01	; 1
     60c:	85 e8       	ldi	r24, 0x85	; 133
     60e:	91 e0       	ldi	r25, 0x01	; 1
     610:	6c d3       	rcall	.+1752   	; 0xcea <nokia_lcd_write_string>
     612:	61 e0       	ldi	r22, 0x01	; 1
     614:	8f e4       	ldi	r24, 0x4F	; 79
     616:	91 e0       	ldi	r25, 0x01	; 1
     618:	68 d3       	rcall	.+1744   	; 0xcea <nokia_lcd_write_string>
     61a:	7e c3       	rjmp	.+1788   	; 0xd18 <nokia_lcd_render>
     61c:	08 95       	ret
     61e:	7f d2       	rcall	.+1278   	; 0xb1e <nokia_lcd_clear>
     620:	61 e0       	ldi	r22, 0x01	; 1
     622:	89 e8       	ldi	r24, 0x89	; 137
     624:	91 e0       	ldi	r25, 0x01	; 1
     626:	61 d3       	rcall	.+1730   	; 0xcea <nokia_lcd_write_string>
     628:	77 c3       	rjmp	.+1774   	; 0xd18 <nokia_lcd_render>
     62a:	08 95       	ret

0000062c <remove_password_verification>:
     62c:	e0 91 6a 01 	lds	r30, 0x016A	; 0x80016a <user_to_remove>
     630:	8a e1       	ldi	r24, 0x1A	; 26
     632:	e8 9f       	mul	r30, r24
     634:	d0 01       	movw	r26, r0
     636:	11 24       	eor	r1, r1
     638:	af 5f       	subi	r26, 0xFF	; 255
     63a:	be 4f       	sbci	r27, 0xFE	; 254
     63c:	51 96       	adiw	r26, 0x11	; 17
     63e:	9c 91       	ld	r25, X
     640:	80 91 e9 07 	lds	r24, 0x07E9	; 0x8007e9 <temporary_password>
     644:	98 13       	cpse	r25, r24
     646:	13 c0       	rjmp	.+38     	; 0x66e <remove_password_verification+0x42>
     648:	8a e1       	ldi	r24, 0x1A	; 26
     64a:	e8 9f       	mul	r30, r24
     64c:	f0 01       	movw	r30, r0
     64e:	11 24       	eor	r1, r1
     650:	ed 5e       	subi	r30, 0xED	; 237
     652:	fe 4f       	sbci	r31, 0xFE	; 254
     654:	aa ee       	ldi	r26, 0xEA	; 234
     656:	b7 e0       	ldi	r27, 0x07	; 7
     658:	21 ef       	ldi	r18, 0xF1	; 241
     65a:	37 e0       	ldi	r19, 0x07	; 7
     65c:	91 91       	ld	r25, Z+
     65e:	8d 91       	ld	r24, X+
     660:	98 13       	cpse	r25, r24
     662:	07 c0       	rjmp	.+14     	; 0x672 <remove_password_verification+0x46>
     664:	a2 17       	cp	r26, r18
     666:	b3 07       	cpc	r27, r19
     668:	c9 f7       	brne	.-14     	; 0x65c <remove_password_verification+0x30>
     66a:	81 e0       	ldi	r24, 0x01	; 1
     66c:	08 95       	ret
     66e:	80 e0       	ldi	r24, 0x00	; 0
     670:	08 95       	ret
     672:	80 e0       	ldi	r24, 0x00	; 0
     674:	08 95       	ret

00000676 <UserVerify_Tick>:
}

void UserVerify_Tick(){
     676:	ff 92       	push	r15
     678:	0f 93       	push	r16
     67a:	1f 93       	push	r17
     67c:	cf 93       	push	r28
     67e:	df 93       	push	r29
	//Actions
	switch(user_verify_state){
     680:	80 91 46 0a 	lds	r24, 0x0A46	; 0x800a46 <user_verify_state>
     684:	81 30       	cpi	r24, 0x01	; 1
     686:	49 f0       	breq	.+18     	; 0x69a <UserVerify_Tick+0x24>
     688:	82 30       	cpi	r24, 0x02	; 2
     68a:	21 f1       	breq	.+72     	; 0x6d4 <UserVerify_Tick+0x5e>
     68c:	cd c0       	rjmp	.+410    	; 0x828 <UserVerify_Tick+0x1b2>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     68e:	8f e4       	ldi	r24, 0x4F	; 79
     690:	93 ec       	ldi	r25, 0xC3	; 195
     692:	01 97       	sbiw	r24, 0x01	; 1
     694:	f1 f7       	brne	.-4      	; 0x692 <UserVerify_Tick+0x1c>
     696:	00 c0       	rjmp	.+0      	; 0x698 <UserVerify_Tick+0x22>
     698:	00 00       	nop
		case uv_init:
			break;
		
		case uv_display:
			while((uv_selection = GetKeypadKey()) == '\0'){ _delay_ms(200); }
     69a:	c7 de       	rcall	.-626    	; 0x42a <GetKeypadKey>
     69c:	80 93 e6 07 	sts	0x07E6, r24	; 0x8007e6 <uv_selection>
     6a0:	88 23       	and	r24, r24
     6a2:	a9 f3       	breq	.-22     	; 0x68e <UserVerify_Tick+0x18>
     6a4:	06 c0       	rjmp	.+12     	; 0x6b2 <UserVerify_Tick+0x3c>
     6a6:	ef e4       	ldi	r30, 0x4F	; 79
     6a8:	f3 ec       	ldi	r31, 0xC3	; 195
     6aa:	31 97       	sbiw	r30, 0x01	; 1
     6ac:	f1 f7       	brne	.-4      	; 0x6aa <UserVerify_Tick+0x34>
     6ae:	00 c0       	rjmp	.+0      	; 0x6b0 <UserVerify_Tick+0x3a>
			while((uv_prev_select = GetKeypadKey()) == uv_selection){ _delay_ms(200); }
     6b0:	00 00       	nop
     6b2:	bb de       	rcall	.-650    	; 0x42a <GetKeypadKey>
     6b4:	80 93 e5 07 	sts	0x07E5, r24	; 0x8007e5 <uv_prev_select>
     6b8:	90 91 e6 07 	lds	r25, 0x07E6	; 0x8007e6 <uv_selection>
     6bc:	89 17       	cp	r24, r25
     6be:	99 f3       	breq	.-26     	; 0x6a6 <UserVerify_Tick+0x30>
			
			uv_selection = uv_selection - '1';
     6c0:	91 53       	subi	r25, 0x31	; 49
     6c2:	90 93 e6 07 	sts	0x07E6, r25	; 0x8007e6 <uv_selection>
			break;
     6c6:	b0 c0       	rjmp	.+352    	; 0x828 <UserVerify_Tick+0x1b2>
     6c8:	8f e4       	ldi	r24, 0x4F	; 79
     6ca:	93 ec       	ldi	r25, 0xC3	; 195
     6cc:	01 97       	sbiw	r24, 0x01	; 1
     6ce:	f1 f7       	brne	.-4      	; 0x6cc <UserVerify_Tick+0x56>
     6d0:	00 c0       	rjmp	.+0      	; 0x6d2 <UserVerify_Tick+0x5c>
			
		case uv_password:
			while((uv_selection = GetKeypadKey()) == '\0'){ _delay_ms(200); }
     6d2:	00 00       	nop
     6d4:	aa de       	rcall	.-684    	; 0x42a <GetKeypadKey>
     6d6:	80 93 e6 07 	sts	0x07E6, r24	; 0x8007e6 <uv_selection>
     6da:	88 23       	and	r24, r24
     6dc:	a9 f3       	breq	.-22     	; 0x6c8 <UserVerify_Tick+0x52>
     6de:	06 c0       	rjmp	.+12     	; 0x6ec <UserVerify_Tick+0x76>
     6e0:	ef e4       	ldi	r30, 0x4F	; 79
     6e2:	f3 ec       	ldi	r31, 0xC3	; 195
     6e4:	31 97       	sbiw	r30, 0x01	; 1
     6e6:	f1 f7       	brne	.-4      	; 0x6e4 <UserVerify_Tick+0x6e>
     6e8:	00 c0       	rjmp	.+0      	; 0x6ea <UserVerify_Tick+0x74>
			while((uv_prev_select = GetKeypadKey()) == uv_selection){ _delay_ms(200); }
     6ea:	00 00       	nop
     6ec:	9e de       	rcall	.-708    	; 0x42a <GetKeypadKey>
     6ee:	80 93 e5 07 	sts	0x07E5, r24	; 0x8007e5 <uv_prev_select>
     6f2:	90 91 e6 07 	lds	r25, 0x07E6	; 0x8007e6 <uv_selection>
     6f6:	89 17       	cp	r24, r25
     6f8:	99 f3       	breq	.-26     	; 0x6e0 <UserVerify_Tick+0x6a>
     6fa:	c1 ef       	ldi	r28, 0xF1	; 241
     6fc:	d7 e0       	ldi	r29, 0x07	; 7
				if(uv_selection == '*'){
					password_size = 0;
					for(unsigned char i = 0; i < 8; ++i){
						temporary_password[i] = '\0';
					}
					temporary_password[0] = '*';
     6fe:	09 ee       	ldi	r16, 0xE9	; 233
     700:	17 e0       	ldi	r17, 0x07	; 7
     702:	0f 2e       	mov	r0, r31
     704:	fa e2       	ldi	r31, 0x2A	; 42
     706:	ff 2e       	mov	r15, r31
     708:	f0 2d       	mov	r31, r0
     70a:	75 c0       	rjmp	.+234    	; 0x7f6 <UserVerify_Tick+0x180>
		case uv_password:
			while((uv_selection = GetKeypadKey()) == '\0'){ _delay_ms(200); }
			while((uv_prev_select = GetKeypadKey()) == uv_selection){ _delay_ms(200); }
			
			while(uv_selection != '#'){
				if(uv_selection != '\0' && uv_selection != '*'){
     70c:	88 23       	and	r24, r24
     70e:	09 f4       	brne	.+2      	; 0x712 <UserVerify_Tick+0x9c>
     710:	5f c0       	rjmp	.+190    	; 0x7d0 <UserVerify_Tick+0x15a>
     712:	8a 32       	cpi	r24, 0x2A	; 42
     714:	a1 f1       	breq	.+104    	; 0x77e <UserVerify_Tick+0x108>
					if(password_size < 8){
     716:	20 91 e8 07 	lds	r18, 0x07E8	; 0x8007e8 <password_size>
     71a:	28 30       	cpi	r18, 0x08	; 8
     71c:	08 f0       	brcs	.+2      	; 0x720 <UserVerify_Tick+0xaa>
     71e:	58 c0       	rjmp	.+176    	; 0x7d0 <UserVerify_Tick+0x15a>
						temporary_password[password_size] = uv_selection;
     720:	30 e0       	ldi	r19, 0x00	; 0
     722:	f9 01       	movw	r30, r18
     724:	e7 51       	subi	r30, 0x17	; 23
     726:	f8 4f       	sbci	r31, 0xF8	; 248
     728:	80 83       	st	Z, r24
						if(password_size + 1 < 8){
     72a:	2f 5f       	subi	r18, 0xFF	; 255
     72c:	3f 4f       	sbci	r19, 0xFF	; 255
     72e:	28 30       	cpi	r18, 0x08	; 8
     730:	31 05       	cpc	r19, r1
     732:	24 f4       	brge	.+8      	; 0x73c <UserVerify_Tick+0xc6>
							temporary_password[password_size + 1] = '*';
     734:	f9 01       	movw	r30, r18
     736:	e7 51       	subi	r30, 0x17	; 23
     738:	f8 4f       	sbci	r31, 0xF8	; 248
						}
						nokia_lcd_clear();
     73a:	f0 82       	st	Z, r15
						nokia_lcd_write_string("Enter",1);
     73c:	f0 d1       	rcall	.+992    	; 0xb1e <nokia_lcd_clear>
     73e:	61 e0       	ldi	r22, 0x01	; 1
     740:	81 ec       	ldi	r24, 0xC1	; 193
     742:	91 e0       	ldi	r25, 0x01	; 1
						nokia_lcd_set_cursor(0,10);
     744:	d2 d2       	rcall	.+1444   	; 0xcea <nokia_lcd_write_string>
     746:	6a e0       	ldi	r22, 0x0A	; 10
     748:	80 e0       	ldi	r24, 0x00	; 0
						nokia_lcd_write_string("Password: ",1);
     74a:	e1 d2       	rcall	.+1474   	; 0xd0e <nokia_lcd_set_cursor>
     74c:	61 e0       	ldi	r22, 0x01	; 1
     74e:	87 ec       	ldi	r24, 0xC7	; 199
     750:	91 e0       	ldi	r25, 0x01	; 1
						nokia_lcd_write_char(uv_password_fails + '0',1);
     752:	cb d2       	rcall	.+1430   	; 0xcea <nokia_lcd_write_string>
     754:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <uv_password_fails>
     758:	61 e0       	ldi	r22, 0x01	; 1
						nokia_lcd_set_cursor(0,20);
     75a:	80 5d       	subi	r24, 0xD0	; 208
     75c:	1c d2       	rcall	.+1080   	; 0xb96 <nokia_lcd_write_char>
     75e:	64 e1       	ldi	r22, 0x14	; 20
     760:	80 e0       	ldi	r24, 0x00	; 0
						nokia_lcd_write_string(temporary_password,1);
     762:	d5 d2       	rcall	.+1450   	; 0xd0e <nokia_lcd_set_cursor>
     764:	61 e0       	ldi	r22, 0x01	; 1
     766:	c8 01       	movw	r24, r16
     768:	c0 d2       	rcall	.+1408   	; 0xcea <nokia_lcd_write_string>
						nokia_lcd_render();
     76a:	d6 d2       	rcall	.+1452   	; 0xd18 <nokia_lcd_render>
     76c:	80 91 e8 07 	lds	r24, 0x07E8	; 0x8007e8 <password_size>
						
						++password_size;
     770:	8f 5f       	subi	r24, 0xFF	; 255
     772:	80 93 e8 07 	sts	0x07E8, r24	; 0x8007e8 <password_size>
     776:	80 91 e6 07 	lds	r24, 0x07E6	; 0x8007e6 <uv_selection>
					}
				}
				
				if(uv_selection == '*'){
     77a:	8a 32       	cpi	r24, 0x2A	; 42
     77c:	49 f5       	brne	.+82     	; 0x7d0 <UserVerify_Tick+0x15a>
					password_size = 0;
     77e:	10 92 e8 07 	sts	0x07E8, r1	; 0x8007e8 <password_size>
     782:	e9 ee       	ldi	r30, 0xE9	; 233
					for(unsigned char i = 0; i < 8; ++i){
						temporary_password[i] = '\0';
     784:	f7 e0       	ldi	r31, 0x07	; 7
					}
				}
				
				if(uv_selection == '*'){
					password_size = 0;
					for(unsigned char i = 0; i < 8; ++i){
     786:	11 92       	st	Z+, r1
     788:	ce 17       	cp	r28, r30
						temporary_password[i] = '\0';
					}
					temporary_password[0] = '*';
     78a:	df 07       	cpc	r29, r31
					nokia_lcd_clear();
     78c:	e1 f7       	brne	.-8      	; 0x786 <UserVerify_Tick+0x110>
     78e:	f8 01       	movw	r30, r16
					nokia_lcd_write_string("Enter",1);
     790:	f0 82       	st	Z, r15
     792:	c5 d1       	rcall	.+906    	; 0xb1e <nokia_lcd_clear>
     794:	61 e0       	ldi	r22, 0x01	; 1
     796:	81 ec       	ldi	r24, 0xC1	; 193
					nokia_lcd_set_cursor(0,10);
     798:	91 e0       	ldi	r25, 0x01	; 1
     79a:	a7 d2       	rcall	.+1358   	; 0xcea <nokia_lcd_write_string>
     79c:	6a e0       	ldi	r22, 0x0A	; 10
					nokia_lcd_write_string("Password: ",1);
     79e:	80 e0       	ldi	r24, 0x00	; 0
     7a0:	b6 d2       	rcall	.+1388   	; 0xd0e <nokia_lcd_set_cursor>
     7a2:	61 e0       	ldi	r22, 0x01	; 1
     7a4:	87 ec       	ldi	r24, 0xC7	; 199
					nokia_lcd_write_char(uv_password_fails + '0',1);
     7a6:	91 e0       	ldi	r25, 0x01	; 1
     7a8:	a0 d2       	rcall	.+1344   	; 0xcea <nokia_lcd_write_string>
     7aa:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <uv_password_fails>
     7ae:	61 e0       	ldi	r22, 0x01	; 1
					nokia_lcd_set_cursor(0,20);
     7b0:	80 5d       	subi	r24, 0xD0	; 208
     7b2:	f1 d1       	rcall	.+994    	; 0xb96 <nokia_lcd_write_char>
     7b4:	64 e1       	ldi	r22, 0x14	; 20
     7b6:	80 e0       	ldi	r24, 0x00	; 0
					nokia_lcd_write_string(temporary_password,1);
     7b8:	aa d2       	rcall	.+1364   	; 0xd0e <nokia_lcd_set_cursor>
     7ba:	61 e0       	ldi	r22, 0x01	; 1
     7bc:	c8 01       	movw	r24, r16
     7be:	95 d2       	rcall	.+1322   	; 0xcea <nokia_lcd_write_string>
					nokia_lcd_render();
     7c0:	ab d2       	rcall	.+1366   	; 0xd18 <nokia_lcd_render>
     7c2:	06 c0       	rjmp	.+12     	; 0x7d0 <UserVerify_Tick+0x15a>
     7c4:	8f e4       	ldi	r24, 0x4F	; 79
     7c6:	93 ec       	ldi	r25, 0xC3	; 195
     7c8:	01 97       	sbiw	r24, 0x01	; 1
     7ca:	f1 f7       	brne	.-4      	; 0x7c8 <UserVerify_Tick+0x152>
     7cc:	00 c0       	rjmp	.+0      	; 0x7ce <UserVerify_Tick+0x158>
     7ce:	00 00       	nop
				}
				
				while((uv_selection = GetKeypadKey()) == '\0'){ _delay_ms(200); }
     7d0:	2c de       	rcall	.-936    	; 0x42a <GetKeypadKey>
     7d2:	80 93 e6 07 	sts	0x07E6, r24	; 0x8007e6 <uv_selection>
     7d6:	88 23       	and	r24, r24
     7d8:	a9 f3       	breq	.-22     	; 0x7c4 <UserVerify_Tick+0x14e>
     7da:	06 c0       	rjmp	.+12     	; 0x7e8 <UserVerify_Tick+0x172>
     7dc:	ef e4       	ldi	r30, 0x4F	; 79
     7de:	f3 ec       	ldi	r31, 0xC3	; 195
     7e0:	31 97       	sbiw	r30, 0x01	; 1
     7e2:	f1 f7       	brne	.-4      	; 0x7e0 <UserVerify_Tick+0x16a>
     7e4:	00 c0       	rjmp	.+0      	; 0x7e6 <UserVerify_Tick+0x170>
     7e6:	00 00       	nop
				while((uv_prev_select = GetKeypadKey()) == uv_selection){ _delay_ms(200); }
     7e8:	20 de       	rcall	.-960    	; 0x42a <GetKeypadKey>
     7ea:	80 93 e5 07 	sts	0x07E5, r24	; 0x8007e5 <uv_prev_select>
     7ee:	90 91 e6 07 	lds	r25, 0x07E6	; 0x8007e6 <uv_selection>
     7f2:	89 17       	cp	r24, r25
     7f4:	99 f3       	breq	.-26     	; 0x7dc <UserVerify_Tick+0x166>
     7f6:	80 91 e6 07 	lds	r24, 0x07E6	; 0x8007e6 <uv_selection>
			
		case uv_password:
			while((uv_selection = GetKeypadKey()) == '\0'){ _delay_ms(200); }
			while((uv_prev_select = GetKeypadKey()) == uv_selection){ _delay_ms(200); }
			
			while(uv_selection != '#'){
     7fa:	83 32       	cpi	r24, 0x23	; 35
     7fc:	09 f0       	breq	.+2      	; 0x800 <UserVerify_Tick+0x18a>
     7fe:	86 cf       	rjmp	.-244    	; 0x70c <UserVerify_Tick+0x96>
     800:	15 df       	rcall	.-470    	; 0x62c <remove_password_verification>
				while((uv_selection = GetKeypadKey()) == '\0'){ _delay_ms(200); }
				while((uv_prev_select = GetKeypadKey()) == uv_selection){ _delay_ms(200); }
			}
			
			
			if(!remove_password_verification()){
     802:	81 11       	cpse	r24, r1
     804:	06 c0       	rjmp	.+12     	; 0x812 <UserVerify_Tick+0x19c>
     806:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <uv_password_fails>
				++uv_password_fails;
     80a:	8f 5f       	subi	r24, 0xFF	; 255
     80c:	80 93 e4 07 	sts	0x07E4, r24	; 0x8007e4 <uv_password_fails>
     810:	0b c0       	rjmp	.+22     	; 0x828 <UserVerify_Tick+0x1b2>
     812:	10 92 e4 07 	sts	0x07E4, r1	; 0x8007e4 <uv_password_fails>
			}
			
			else{
				uv_password_fails = 0;
     816:	80 91 46 0a 	lds	r24, 0x0A46	; 0x800a46 <user_verify_state>
			
		default:
			break;
	}
	//Transitions
	switch(user_verify_state){
     81a:	81 30       	cpi	r24, 0x01	; 1
     81c:	e9 f0       	breq	.+58     	; 0x858 <UserVerify_Tick+0x1e2>
     81e:	68 f0       	brcs	.+26     	; 0x83a <UserVerify_Tick+0x1c4>
     820:	82 30       	cpi	r24, 0x02	; 2
     822:	09 f0       	breq	.+2      	; 0x826 <UserVerify_Tick+0x1b0>
     824:	e9 c0       	rjmp	.+466    	; 0x9f8 <UserVerify_Tick+0x382>
     826:	67 c0       	rjmp	.+206    	; 0x8f6 <UserVerify_Tick+0x280>
     828:	80 91 46 0a 	lds	r24, 0x0A46	; 0x800a46 <user_verify_state>
     82c:	81 30       	cpi	r24, 0x01	; 1
     82e:	a1 f0       	breq	.+40     	; 0x858 <UserVerify_Tick+0x1e2>
     830:	20 f0       	brcs	.+8      	; 0x83a <UserVerify_Tick+0x1c4>
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	09 f4       	brne	.+2      	; 0x838 <UserVerify_Tick+0x1c2>
     836:	5b c0       	rjmp	.+182    	; 0x8ee <UserVerify_Tick+0x278>
     838:	df c0       	rjmp	.+446    	; 0x9f8 <UserVerify_Tick+0x382>
     83a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
		case uv_init:
			if(user_verify_flag){
     83e:	88 23       	and	r24, r24
     840:	09 f4       	brne	.+2      	; 0x844 <UserVerify_Tick+0x1ce>
     842:	da c0       	rjmp	.+436    	; 0x9f8 <UserVerify_Tick+0x382>
     844:	57 de       	rcall	.-850    	; 0x4f4 <removeusers_intro>
				removeusers_intro();
     846:	85 e0       	ldi	r24, 0x05	; 5
				user_to_remove = 5;
     848:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <user_to_remove>
     84c:	10 92 e7 07 	sts	0x07E7, r1	; 0x8007e7 <correct_user_credentials>
				correct_user_credentials = 0;
				user_verify_state = uv_display;
     850:	81 e0       	ldi	r24, 0x01	; 1
     852:	80 93 46 0a 	sts	0x0A46, r24	; 0x800a46 <user_verify_state>
				user_verify_state = uv_init;
			}
			break;
			
		case uv_display:
			if(uv_selection < number_of_users && user_verify_flag){
     856:	d0 c0       	rjmp	.+416    	; 0x9f8 <UserVerify_Tick+0x382>
     858:	80 91 e6 07 	lds	r24, 0x07E6	; 0x8007e6 <uv_selection>
     85c:	90 91 69 01 	lds	r25, 0x0169	; 0x800169 <number_of_users>
     860:	89 17       	cp	r24, r25
     862:	80 f5       	brcc	.+96     	; 0x8c4 <UserVerify_Tick+0x24e>
     864:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <__data_start>
				user_to_remove = uv_selection;
     868:	99 23       	and	r25, r25
				uv_password_fails = 0;
     86a:	81 f1       	breq	.+96     	; 0x8cc <UserVerify_Tick+0x256>
				nokia_lcd_clear();
     86c:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <user_to_remove>
				nokia_lcd_write_string("Enter",1);
     870:	10 92 e4 07 	sts	0x07E4, r1	; 0x8007e4 <uv_password_fails>
     874:	54 d1       	rcall	.+680    	; 0xb1e <nokia_lcd_clear>
     876:	61 e0       	ldi	r22, 0x01	; 1
				nokia_lcd_set_cursor(0,10);
     878:	81 ec       	ldi	r24, 0xC1	; 193
     87a:	91 e0       	ldi	r25, 0x01	; 1
     87c:	36 d2       	rcall	.+1132   	; 0xcea <nokia_lcd_write_string>
     87e:	6a e0       	ldi	r22, 0x0A	; 10
				nokia_lcd_write_string("Password: ",1);
     880:	80 e0       	ldi	r24, 0x00	; 0
     882:	45 d2       	rcall	.+1162   	; 0xd0e <nokia_lcd_set_cursor>
     884:	61 e0       	ldi	r22, 0x01	; 1
     886:	87 ec       	ldi	r24, 0xC7	; 199
     888:	91 e0       	ldi	r25, 0x01	; 1
				nokia_lcd_write_char(uv_password_fails + '0',1);
     88a:	2f d2       	rcall	.+1118   	; 0xcea <nokia_lcd_write_string>
     88c:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <uv_password_fails>
     890:	61 e0       	ldi	r22, 0x01	; 1
     892:	80 5d       	subi	r24, 0xD0	; 208
     894:	80 d1       	rcall	.+768    	; 0xb96 <nokia_lcd_write_char>
				nokia_lcd_set_cursor(0,20);
     896:	64 e1       	ldi	r22, 0x14	; 20
     898:	80 e0       	ldi	r24, 0x00	; 0
     89a:	39 d2       	rcall	.+1138   	; 0xd0e <nokia_lcd_set_cursor>
     89c:	61 e0       	ldi	r22, 0x01	; 1
				nokia_lcd_write_string("*",1);
     89e:	82 ed       	ldi	r24, 0xD2	; 210
     8a0:	91 e0       	ldi	r25, 0x01	; 1
     8a2:	23 d2       	rcall	.+1094   	; 0xcea <nokia_lcd_write_string>
     8a4:	39 d2       	rcall	.+1138   	; 0xd18 <nokia_lcd_render>
     8a6:	e9 ee       	ldi	r30, 0xE9	; 233
				nokia_lcd_render();
     8a8:	f7 e0       	ldi	r31, 0x07	; 7
     8aa:	81 ef       	ldi	r24, 0xF1	; 241
     8ac:	97 e0       	ldi	r25, 0x07	; 7
     8ae:	11 92       	st	Z+, r1
     8b0:	e8 17       	cp	r30, r24
     8b2:	f9 07       	cpc	r31, r25
				for(unsigned char i = 0; i < 8; ++i){
					temporary_password[i] = '\0';
     8b4:	e1 f7       	brne	.-8      	; 0x8ae <UserVerify_Tick+0x238>
				nokia_lcd_write_string("Password: ",1);
				nokia_lcd_write_char(uv_password_fails + '0',1);
				nokia_lcd_set_cursor(0,20);
				nokia_lcd_write_string("*",1);
				nokia_lcd_render();
				for(unsigned char i = 0; i < 8; ++i){
     8b6:	8a e2       	ldi	r24, 0x2A	; 42
     8b8:	80 93 e9 07 	sts	0x07E9, r24	; 0x8007e9 <temporary_password>
					temporary_password[i] = '\0';
				}
				temporary_password[0] = '*';
     8bc:	82 e0       	ldi	r24, 0x02	; 2
     8be:	80 93 46 0a 	sts	0x0A46, r24	; 0x800a46 <user_verify_state>
				user_verify_state = uv_password;
     8c2:	9a c0       	rjmp	.+308    	; 0x9f8 <UserVerify_Tick+0x382>
     8c4:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
			}
			
			else if(!user_verify_flag){
     8c8:	81 11       	cpse	r24, r1
     8ca:	96 c0       	rjmp	.+300    	; 0x9f8 <UserVerify_Tick+0x382>
     8cc:	10 92 e4 07 	sts	0x07E4, r1	; 0x8007e4 <uv_password_fails>
				uv_password_fails = 0;
				password_size = 0;
     8d0:	10 92 e8 07 	sts	0x07E8, r1	; 0x8007e8 <password_size>
     8d4:	e9 ee       	ldi	r30, 0xE9	; 233
     8d6:	f7 e0       	ldi	r31, 0x07	; 7
				for(unsigned char i = 0; i < 8; ++i){
					temporary_password[i] = '\0';
     8d8:	81 ef       	ldi	r24, 0xF1	; 241
			}
			
			else if(!user_verify_flag){
				uv_password_fails = 0;
				password_size = 0;
				for(unsigned char i = 0; i < 8; ++i){
     8da:	97 e0       	ldi	r25, 0x07	; 7
     8dc:	11 92       	st	Z+, r1
     8de:	e8 17       	cp	r30, r24
					temporary_password[i] = '\0';
				}
				temporary_password[0] = '\0';
     8e0:	f9 07       	cpc	r31, r25
     8e2:	e1 f7       	brne	.-8      	; 0x8dc <UserVerify_Tick+0x266>
				user_verify_state = uv_init;
     8e4:	10 92 e9 07 	sts	0x07E9, r1	; 0x8007e9 <temporary_password>
     8e8:	10 92 46 0a 	sts	0x0A46, r1	; 0x800a46 <user_verify_state>
			}
			
			break;
		
		case uv_password:
			if(uv_password_fails == 0 && user_verify_flag){
     8ec:	85 c0       	rjmp	.+266    	; 0x9f8 <UserVerify_Tick+0x382>
     8ee:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <uv_password_fails>
     8f2:	81 11       	cpse	r24, r1
     8f4:	1a c0       	rjmp	.+52     	; 0x92a <UserVerify_Tick+0x2b4>
     8f6:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     8fa:	88 23       	and	r24, r24
				nokia_lcd_clear();
     8fc:	09 f4       	brne	.+2      	; 0x900 <UserVerify_Tick+0x28a>
     8fe:	6c c0       	rjmp	.+216    	; 0x9d8 <UserVerify_Tick+0x362>
				nokia_lcd_write_string("User verified",1);
     900:	0e d1       	rcall	.+540    	; 0xb1e <nokia_lcd_clear>
     902:	61 e0       	ldi	r22, 0x01	; 1
     904:	84 ed       	ldi	r24, 0xD4	; 212
     906:	91 e0       	ldi	r25, 0x01	; 1
     908:	f0 d1       	rcall	.+992    	; 0xcea <nokia_lcd_write_string>
				nokia_lcd_set_cursor(0,10);
     90a:	6a e0       	ldi	r22, 0x0A	; 10
     90c:	80 e0       	ldi	r24, 0x00	; 0
     90e:	ff d1       	rcall	.+1022   	; 0xd0e <nokia_lcd_set_cursor>
				nokia_lcd_write_string("successfully",1);
     910:	61 e0       	ldi	r22, 0x01	; 1
     912:	84 ee       	ldi	r24, 0xE4	; 228
     914:	91 e0       	ldi	r25, 0x01	; 1
     916:	e9 d1       	rcall	.+978    	; 0xcea <nokia_lcd_write_string>
				nokia_lcd_render();
     918:	ff d1       	rcall	.+1022   	; 0xd18 <nokia_lcd_render>
				correct_user_credentials = 1;
     91a:	81 e0       	ldi	r24, 0x01	; 1
     91c:	80 93 e7 07 	sts	0x07E7, r24	; 0x8007e7 <correct_user_credentials>
				user_verify_flag = 0;
     920:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__data_start>
				user_verify_state = uv_init;
     924:	10 92 46 0a 	sts	0x0A46, r1	; 0x800a46 <user_verify_state>
			}
			
			else if(uv_password_fails == 3 && user_verify_flag){
     928:	67 c0       	rjmp	.+206    	; 0x9f8 <UserVerify_Tick+0x382>
     92a:	83 30       	cpi	r24, 0x03	; 3
     92c:	39 f5       	brne	.+78     	; 0x97c <UserVerify_Tick+0x306>
     92e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     932:	88 23       	and	r24, r24
     934:	09 f4       	brne	.+2      	; 0x938 <UserVerify_Tick+0x2c2>
				uv_password_fails = 0;
     936:	50 c0       	rjmp	.+160    	; 0x9d8 <UserVerify_Tick+0x362>
				password_size = 0;
     938:	10 92 e4 07 	sts	0x07E4, r1	; 0x8007e4 <uv_password_fails>
     93c:	10 92 e8 07 	sts	0x07E8, r1	; 0x8007e8 <password_size>
     940:	e9 ee       	ldi	r30, 0xE9	; 233
				for(unsigned char i = 0; i < 8; ++i){
     942:	f7 e0       	ldi	r31, 0x07	; 7
     944:	81 ef       	ldi	r24, 0xF1	; 241
     946:	97 e0       	ldi	r25, 0x07	; 7
					temporary_password[i] = '\0';
				}
				temporary_password[0] = '\0';
     948:	11 92       	st	Z+, r1
				nokia_lcd_clear();
     94a:	8e 17       	cp	r24, r30
     94c:	9f 07       	cpc	r25, r31
				nokia_lcd_write_string("User verified",1);
     94e:	e1 f7       	brne	.-8      	; 0x948 <UserVerify_Tick+0x2d2>
     950:	10 92 e9 07 	sts	0x07E9, r1	; 0x8007e9 <temporary_password>
     954:	e4 d0       	rcall	.+456    	; 0xb1e <nokia_lcd_clear>
				nokia_lcd_set_cursor(0,10);
     956:	61 e0       	ldi	r22, 0x01	; 1
     958:	84 ed       	ldi	r24, 0xD4	; 212
     95a:	91 e0       	ldi	r25, 0x01	; 1
				nokia_lcd_write_string("unsuccessfully",1);
     95c:	c6 d1       	rcall	.+908    	; 0xcea <nokia_lcd_write_string>
     95e:	6a e0       	ldi	r22, 0x0A	; 10
     960:	80 e0       	ldi	r24, 0x00	; 0
     962:	d5 d1       	rcall	.+938    	; 0xd0e <nokia_lcd_set_cursor>
				nokia_lcd_render();
     964:	61 e0       	ldi	r22, 0x01	; 1
     966:	82 ee       	ldi	r24, 0xE2	; 226
				correct_user_credentials = 0;
     968:	91 e0       	ldi	r25, 0x01	; 1
     96a:	bf d1       	rcall	.+894    	; 0xcea <nokia_lcd_write_string>
				user_verify_flag = 0;
     96c:	d5 d1       	rcall	.+938    	; 0xd18 <nokia_lcd_render>
     96e:	10 92 e7 07 	sts	0x07E7, r1	; 0x8007e7 <correct_user_credentials>
				user_verify_state = uv_init;
     972:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__data_start>
			}
			
			else if(uv_password_fails != 0 && uv_password_fails != 3 && user_verify_flag){
     976:	10 92 46 0a 	sts	0x0A46, r1	; 0x800a46 <user_verify_state>
     97a:	3e c0       	rjmp	.+124    	; 0x9f8 <UserVerify_Tick+0x382>
     97c:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
				nokia_lcd_clear();
     980:	88 23       	and	r24, r24
				nokia_lcd_write_string("Enter",1);
     982:	51 f1       	breq	.+84     	; 0x9d8 <UserVerify_Tick+0x362>
     984:	cc d0       	rcall	.+408    	; 0xb1e <nokia_lcd_clear>
     986:	61 e0       	ldi	r22, 0x01	; 1
     988:	81 ec       	ldi	r24, 0xC1	; 193
     98a:	91 e0       	ldi	r25, 0x01	; 1
				nokia_lcd_set_cursor(0,10);
     98c:	ae d1       	rcall	.+860    	; 0xcea <nokia_lcd_write_string>
     98e:	6a e0       	ldi	r22, 0x0A	; 10
     990:	80 e0       	ldi	r24, 0x00	; 0
     992:	bd d1       	rcall	.+890    	; 0xd0e <nokia_lcd_set_cursor>
				nokia_lcd_write_string("Password: ",1);
     994:	61 e0       	ldi	r22, 0x01	; 1
     996:	87 ec       	ldi	r24, 0xC7	; 199
     998:	91 e0       	ldi	r25, 0x01	; 1
     99a:	a7 d1       	rcall	.+846    	; 0xcea <nokia_lcd_write_string>
     99c:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <uv_password_fails>
				nokia_lcd_write_char(uv_password_fails + '0',1);
     9a0:	61 e0       	ldi	r22, 0x01	; 1
     9a2:	80 5d       	subi	r24, 0xD0	; 208
     9a4:	f8 d0       	rcall	.+496    	; 0xb96 <nokia_lcd_write_char>
     9a6:	64 e1       	ldi	r22, 0x14	; 20
     9a8:	80 e0       	ldi	r24, 0x00	; 0
				nokia_lcd_set_cursor(0,20);
     9aa:	b1 d1       	rcall	.+866    	; 0xd0e <nokia_lcd_set_cursor>
     9ac:	61 e0       	ldi	r22, 0x01	; 1
     9ae:	82 ed       	ldi	r24, 0xD2	; 210
     9b0:	91 e0       	ldi	r25, 0x01	; 1
				nokia_lcd_write_string("*",1);
     9b2:	9b d1       	rcall	.+822    	; 0xcea <nokia_lcd_write_string>
     9b4:	b1 d1       	rcall	.+866    	; 0xd18 <nokia_lcd_render>
     9b6:	10 92 e8 07 	sts	0x07E8, r1	; 0x8007e8 <password_size>
     9ba:	e9 ee       	ldi	r30, 0xE9	; 233
				nokia_lcd_render();
     9bc:	f7 e0       	ldi	r31, 0x07	; 7
     9be:	81 ef       	ldi	r24, 0xF1	; 241
				password_size = 0;
     9c0:	97 e0       	ldi	r25, 0x07	; 7
     9c2:	11 92       	st	Z+, r1
     9c4:	8e 17       	cp	r24, r30
     9c6:	9f 07       	cpc	r25, r31
     9c8:	e1 f7       	brne	.-8      	; 0x9c2 <UserVerify_Tick+0x34c>
     9ca:	8a e2       	ldi	r24, 0x2A	; 42
				for(unsigned char i = 0; i < 8; ++i){
					temporary_password[i] = '\0';
     9cc:	80 93 e9 07 	sts	0x07E9, r24	; 0x8007e9 <temporary_password>
				nokia_lcd_write_char(uv_password_fails + '0',1);
				nokia_lcd_set_cursor(0,20);
				nokia_lcd_write_string("*",1);
				nokia_lcd_render();
				password_size = 0;
				for(unsigned char i = 0; i < 8; ++i){
     9d0:	82 e0       	ldi	r24, 0x02	; 2
     9d2:	80 93 46 0a 	sts	0x0A46, r24	; 0x800a46 <user_verify_state>
					temporary_password[i] = '\0';
				}
				temporary_password[0] = '*';
     9d6:	10 c0       	rjmp	.+32     	; 0x9f8 <UserVerify_Tick+0x382>
     9d8:	10 92 e4 07 	sts	0x07E4, r1	; 0x8007e4 <uv_password_fails>
				user_verify_state = uv_password;
     9dc:	10 92 e8 07 	sts	0x07E8, r1	; 0x8007e8 <password_size>
     9e0:	e9 ee       	ldi	r30, 0xE9	; 233
			}
			
			else if(!user_verify_flag){
				uv_password_fails = 0;
     9e2:	f7 e0       	ldi	r31, 0x07	; 7
     9e4:	81 ef       	ldi	r24, 0xF1	; 241
				password_size = 0;
     9e6:	97 e0       	ldi	r25, 0x07	; 7
     9e8:	11 92       	st	Z+, r1
     9ea:	e8 17       	cp	r30, r24
     9ec:	f9 07       	cpc	r31, r25
     9ee:	e1 f7       	brne	.-8      	; 0x9e8 <UserVerify_Tick+0x372>
     9f0:	10 92 e9 07 	sts	0x07E9, r1	; 0x8007e9 <temporary_password>
				for(unsigned char i = 0; i < 8; ++i){
     9f4:	10 92 46 0a 	sts	0x0A46, r1	; 0x800a46 <user_verify_state>
     9f8:	df 91       	pop	r29
					temporary_password[i] = '\0';
				}
				temporary_password[0] = '\0';
     9fa:	cf 91       	pop	r28
     9fc:	1f 91       	pop	r17
				user_verify_state = uv_init;
     9fe:	0f 91       	pop	r16
     a00:	ff 90       	pop	r15
			break;
		
		default:
			break;
	}
}
     a02:	08 95       	ret

00000a04 <UserVerifyTask>:
     a04:	10 92 46 0a 	sts	0x0A46, r1	; 0x800a46 <user_verify_state>
     a08:	36 de       	rcall	.-916    	; 0x676 <UserVerify_Tick>
     a0a:	84 e6       	ldi	r24, 0x64	; 100
     a0c:	90 e0       	ldi	r25, 0x00	; 0
{
	UserVerify_Init();
	for(;;) 
	{ 	
		UserVerify_Tick();
		vTaskDelay(100); 
     a0e:	91 d5       	rcall	.+2850   	; 0x1532 <vTaskDelay>
     a10:	fb cf       	rjmp	.-10     	; 0xa08 <UserVerifyTask+0x4>

00000a12 <UserVerifyPulse>:
	} 
}

void UserVerifyPulse(unsigned portBASE_TYPE Priority)
{
     a12:	af 92       	push	r10
     a14:	bf 92       	push	r11
     a16:	cf 92       	push	r12
     a18:	df 92       	push	r13
     a1a:	ef 92       	push	r14
     a1c:	ff 92       	push	r15
     a1e:	0f 93       	push	r16
	xTaskCreate(UserVerifyTask, (signed portCHAR *)"UserVerifyTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     a20:	a1 2c       	mov	r10, r1
     a22:	b1 2c       	mov	r11, r1
     a24:	c1 2c       	mov	r12, r1
     a26:	d1 2c       	mov	r13, r1
     a28:	e1 2c       	mov	r14, r1
     a2a:	f1 2c       	mov	r15, r1
     a2c:	08 2f       	mov	r16, r24
     a2e:	20 e0       	ldi	r18, 0x00	; 0
     a30:	30 e0       	ldi	r19, 0x00	; 0
     a32:	45 e5       	ldi	r20, 0x55	; 85
     a34:	50 e0       	ldi	r21, 0x00	; 0
     a36:	61 ef       	ldi	r22, 0xF1	; 241
     a38:	71 e0       	ldi	r23, 0x01	; 1
     a3a:	82 e0       	ldi	r24, 0x02	; 2
     a3c:	95 e0       	ldi	r25, 0x05	; 5
     a3e:	11 d3       	rcall	.+1570   	; 0x1062 <xTaskGenericCreate>
}	
     a40:	0f 91       	pop	r16
     a42:	ff 90       	pop	r15
     a44:	ef 90       	pop	r14
     a46:	df 90       	pop	r13
     a48:	cf 90       	pop	r12
     a4a:	bf 90       	pop	r11
     a4c:	af 90       	pop	r10
     a4e:	08 95       	ret

00000a50 <main>:
 
int main(void) 
{ 
	DDRC = 0x0F;	//Set PC7...PC3 to input, PC2...PC0 to output [0000 1111]
     a50:	8f e0       	ldi	r24, 0x0F	; 15
     a52:	87 b9       	out	0x07, r24	; 7
	PORTC = 0xF0;	//Init port C to 1s							[1111 0000]
     a54:	80 ef       	ldi	r24, 0xF0	; 240
     a56:	88 b9       	out	0x08, r24	; 8
	DDRD = 0xFF;	//Set Port D to output
     a58:	8f ef       	ldi	r24, 0xFF	; 255
     a5a:	8a b9       	out	0x0a, r24	; 10
	PORTD = 0x00;	//Init Port D to 0s
     a5c:	1b b8       	out	0x0b, r1	; 11
	DDRB = 0xFF;	//Controls the locks
     a5e:	84 b9       	out	0x04, r24	; 4
	PORTB = 0x00;
     a60:	15 b8       	out	0x05, r1	; 5
	nokia_lcd_init();
     a62:	27 d0       	rcall	.+78     	; 0xab2 <nokia_lcd_init>
	//Start Tasks  
	UserVerifyPulse(1);
     a64:	81 e0       	ldi	r24, 0x01	; 1
    //RunSchedular 
	vTaskStartScheduler(); 
     a66:	d5 df       	rcall	.-86     	; 0xa12 <UserVerifyPulse>
     a68:	ef d3       	rcall	.+2014   	; 0x1248 <vTaskStartScheduler>
 
	return 0; 
     a6a:	80 e0       	ldi	r24, 0x00	; 0
     a6c:	90 e0       	ldi	r25, 0x00	; 0
     a6e:	08 95       	ret

00000a70 <write>:
		nokia_lcd.screen[i] = 0x00;
}

void nokia_lcd_power(uint8_t on)
{
	write_cmd(on ? 0x20 : 0x24);
     a70:	59 98       	cbi	0x0b, 1	; 11
     a72:	66 23       	and	r22, r22
     a74:	11 f0       	breq	.+4      	; 0xa7a <write+0xa>
     a76:	5b 9a       	sbi	0x0b, 3	; 11
     a78:	15 c0       	rjmp	.+42     	; 0xaa4 <write+0x34>
     a7a:	5b 98       	cbi	0x0b, 3	; 11
     a7c:	13 c0       	rjmp	.+38     	; 0xaa4 <write+0x34>
     a7e:	ac 01       	movw	r20, r24
     a80:	02 2e       	mov	r0, r18
     a82:	02 c0       	rjmp	.+4      	; 0xa88 <write+0x18>
     a84:	55 95       	asr	r21
     a86:	47 95       	ror	r20
     a88:	0a 94       	dec	r0
     a8a:	e2 f7       	brpl	.-8      	; 0xa84 <write+0x14>
     a8c:	40 ff       	sbrs	r20, 0
     a8e:	02 c0       	rjmp	.+4      	; 0xa94 <write+0x24>
     a90:	5c 9a       	sbi	0x0b, 4	; 11
     a92:	01 c0       	rjmp	.+2      	; 0xa96 <write+0x26>
     a94:	5c 98       	cbi	0x0b, 4	; 11
     a96:	5d 9a       	sbi	0x0b, 5	; 11
     a98:	5d 98       	cbi	0x0b, 5	; 11
     a9a:	21 50       	subi	r18, 0x01	; 1
     a9c:	31 09       	sbc	r19, r1
     a9e:	78 f7       	brcc	.-34     	; 0xa7e <write+0xe>
     aa0:	59 9a       	sbi	0x0b, 1	; 11
     aa2:	08 95       	ret
     aa4:	27 e0       	ldi	r18, 0x07	; 7
     aa6:	30 e0       	ldi	r19, 0x00	; 0
     aa8:	90 e0       	ldi	r25, 0x00	; 0
     aaa:	e9 cf       	rjmp	.-46     	; 0xa7e <write+0xe>

00000aac <write_cmd>:
     aac:	60 e0       	ldi	r22, 0x00	; 0
     aae:	e0 cf       	rjmp	.-64     	; 0xa70 <write>
     ab0:	08 95       	ret

00000ab2 <nokia_lcd_init>:
     ab2:	cf 93       	push	r28
     ab4:	df 93       	push	r29
     ab6:	51 9a       	sbi	0x0a, 1	; 10
     ab8:	52 9a       	sbi	0x0a, 2	; 10
     aba:	53 9a       	sbi	0x0a, 3	; 10
     abc:	54 9a       	sbi	0x0a, 4	; 10
     abe:	55 9a       	sbi	0x0a, 5	; 10
     ac0:	5a 9a       	sbi	0x0b, 2	; 11
     ac2:	59 9a       	sbi	0x0b, 1	; 11
     ac4:	83 ec       	ldi	r24, 0xC3	; 195
     ac6:	99 e0       	ldi	r25, 0x09	; 9
     ac8:	01 97       	sbiw	r24, 0x01	; 1
     aca:	f1 f7       	brne	.-4      	; 0xac8 <nokia_lcd_init+0x16>
     acc:	00 c0       	rjmp	.+0      	; 0xace <nokia_lcd_init+0x1c>
     ace:	00 00       	nop
     ad0:	5a 98       	cbi	0x0b, 2	; 11
     ad2:	8b e5       	ldi	r24, 0x5B	; 91
     ad4:	94 e4       	ldi	r25, 0x44	; 68
     ad6:	01 97       	sbiw	r24, 0x01	; 1
     ad8:	f1 f7       	brne	.-4      	; 0xad6 <nokia_lcd_init+0x24>
     ada:	00 c0       	rjmp	.+0      	; 0xadc <nokia_lcd_init+0x2a>
     adc:	00 00       	nop
     ade:	5a 9a       	sbi	0x0b, 2	; 11
     ae0:	59 98       	cbi	0x0b, 1	; 11
     ae2:	81 e2       	ldi	r24, 0x21	; 33
     ae4:	e3 df       	rcall	.-58     	; 0xaac <write_cmd>
     ae6:	83 e1       	ldi	r24, 0x13	; 19
     ae8:	e1 df       	rcall	.-62     	; 0xaac <write_cmd>
     aea:	86 e0       	ldi	r24, 0x06	; 6
     aec:	df df       	rcall	.-66     	; 0xaac <write_cmd>
     aee:	82 ec       	ldi	r24, 0xC2	; 194
     af0:	dd df       	rcall	.-70     	; 0xaac <write_cmd>
     af2:	80 e2       	ldi	r24, 0x20	; 32
     af4:	db df       	rcall	.-74     	; 0xaac <write_cmd>
     af6:	89 e0       	ldi	r24, 0x09	; 9
     af8:	d9 df       	rcall	.-78     	; 0xaac <write_cmd>
     afa:	80 e8       	ldi	r24, 0x80	; 128
     afc:	d7 df       	rcall	.-82     	; 0xaac <write_cmd>
     afe:	80 e4       	ldi	r24, 0x40	; 64
     b00:	d5 df       	rcall	.-86     	; 0xaac <write_cmd>
     b02:	c8 ef       	ldi	r28, 0xF8	; 248
     b04:	d1 e0       	ldi	r29, 0x01	; 1
     b06:	61 e0       	ldi	r22, 0x01	; 1
     b08:	80 e0       	ldi	r24, 0x00	; 0
     b0a:	b2 df       	rcall	.-156    	; 0xa70 <write>
     b0c:	21 97       	sbiw	r28, 0x01	; 1
     b0e:	d9 f7       	brne	.-10     	; 0xb06 <nokia_lcd_init+0x54>
     b10:	88 e0       	ldi	r24, 0x08	; 8
     b12:	cc df       	rcall	.-104    	; 0xaac <write_cmd>
     b14:	8c e0       	ldi	r24, 0x0C	; 12
     b16:	ca df       	rcall	.-108    	; 0xaac <write_cmd>
     b18:	df 91       	pop	r29
     b1a:	cf 91       	pop	r28
     b1c:	08 95       	ret

00000b1e <nokia_lcd_clear>:
     b1e:	80 e8       	ldi	r24, 0x80	; 128
     b20:	c5 df       	rcall	.-118    	; 0xaac <write_cmd>
     b22:	80 e4       	ldi	r24, 0x40	; 64
     b24:	c3 df       	rcall	.-122    	; 0xaac <write_cmd>
     b26:	10 92 ea 09 	sts	0x09EA, r1	; 0x8009ea <nokia_lcd+0x1f8>
     b2a:	10 92 eb 09 	sts	0x09EB, r1	; 0x8009eb <nokia_lcd+0x1f9>
     b2e:	e2 ef       	ldi	r30, 0xF2	; 242
     b30:	f7 e0       	ldi	r31, 0x07	; 7
     b32:	8a ee       	ldi	r24, 0xEA	; 234
     b34:	99 e0       	ldi	r25, 0x09	; 9
     b36:	11 92       	st	Z+, r1
     b38:	e8 17       	cp	r30, r24
     b3a:	f9 07       	cpc	r31, r25
     b3c:	e1 f7       	brne	.-8      	; 0xb36 <nokia_lcd_clear+0x18>
     b3e:	08 95       	ret

00000b40 <nokia_lcd_set_pixel>:
}

void nokia_lcd_set_pixel(uint8_t x, uint8_t y, uint8_t value)
{
	uint8_t *byte = &nokia_lcd.screen[y/8*84+x];
     b40:	26 2f       	mov	r18, r22
     b42:	26 95       	lsr	r18
     b44:	26 95       	lsr	r18
     b46:	26 95       	lsr	r18
     b48:	90 e0       	ldi	r25, 0x00	; 0
     b4a:	34 e5       	ldi	r19, 0x54	; 84
     b4c:	23 9f       	mul	r18, r19
     b4e:	80 0d       	add	r24, r0
     b50:	91 1d       	adc	r25, r1
     b52:	11 24       	eor	r1, r1
	if (value)
     b54:	44 23       	and	r20, r20
     b56:	79 f0       	breq	.+30     	; 0xb76 <nokia_lcd_set_pixel+0x36>
		*byte |= (1 << (y % 8));
     b58:	fc 01       	movw	r30, r24
     b5a:	ee 50       	subi	r30, 0x0E	; 14
     b5c:	f8 4f       	sbci	r31, 0xF8	; 248
     b5e:	67 70       	andi	r22, 0x07	; 7
     b60:	81 e0       	ldi	r24, 0x01	; 1
     b62:	90 e0       	ldi	r25, 0x00	; 0
     b64:	02 c0       	rjmp	.+4      	; 0xb6a <nokia_lcd_set_pixel+0x2a>
     b66:	88 0f       	add	r24, r24
     b68:	99 1f       	adc	r25, r25
     b6a:	6a 95       	dec	r22
     b6c:	e2 f7       	brpl	.-8      	; 0xb66 <nokia_lcd_set_pixel+0x26>
     b6e:	90 81       	ld	r25, Z
     b70:	89 2b       	or	r24, r25
     b72:	80 83       	st	Z, r24
     b74:	08 95       	ret
	else
		*byte &= ~(1 << (y %8 ));
     b76:	fc 01       	movw	r30, r24
     b78:	ee 50       	subi	r30, 0x0E	; 14
     b7a:	f8 4f       	sbci	r31, 0xF8	; 248
     b7c:	67 70       	andi	r22, 0x07	; 7
     b7e:	81 e0       	ldi	r24, 0x01	; 1
     b80:	90 e0       	ldi	r25, 0x00	; 0
     b82:	02 c0       	rjmp	.+4      	; 0xb88 <nokia_lcd_set_pixel+0x48>
     b84:	88 0f       	add	r24, r24
     b86:	99 1f       	adc	r25, r25
     b88:	6a 95       	dec	r22
     b8a:	e2 f7       	brpl	.-8      	; 0xb84 <nokia_lcd_set_pixel+0x44>
     b8c:	80 95       	com	r24
     b8e:	90 81       	ld	r25, Z
     b90:	89 23       	and	r24, r25
     b92:	80 83       	st	Z, r24
     b94:	08 95       	ret

00000b96 <nokia_lcd_write_char>:
}

void nokia_lcd_write_char(char code, uint8_t scale)
{
     b96:	5f 92       	push	r5
     b98:	6f 92       	push	r6
     b9a:	7f 92       	push	r7
     b9c:	8f 92       	push	r8
     b9e:	9f 92       	push	r9
     ba0:	af 92       	push	r10
     ba2:	bf 92       	push	r11
     ba4:	cf 92       	push	r12
     ba6:	df 92       	push	r13
     ba8:	ef 92       	push	r14
     baa:	ff 92       	push	r15
     bac:	0f 93       	push	r16
     bae:	1f 93       	push	r17
     bb0:	cf 93       	push	r28
     bb2:	df 93       	push	r29
     bb4:	56 2e       	mov	r5, r22
	register uint8_t x, y;

	for (x = 0; x < 5*scale; x++)
     bb6:	26 2f       	mov	r18, r22
     bb8:	30 e0       	ldi	r19, 0x00	; 0
     bba:	49 01       	movw	r8, r18
     bbc:	88 0c       	add	r8, r8
     bbe:	99 1c       	adc	r9, r9
     bc0:	88 0c       	add	r8, r8
     bc2:	99 1c       	adc	r9, r9
     bc4:	82 0e       	add	r8, r18
     bc6:	93 1e       	adc	r9, r19
     bc8:	18 14       	cp	r1, r8
     bca:	19 04       	cpc	r1, r9
     bcc:	0c f0       	brlt	.+2      	; 0xbd0 <nokia_lcd_write_char+0x3a>
     bce:	59 c0       	rjmp	.+178    	; 0xc82 <nokia_lcd_write_char+0xec>
		for (y = 0; y < 7*scale; y++)
     bd0:	89 01       	movw	r16, r18
     bd2:	00 0f       	add	r16, r16
     bd4:	11 1f       	adc	r17, r17
     bd6:	00 0f       	add	r16, r16
     bd8:	11 1f       	adc	r17, r17
     bda:	00 0f       	add	r16, r16
     bdc:	11 1f       	adc	r17, r17
     bde:	02 1b       	sub	r16, r18
     be0:	13 0b       	sbc	r17, r19
     be2:	61 2c       	mov	r6, r1
			if (pgm_read_byte(&CHARSET[code-32][x/scale]) & (1 << y/scale))
     be4:	a8 2e       	mov	r10, r24
     be6:	b1 2c       	mov	r11, r1
     be8:	c5 01       	movw	r24, r10
     bea:	80 97       	sbiw	r24, 0x20	; 32
     bec:	5c 01       	movw	r10, r24
     bee:	aa 0c       	add	r10, r10
     bf0:	bb 1c       	adc	r11, r11
     bf2:	aa 0c       	add	r10, r10
     bf4:	bb 1c       	adc	r11, r11
     bf6:	a8 0e       	add	r10, r24
     bf8:	b9 1e       	adc	r11, r25
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 1);
			else
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 0);
     bfa:	0f 2e       	mov	r0, r31
     bfc:	fb ee       	ldi	r31, 0xEB	; 235
     bfe:	cf 2e       	mov	r12, r31
     c00:	f9 e0       	ldi	r31, 0x09	; 9
     c02:	df 2e       	mov	r13, r31
     c04:	f0 2d       	mov	r31, r0
     c06:	0f 2e       	mov	r0, r31
     c08:	fa ee       	ldi	r31, 0xEA	; 234
     c0a:	ef 2e       	mov	r14, r31
     c0c:	f9 e0       	ldi	r31, 0x09	; 9
     c0e:	ff 2e       	mov	r15, r31
     c10:	f0 2d       	mov	r31, r0
     c12:	2a c0       	rjmp	.+84     	; 0xc68 <nokia_lcd_write_char+0xd2>
{
	register uint8_t x, y;

	for (x = 0; x < 5*scale; x++)
		for (y = 0; y < 7*scale; y++)
			if (pgm_read_byte(&CHARSET[code-32][x/scale]) & (1 << y/scale))
     c14:	fe 01       	movw	r30, r28
     c16:	24 91       	lpm	r18, Z
     c18:	30 e0       	ldi	r19, 0x00	; 0
     c1a:	87 2d       	mov	r24, r7
     c1c:	65 2d       	mov	r22, r5
     c1e:	4a d5       	rcall	.+2708   	; 0x16b4 <__udivmodqi4>
     c20:	02 c0       	rjmp	.+4      	; 0xc26 <nokia_lcd_write_char+0x90>
     c22:	35 95       	asr	r19
     c24:	27 95       	ror	r18
     c26:	8a 95       	dec	r24
     c28:	e2 f7       	brpl	.-8      	; 0xc22 <nokia_lcd_write_char+0x8c>
     c2a:	20 ff       	sbrs	r18, 0
     c2c:	09 c0       	rjmp	.+18     	; 0xc40 <nokia_lcd_write_char+0xaa>
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 1);
     c2e:	f6 01       	movw	r30, r12
     c30:	60 81       	ld	r22, Z
     c32:	67 0d       	add	r22, r7
     c34:	f7 01       	movw	r30, r14
     c36:	80 81       	ld	r24, Z
     c38:	41 e0       	ldi	r20, 0x01	; 1
     c3a:	86 0d       	add	r24, r6
     c3c:	81 df       	rcall	.-254    	; 0xb40 <nokia_lcd_set_pixel>
     c3e:	08 c0       	rjmp	.+16     	; 0xc50 <nokia_lcd_write_char+0xba>
			else
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 0);
     c40:	f6 01       	movw	r30, r12
     c42:	60 81       	ld	r22, Z
     c44:	67 0d       	add	r22, r7
     c46:	f7 01       	movw	r30, r14
     c48:	80 81       	ld	r24, Z
     c4a:	40 e0       	ldi	r20, 0x00	; 0
     c4c:	86 0d       	add	r24, r6
     c4e:	78 df       	rcall	.-272    	; 0xb40 <nokia_lcd_set_pixel>
void nokia_lcd_write_char(char code, uint8_t scale)
{
	register uint8_t x, y;

	for (x = 0; x < 5*scale; x++)
		for (y = 0; y < 7*scale; y++)
     c50:	73 94       	inc	r7
     c52:	87 2d       	mov	r24, r7
     c54:	90 e0       	ldi	r25, 0x00	; 0
     c56:	80 17       	cp	r24, r16
     c58:	91 07       	cpc	r25, r17
     c5a:	e4 f2       	brlt	.-72     	; 0xc14 <nokia_lcd_write_char+0x7e>

void nokia_lcd_write_char(char code, uint8_t scale)
{
	register uint8_t x, y;

	for (x = 0; x < 5*scale; x++)
     c5c:	63 94       	inc	r6
     c5e:	86 2d       	mov	r24, r6
     c60:	90 e0       	ldi	r25, 0x00	; 0
     c62:	88 15       	cp	r24, r8
     c64:	99 05       	cpc	r25, r9
     c66:	6c f4       	brge	.+26     	; 0xc82 <nokia_lcd_write_char+0xec>
		for (y = 0; y < 7*scale; y++)
     c68:	10 16       	cp	r1, r16
     c6a:	11 06       	cpc	r1, r17
			if (pgm_read_byte(&CHARSET[code-32][x/scale]) & (1 << y/scale))
     c6c:	bc f7       	brge	.-18     	; 0xc5c <nokia_lcd_write_char+0xc6>
     c6e:	86 2d       	mov	r24, r6
     c70:	65 2d       	mov	r22, r5
     c72:	20 d5       	rcall	.+2624   	; 0x16b4 <__udivmodqi4>
     c74:	e5 01       	movw	r28, r10
     c76:	c8 0f       	add	r28, r24
     c78:	d1 1d       	adc	r29, r1
     c7a:	c4 57       	subi	r28, 0x74	; 116
     c7c:	df 4f       	sbci	r29, 0xFF	; 255
     c7e:	71 2c       	mov	r7, r1
     c80:	c9 cf       	rjmp	.-110    	; 0xc14 <nokia_lcd_write_char+0x7e>
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 1);
			else
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 0);

	nokia_lcd.cursor_x += 5*scale + 1;
     c82:	80 91 ea 09 	lds	r24, 0x09EA	; 0x8009ea <nokia_lcd+0x1f8>
     c86:	91 e0       	ldi	r25, 0x01	; 1
     c88:	98 0f       	add	r25, r24
     c8a:	85 2d       	mov	r24, r5
     c8c:	88 0f       	add	r24, r24
     c8e:	88 0f       	add	r24, r24
     c90:	85 0d       	add	r24, r5
     c92:	89 0f       	add	r24, r25
	if (nokia_lcd.cursor_x >= 84) {
     c94:	84 35       	cpi	r24, 0x54	; 84
     c96:	18 f4       	brcc	.+6      	; 0xc9e <nokia_lcd_write_char+0x108>
			if (pgm_read_byte(&CHARSET[code-32][x/scale]) & (1 << y/scale))
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 1);
			else
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 0);

	nokia_lcd.cursor_x += 5*scale + 1;
     c98:	80 93 ea 09 	sts	0x09EA, r24	; 0x8009ea <nokia_lcd+0x1f8>
     c9c:	0e c0       	rjmp	.+28     	; 0xcba <nokia_lcd_write_char+0x124>
	if (nokia_lcd.cursor_x >= 84) {
		nokia_lcd.cursor_x = 0;
     c9e:	10 92 ea 09 	sts	0x09EA, r1	; 0x8009ea <nokia_lcd+0x1f8>
		nokia_lcd.cursor_y += 7*scale + 1;
     ca2:	eb ee       	ldi	r30, 0xEB	; 235
     ca4:	f9 e0       	ldi	r31, 0x09	; 9
     ca6:	80 81       	ld	r24, Z
     ca8:	91 e0       	ldi	r25, 0x01	; 1
     caa:	98 0f       	add	r25, r24
     cac:	85 2d       	mov	r24, r5
     cae:	88 0f       	add	r24, r24
     cb0:	88 0f       	add	r24, r24
     cb2:	88 0f       	add	r24, r24
     cb4:	85 19       	sub	r24, r5
     cb6:	89 0f       	add	r24, r25
     cb8:	80 83       	st	Z, r24
	}
	if (nokia_lcd.cursor_y >= 48) {
     cba:	80 91 eb 09 	lds	r24, 0x09EB	; 0x8009eb <nokia_lcd+0x1f9>
     cbe:	80 33       	cpi	r24, 0x30	; 48
     cc0:	20 f0       	brcs	.+8      	; 0xcca <nokia_lcd_write_char+0x134>
		nokia_lcd.cursor_x = 0;
     cc2:	10 92 ea 09 	sts	0x09EA, r1	; 0x8009ea <nokia_lcd+0x1f8>
		nokia_lcd.cursor_y = 0;
     cc6:	10 92 eb 09 	sts	0x09EB, r1	; 0x8009eb <nokia_lcd+0x1f9>
	}
}
     cca:	df 91       	pop	r29
     ccc:	cf 91       	pop	r28
     cce:	1f 91       	pop	r17
     cd0:	0f 91       	pop	r16
     cd2:	ff 90       	pop	r15
     cd4:	ef 90       	pop	r14
     cd6:	df 90       	pop	r13
     cd8:	cf 90       	pop	r12
     cda:	bf 90       	pop	r11
     cdc:	af 90       	pop	r10
     cde:	9f 90       	pop	r9
     ce0:	8f 90       	pop	r8
     ce2:	7f 90       	pop	r7
     ce4:	6f 90       	pop	r6
     ce6:	5f 90       	pop	r5
     ce8:	08 95       	ret

00000cea <nokia_lcd_write_string>:

void nokia_lcd_write_string(const char *str, uint8_t scale)
{
     cea:	1f 93       	push	r17
     cec:	cf 93       	push	r28
     cee:	df 93       	push	r29
     cf0:	ec 01       	movw	r28, r24
	while(*str)
     cf2:	88 81       	ld	r24, Y
     cf4:	88 23       	and	r24, r24
     cf6:	39 f0       	breq	.+14     	; 0xd06 <nokia_lcd_write_string+0x1c>
     cf8:	16 2f       	mov	r17, r22
     cfa:	21 96       	adiw	r28, 0x01	; 1
		nokia_lcd_write_char(*str++, scale);
     cfc:	61 2f       	mov	r22, r17
     cfe:	4b df       	rcall	.-362    	; 0xb96 <nokia_lcd_write_char>
	}
}

void nokia_lcd_write_string(const char *str, uint8_t scale)
{
	while(*str)
     d00:	89 91       	ld	r24, Y+
     d02:	81 11       	cpse	r24, r1
     d04:	fb cf       	rjmp	.-10     	; 0xcfc <nokia_lcd_write_string+0x12>
		nokia_lcd_write_char(*str++, scale);
}
     d06:	df 91       	pop	r29
     d08:	cf 91       	pop	r28
     d0a:	1f 91       	pop	r17
     d0c:	08 95       	ret

00000d0e <nokia_lcd_set_cursor>:

void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
	nokia_lcd.cursor_x = x;
     d0e:	80 93 ea 09 	sts	0x09EA, r24	; 0x8009ea <nokia_lcd+0x1f8>
	nokia_lcd.cursor_y = y;
     d12:	60 93 eb 09 	sts	0x09EB, r22	; 0x8009eb <nokia_lcd+0x1f9>
     d16:	08 95       	ret

00000d18 <nokia_lcd_render>:
}

void nokia_lcd_render(void)
{
     d18:	0f 93       	push	r16
     d1a:	1f 93       	push	r17
     d1c:	cf 93       	push	r28
     d1e:	df 93       	push	r29
	register unsigned i;
	/* Set column and row to 0 */
	write_cmd(0x80);
     d20:	80 e8       	ldi	r24, 0x80	; 128
     d22:	c4 de       	rcall	.-632    	; 0xaac <write_cmd>
	write_cmd(0x40);
     d24:	80 e4       	ldi	r24, 0x40	; 64
     d26:	c2 de       	rcall	.-636    	; 0xaac <write_cmd>
     d28:	c2 ef       	ldi	r28, 0xF2	; 242
     d2a:	d7 e0       	ldi	r29, 0x07	; 7
     d2c:	0a ee       	ldi	r16, 0xEA	; 234
     d2e:	19 e0       	ldi	r17, 0x09	; 9
	write(cmd, 0);
}

static void write_data(uint8_t data)
{
	write(data, 1);
     d30:	61 e0       	ldi	r22, 0x01	; 1
     d32:	89 91       	ld	r24, Y+
     d34:	9d de       	rcall	.-710    	; 0xa70 <write>
	/* Set column and row to 0 */
	write_cmd(0x80);
	write_cmd(0x40);

	/* Write screen to display */
	for (i = 0; i < 504; i++)
     d36:	c0 17       	cp	r28, r16
     d38:	d1 07       	cpc	r29, r17
     d3a:	d1 f7       	brne	.-12     	; 0xd30 <nokia_lcd_render+0x18>
		write_data(nokia_lcd.screen[i]);
}
     d3c:	df 91       	pop	r29
     d3e:	cf 91       	pop	r28
     d40:	1f 91       	pop	r17
     d42:	0f 91       	pop	r16
     d44:	08 95       	ret

00000d46 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     d46:	31 e1       	ldi	r19, 0x11	; 17
     d48:	fc 01       	movw	r30, r24
     d4a:	30 83       	st	Z, r19
     d4c:	31 97       	sbiw	r30, 0x01	; 1
     d4e:	22 e2       	ldi	r18, 0x22	; 34
     d50:	20 83       	st	Z, r18
     d52:	31 97       	sbiw	r30, 0x01	; 1
     d54:	a3 e3       	ldi	r26, 0x33	; 51
     d56:	a0 83       	st	Z, r26
     d58:	31 97       	sbiw	r30, 0x01	; 1
     d5a:	60 83       	st	Z, r22
     d5c:	31 97       	sbiw	r30, 0x01	; 1
     d5e:	70 83       	st	Z, r23
     d60:	31 97       	sbiw	r30, 0x01	; 1
     d62:	10 82       	st	Z, r1
     d64:	31 97       	sbiw	r30, 0x01	; 1
     d66:	60 e8       	ldi	r22, 0x80	; 128
     d68:	60 83       	st	Z, r22
     d6a:	31 97       	sbiw	r30, 0x01	; 1
     d6c:	10 82       	st	Z, r1
     d6e:	31 97       	sbiw	r30, 0x01	; 1
     d70:	62 e0       	ldi	r22, 0x02	; 2
     d72:	60 83       	st	Z, r22
     d74:	31 97       	sbiw	r30, 0x01	; 1
     d76:	63 e0       	ldi	r22, 0x03	; 3
     d78:	60 83       	st	Z, r22
     d7a:	31 97       	sbiw	r30, 0x01	; 1
     d7c:	64 e0       	ldi	r22, 0x04	; 4
     d7e:	60 83       	st	Z, r22
     d80:	31 97       	sbiw	r30, 0x01	; 1
     d82:	65 e0       	ldi	r22, 0x05	; 5
     d84:	60 83       	st	Z, r22
     d86:	31 97       	sbiw	r30, 0x01	; 1
     d88:	66 e0       	ldi	r22, 0x06	; 6
     d8a:	60 83       	st	Z, r22
     d8c:	31 97       	sbiw	r30, 0x01	; 1
     d8e:	67 e0       	ldi	r22, 0x07	; 7
     d90:	60 83       	st	Z, r22
     d92:	31 97       	sbiw	r30, 0x01	; 1
     d94:	68 e0       	ldi	r22, 0x08	; 8
     d96:	60 83       	st	Z, r22
     d98:	31 97       	sbiw	r30, 0x01	; 1
     d9a:	69 e0       	ldi	r22, 0x09	; 9
     d9c:	60 83       	st	Z, r22
     d9e:	31 97       	sbiw	r30, 0x01	; 1
     da0:	60 e1       	ldi	r22, 0x10	; 16
     da2:	60 83       	st	Z, r22
     da4:	31 97       	sbiw	r30, 0x01	; 1
     da6:	30 83       	st	Z, r19
     da8:	31 97       	sbiw	r30, 0x01	; 1
     daa:	32 e1       	ldi	r19, 0x12	; 18
     dac:	30 83       	st	Z, r19
     dae:	31 97       	sbiw	r30, 0x01	; 1
     db0:	33 e1       	ldi	r19, 0x13	; 19
     db2:	30 83       	st	Z, r19
     db4:	31 97       	sbiw	r30, 0x01	; 1
     db6:	34 e1       	ldi	r19, 0x14	; 20
     db8:	30 83       	st	Z, r19
     dba:	31 97       	sbiw	r30, 0x01	; 1
     dbc:	35 e1       	ldi	r19, 0x15	; 21
     dbe:	30 83       	st	Z, r19
     dc0:	31 97       	sbiw	r30, 0x01	; 1
     dc2:	36 e1       	ldi	r19, 0x16	; 22
     dc4:	30 83       	st	Z, r19
     dc6:	31 97       	sbiw	r30, 0x01	; 1
     dc8:	37 e1       	ldi	r19, 0x17	; 23
     dca:	30 83       	st	Z, r19
     dcc:	31 97       	sbiw	r30, 0x01	; 1
     dce:	38 e1       	ldi	r19, 0x18	; 24
     dd0:	30 83       	st	Z, r19
     dd2:	31 97       	sbiw	r30, 0x01	; 1
     dd4:	39 e1       	ldi	r19, 0x19	; 25
     dd6:	30 83       	st	Z, r19
     dd8:	31 97       	sbiw	r30, 0x01	; 1
     dda:	30 e2       	ldi	r19, 0x20	; 32
     ddc:	30 83       	st	Z, r19
     dde:	31 97       	sbiw	r30, 0x01	; 1
     de0:	31 e2       	ldi	r19, 0x21	; 33
     de2:	30 83       	st	Z, r19
     de4:	31 97       	sbiw	r30, 0x01	; 1
     de6:	20 83       	st	Z, r18
     de8:	31 97       	sbiw	r30, 0x01	; 1
     dea:	23 e2       	ldi	r18, 0x23	; 35
     dec:	20 83       	st	Z, r18
     dee:	31 97       	sbiw	r30, 0x01	; 1
     df0:	40 83       	st	Z, r20
     df2:	31 97       	sbiw	r30, 0x01	; 1
     df4:	50 83       	st	Z, r21
     df6:	31 97       	sbiw	r30, 0x01	; 1
     df8:	26 e2       	ldi	r18, 0x26	; 38
     dfa:	20 83       	st	Z, r18
     dfc:	31 97       	sbiw	r30, 0x01	; 1
     dfe:	27 e2       	ldi	r18, 0x27	; 39
     e00:	20 83       	st	Z, r18
     e02:	31 97       	sbiw	r30, 0x01	; 1
     e04:	28 e2       	ldi	r18, 0x28	; 40
     e06:	20 83       	st	Z, r18
     e08:	31 97       	sbiw	r30, 0x01	; 1
     e0a:	29 e2       	ldi	r18, 0x29	; 41
     e0c:	20 83       	st	Z, r18
     e0e:	31 97       	sbiw	r30, 0x01	; 1
     e10:	20 e3       	ldi	r18, 0x30	; 48
     e12:	20 83       	st	Z, r18
     e14:	31 97       	sbiw	r30, 0x01	; 1
     e16:	21 e3       	ldi	r18, 0x31	; 49
     e18:	20 83       	st	Z, r18
     e1a:	86 97       	sbiw	r24, 0x26	; 38
     e1c:	08 95       	ret

00000e1e <xPortStartScheduler>:
     e1e:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     e22:	8c e7       	ldi	r24, 0x7C	; 124
     e24:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     e28:	8b e0       	ldi	r24, 0x0B	; 11
     e2a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     e2e:	ef e6       	ldi	r30, 0x6F	; 111
     e30:	f0 e0       	ldi	r31, 0x00	; 0
     e32:	80 81       	ld	r24, Z
     e34:	82 60       	ori	r24, 0x02	; 2
     e36:	80 83       	st	Z, r24
     e38:	a0 91 44 0a 	lds	r26, 0x0A44	; 0x800a44 <pxCurrentTCB>
     e3c:	b0 91 45 0a 	lds	r27, 0x0A45	; 0x800a45 <pxCurrentTCB+0x1>
     e40:	cd 91       	ld	r28, X+
     e42:	cd bf       	out	0x3d, r28	; 61
     e44:	dd 91       	ld	r29, X+
     e46:	de bf       	out	0x3e, r29	; 62
     e48:	ff 91       	pop	r31
     e4a:	ef 91       	pop	r30
     e4c:	df 91       	pop	r29
     e4e:	cf 91       	pop	r28
     e50:	bf 91       	pop	r27
     e52:	af 91       	pop	r26
     e54:	9f 91       	pop	r25
     e56:	8f 91       	pop	r24
     e58:	7f 91       	pop	r23
     e5a:	6f 91       	pop	r22
     e5c:	5f 91       	pop	r21
     e5e:	4f 91       	pop	r20
     e60:	3f 91       	pop	r19
     e62:	2f 91       	pop	r18
     e64:	1f 91       	pop	r17
     e66:	0f 91       	pop	r16
     e68:	ff 90       	pop	r15
     e6a:	ef 90       	pop	r14
     e6c:	df 90       	pop	r13
     e6e:	cf 90       	pop	r12
     e70:	bf 90       	pop	r11
     e72:	af 90       	pop	r10
     e74:	9f 90       	pop	r9
     e76:	8f 90       	pop	r8
     e78:	7f 90       	pop	r7
     e7a:	6f 90       	pop	r6
     e7c:	5f 90       	pop	r5
     e7e:	4f 90       	pop	r4
     e80:	3f 90       	pop	r3
     e82:	2f 90       	pop	r2
     e84:	1f 90       	pop	r1
     e86:	0f 90       	pop	r0
     e88:	0f be       	out	0x3f, r0	; 63
     e8a:	0f 90       	pop	r0
     e8c:	08 95       	ret
     e8e:	81 e0       	ldi	r24, 0x01	; 1
     e90:	08 95       	ret

00000e92 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     e92:	0f 92       	push	r0
     e94:	0f b6       	in	r0, 0x3f	; 63
     e96:	f8 94       	cli
     e98:	0f 92       	push	r0
     e9a:	1f 92       	push	r1
     e9c:	11 24       	eor	r1, r1
     e9e:	2f 92       	push	r2
     ea0:	3f 92       	push	r3
     ea2:	4f 92       	push	r4
     ea4:	5f 92       	push	r5
     ea6:	6f 92       	push	r6
     ea8:	7f 92       	push	r7
     eaa:	8f 92       	push	r8
     eac:	9f 92       	push	r9
     eae:	af 92       	push	r10
     eb0:	bf 92       	push	r11
     eb2:	cf 92       	push	r12
     eb4:	df 92       	push	r13
     eb6:	ef 92       	push	r14
     eb8:	ff 92       	push	r15
     eba:	0f 93       	push	r16
     ebc:	1f 93       	push	r17
     ebe:	2f 93       	push	r18
     ec0:	3f 93       	push	r19
     ec2:	4f 93       	push	r20
     ec4:	5f 93       	push	r21
     ec6:	6f 93       	push	r22
     ec8:	7f 93       	push	r23
     eca:	8f 93       	push	r24
     ecc:	9f 93       	push	r25
     ece:	af 93       	push	r26
     ed0:	bf 93       	push	r27
     ed2:	cf 93       	push	r28
     ed4:	df 93       	push	r29
     ed6:	ef 93       	push	r30
     ed8:	ff 93       	push	r31
     eda:	a0 91 44 0a 	lds	r26, 0x0A44	; 0x800a44 <pxCurrentTCB>
     ede:	b0 91 45 0a 	lds	r27, 0x0A45	; 0x800a45 <pxCurrentTCB+0x1>
     ee2:	0d b6       	in	r0, 0x3d	; 61
     ee4:	0d 92       	st	X+, r0
     ee6:	0e b6       	in	r0, 0x3e	; 62
     ee8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     eea:	78 d3       	rcall	.+1776   	; 0x15dc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     eec:	a0 91 44 0a 	lds	r26, 0x0A44	; 0x800a44 <pxCurrentTCB>
     ef0:	b0 91 45 0a 	lds	r27, 0x0A45	; 0x800a45 <pxCurrentTCB+0x1>
     ef4:	cd 91       	ld	r28, X+
     ef6:	cd bf       	out	0x3d, r28	; 61
     ef8:	dd 91       	ld	r29, X+
     efa:	de bf       	out	0x3e, r29	; 62
     efc:	ff 91       	pop	r31
     efe:	ef 91       	pop	r30
     f00:	df 91       	pop	r29
     f02:	cf 91       	pop	r28
     f04:	bf 91       	pop	r27
     f06:	af 91       	pop	r26
     f08:	9f 91       	pop	r25
     f0a:	8f 91       	pop	r24
     f0c:	7f 91       	pop	r23
     f0e:	6f 91       	pop	r22
     f10:	5f 91       	pop	r21
     f12:	4f 91       	pop	r20
     f14:	3f 91       	pop	r19
     f16:	2f 91       	pop	r18
     f18:	1f 91       	pop	r17
     f1a:	0f 91       	pop	r16
     f1c:	ff 90       	pop	r15
     f1e:	ef 90       	pop	r14
     f20:	df 90       	pop	r13
     f22:	cf 90       	pop	r12
     f24:	bf 90       	pop	r11
     f26:	af 90       	pop	r10
     f28:	9f 90       	pop	r9
     f2a:	8f 90       	pop	r8
     f2c:	7f 90       	pop	r7
     f2e:	6f 90       	pop	r6
     f30:	5f 90       	pop	r5
     f32:	4f 90       	pop	r4
     f34:	3f 90       	pop	r3
     f36:	2f 90       	pop	r2
     f38:	1f 90       	pop	r1
     f3a:	0f 90       	pop	r0
     f3c:	0f be       	out	0x3f, r0	; 63
     f3e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f40:	08 95       	ret

00000f42 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     f42:	0f 92       	push	r0
     f44:	0f b6       	in	r0, 0x3f	; 63
     f46:	f8 94       	cli
     f48:	0f 92       	push	r0
     f4a:	1f 92       	push	r1
     f4c:	11 24       	eor	r1, r1
     f4e:	2f 92       	push	r2
     f50:	3f 92       	push	r3
     f52:	4f 92       	push	r4
     f54:	5f 92       	push	r5
     f56:	6f 92       	push	r6
     f58:	7f 92       	push	r7
     f5a:	8f 92       	push	r8
     f5c:	9f 92       	push	r9
     f5e:	af 92       	push	r10
     f60:	bf 92       	push	r11
     f62:	cf 92       	push	r12
     f64:	df 92       	push	r13
     f66:	ef 92       	push	r14
     f68:	ff 92       	push	r15
     f6a:	0f 93       	push	r16
     f6c:	1f 93       	push	r17
     f6e:	2f 93       	push	r18
     f70:	3f 93       	push	r19
     f72:	4f 93       	push	r20
     f74:	5f 93       	push	r21
     f76:	6f 93       	push	r22
     f78:	7f 93       	push	r23
     f7a:	8f 93       	push	r24
     f7c:	9f 93       	push	r25
     f7e:	af 93       	push	r26
     f80:	bf 93       	push	r27
     f82:	cf 93       	push	r28
     f84:	df 93       	push	r29
     f86:	ef 93       	push	r30
     f88:	ff 93       	push	r31
     f8a:	a0 91 44 0a 	lds	r26, 0x0A44	; 0x800a44 <pxCurrentTCB>
     f8e:	b0 91 45 0a 	lds	r27, 0x0A45	; 0x800a45 <pxCurrentTCB+0x1>
     f92:	0d b6       	in	r0, 0x3d	; 61
     f94:	0d 92       	st	X+, r0
     f96:	0e b6       	in	r0, 0x3e	; 62
     f98:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     f9a:	85 d1       	rcall	.+778    	; 0x12a6 <vTaskIncrementTick>
	vTaskSwitchContext();
     f9c:	1f d3       	rcall	.+1598   	; 0x15dc <vTaskSwitchContext>
     f9e:	a0 91 44 0a 	lds	r26, 0x0A44	; 0x800a44 <pxCurrentTCB>
	portRESTORE_CONTEXT();
     fa2:	b0 91 45 0a 	lds	r27, 0x0A45	; 0x800a45 <pxCurrentTCB+0x1>
     fa6:	cd 91       	ld	r28, X+
     fa8:	cd bf       	out	0x3d, r28	; 61
     faa:	dd 91       	ld	r29, X+
     fac:	de bf       	out	0x3e, r29	; 62
     fae:	ff 91       	pop	r31
     fb0:	ef 91       	pop	r30
     fb2:	df 91       	pop	r29
     fb4:	cf 91       	pop	r28
     fb6:	bf 91       	pop	r27
     fb8:	af 91       	pop	r26
     fba:	9f 91       	pop	r25
     fbc:	8f 91       	pop	r24
     fbe:	7f 91       	pop	r23
     fc0:	6f 91       	pop	r22
     fc2:	5f 91       	pop	r21
     fc4:	4f 91       	pop	r20
     fc6:	3f 91       	pop	r19
     fc8:	2f 91       	pop	r18
     fca:	1f 91       	pop	r17
     fcc:	0f 91       	pop	r16
     fce:	ff 90       	pop	r15
     fd0:	ef 90       	pop	r14
     fd2:	df 90       	pop	r13
     fd4:	cf 90       	pop	r12
     fd6:	bf 90       	pop	r11
     fd8:	af 90       	pop	r10
     fda:	9f 90       	pop	r9
     fdc:	8f 90       	pop	r8
     fde:	7f 90       	pop	r7
     fe0:	6f 90       	pop	r6
     fe2:	5f 90       	pop	r5
     fe4:	4f 90       	pop	r4
     fe6:	3f 90       	pop	r3
     fe8:	2f 90       	pop	r2
     fea:	1f 90       	pop	r1
     fec:	0f 90       	pop	r0
     fee:	0f be       	out	0x3f, r0	; 63
     ff0:	0f 90       	pop	r0
     ff2:	08 95       	ret

00000ff4 <__vector_13>:

	asm volatile ( "ret" );
     ff4:	a6 df       	rcall	.-180    	; 0xf42 <vPortYieldFromTick>
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
     ff6:	18 95       	reti

00000ff8 <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
     ff8:	cf 93       	push	r28
     ffa:	df 93       	push	r29
     ffc:	ec 01       	movw	r28, r24
     ffe:	e0 91 44 0a 	lds	r30, 0x0A44	; 0x800a44 <pxCurrentTCB>
    1002:	f0 91 45 0a 	lds	r31, 0x0A45	; 0x800a45 <pxCurrentTCB+0x1>
    1006:	93 83       	std	Z+3, r25	; 0x03
    1008:	82 83       	std	Z+2, r24	; 0x02
    100a:	80 91 f4 09 	lds	r24, 0x09F4	; 0x8009f4 <xTickCount>
    100e:	90 91 f5 09 	lds	r25, 0x09F5	; 0x8009f5 <xTickCount+0x1>
    1012:	c8 17       	cp	r28, r24
    1014:	d9 07       	cpc	r29, r25
    1016:	60 f4       	brcc	.+24     	; 0x1030 <prvAddCurrentTaskToDelayedList+0x38>
    1018:	60 91 44 0a 	lds	r22, 0x0A44	; 0x800a44 <pxCurrentTCB>
    101c:	70 91 45 0a 	lds	r23, 0x0A45	; 0x800a45 <pxCurrentTCB+0x1>
    1020:	80 91 0a 0a 	lds	r24, 0x0A0A	; 0x800a0a <pxOverflowDelayedTaskList>
    1024:	90 91 0b 0a 	lds	r25, 0x0A0B	; 0x800a0b <pxOverflowDelayedTaskList+0x1>
    1028:	6e 5f       	subi	r22, 0xFE	; 254
    102a:	7f 4f       	sbci	r23, 0xFF	; 255
    102c:	9d d9       	rcall	.-3270   	; 0x368 <vListInsert>
    102e:	16 c0       	rjmp	.+44     	; 0x105c <prvAddCurrentTaskToDelayedList+0x64>
    1030:	60 91 44 0a 	lds	r22, 0x0A44	; 0x800a44 <pxCurrentTCB>
    1034:	70 91 45 0a 	lds	r23, 0x0A45	; 0x800a45 <pxCurrentTCB+0x1>
    1038:	80 91 0c 0a 	lds	r24, 0x0A0C	; 0x800a0c <pxDelayedTaskList>
    103c:	90 91 0d 0a 	lds	r25, 0x0A0D	; 0x800a0d <pxDelayedTaskList+0x1>
    1040:	6e 5f       	subi	r22, 0xFE	; 254
    1042:	7f 4f       	sbci	r23, 0xFF	; 255
    1044:	91 d9       	rcall	.-3294   	; 0x368 <vListInsert>
    1046:	80 91 6b 01 	lds	r24, 0x016B	; 0x80016b <xNextTaskUnblockTime>
    104a:	90 91 6c 01 	lds	r25, 0x016C	; 0x80016c <xNextTaskUnblockTime+0x1>
    104e:	c8 17       	cp	r28, r24
    1050:	d9 07       	cpc	r29, r25
    1052:	20 f4       	brcc	.+8      	; 0x105c <prvAddCurrentTaskToDelayedList+0x64>
    1054:	d0 93 6c 01 	sts	0x016C, r29	; 0x80016c <xNextTaskUnblockTime+0x1>
    1058:	c0 93 6b 01 	sts	0x016B, r28	; 0x80016b <xNextTaskUnblockTime>
    105c:	df 91       	pop	r29
    105e:	cf 91       	pop	r28
    1060:	08 95       	ret

00001062 <xTaskGenericCreate>:
    1062:	4f 92       	push	r4
    1064:	5f 92       	push	r5
    1066:	6f 92       	push	r6
    1068:	7f 92       	push	r7
    106a:	8f 92       	push	r8
    106c:	9f 92       	push	r9
    106e:	af 92       	push	r10
    1070:	bf 92       	push	r11
    1072:	cf 92       	push	r12
    1074:	df 92       	push	r13
    1076:	ef 92       	push	r14
    1078:	ff 92       	push	r15
    107a:	0f 93       	push	r16
    107c:	1f 93       	push	r17
    107e:	cf 93       	push	r28
    1080:	df 93       	push	r29
    1082:	5c 01       	movw	r10, r24
    1084:	4b 01       	movw	r8, r22
    1086:	3a 01       	movw	r6, r20
    1088:	29 01       	movw	r4, r18
    108a:	81 e2       	ldi	r24, 0x21	; 33
    108c:	90 e0       	ldi	r25, 0x00	; 0
    108e:	0d d9       	rcall	.-3558   	; 0x2aa <pvPortMalloc>
    1090:	ec 01       	movw	r28, r24
    1092:	89 2b       	or	r24, r25
    1094:	09 f4       	brne	.+2      	; 0x1098 <xTaskGenericCreate+0x36>
    1096:	c6 c0       	rjmp	.+396    	; 0x1224 <xTaskGenericCreate+0x1c2>
    1098:	c1 14       	cp	r12, r1
    109a:	d1 04       	cpc	r13, r1
    109c:	09 f0       	breq	.+2      	; 0x10a0 <xTaskGenericCreate+0x3e>
    109e:	be c0       	rjmp	.+380    	; 0x121c <xTaskGenericCreate+0x1ba>
    10a0:	c3 01       	movw	r24, r6
    10a2:	03 d9       	rcall	.-3578   	; 0x2aa <pvPortMalloc>
    10a4:	98 8f       	std	Y+24, r25	; 0x18
    10a6:	8f 8b       	std	Y+23, r24	; 0x17
    10a8:	00 97       	sbiw	r24, 0x00	; 0
    10aa:	19 f4       	brne	.+6      	; 0x10b2 <xTaskGenericCreate+0x50>
    10ac:	ce 01       	movw	r24, r28
    10ae:	22 d9       	rcall	.-3516   	; 0x2f4 <vPortFree>
    10b0:	b9 c0       	rjmp	.+370    	; 0x1224 <xTaskGenericCreate+0x1c2>
    10b2:	a3 01       	movw	r20, r6
    10b4:	65 ea       	ldi	r22, 0xA5	; 165
    10b6:	70 e0       	ldi	r23, 0x00	; 0
    10b8:	09 d3       	rcall	.+1554   	; 0x16cc <memset>
    10ba:	93 01       	movw	r18, r6
    10bc:	21 50       	subi	r18, 0x01	; 1
    10be:	31 09       	sbc	r19, r1
    10c0:	8f 89       	ldd	r24, Y+23	; 0x17
    10c2:	98 8d       	ldd	r25, Y+24	; 0x18
    10c4:	3c 01       	movw	r6, r24
    10c6:	62 0e       	add	r6, r18
    10c8:	73 1e       	adc	r7, r19
    10ca:	48 e0       	ldi	r20, 0x08	; 8
    10cc:	50 e0       	ldi	r21, 0x00	; 0
    10ce:	b4 01       	movw	r22, r8
    10d0:	ce 01       	movw	r24, r28
    10d2:	49 96       	adiw	r24, 0x19	; 25
    10d4:	02 d3       	rcall	.+1540   	; 0x16da <strncpy>
    10d6:	18 a2       	std	Y+32, r1	; 0x20
    10d8:	10 2f       	mov	r17, r16
    10da:	04 30       	cpi	r16, 0x04	; 4
    10dc:	08 f0       	brcs	.+2      	; 0x10e0 <xTaskGenericCreate+0x7e>
    10de:	13 e0       	ldi	r17, 0x03	; 3
    10e0:	1e 8b       	std	Y+22, r17	; 0x16
    10e2:	6e 01       	movw	r12, r28
    10e4:	82 e0       	ldi	r24, 0x02	; 2
    10e6:	c8 0e       	add	r12, r24
    10e8:	d1 1c       	adc	r13, r1
    10ea:	c6 01       	movw	r24, r12
    10ec:	12 d9       	rcall	.-3548   	; 0x312 <vListInitialiseItem>
    10ee:	ce 01       	movw	r24, r28
    10f0:	0c 96       	adiw	r24, 0x0c	; 12
    10f2:	0f d9       	rcall	.-3554   	; 0x312 <vListInitialiseItem>
    10f4:	d9 87       	std	Y+9, r29	; 0x09
    10f6:	c8 87       	std	Y+8, r28	; 0x08
    10f8:	84 e0       	ldi	r24, 0x04	; 4
    10fa:	90 e0       	ldi	r25, 0x00	; 0
    10fc:	81 1b       	sub	r24, r17
    10fe:	91 09       	sbc	r25, r1
    1100:	9d 87       	std	Y+13, r25	; 0x0d
    1102:	8c 87       	std	Y+12, r24	; 0x0c
    1104:	db 8b       	std	Y+19, r29	; 0x13
    1106:	ca 8b       	std	Y+18, r28	; 0x12
    1108:	a2 01       	movw	r20, r4
    110a:	b5 01       	movw	r22, r10
    110c:	c3 01       	movw	r24, r6
    110e:	1b de       	rcall	.-970    	; 0xd46 <pxPortInitialiseStack>
    1110:	99 83       	std	Y+1, r25	; 0x01
    1112:	88 83       	st	Y, r24
    1114:	e1 14       	cp	r14, r1
    1116:	f1 04       	cpc	r15, r1
    1118:	19 f0       	breq	.+6      	; 0x1120 <xTaskGenericCreate+0xbe>
    111a:	f7 01       	movw	r30, r14
    111c:	d1 83       	std	Z+1, r29	; 0x01
    111e:	c0 83       	st	Z, r28
    1120:	0f b6       	in	r0, 0x3f	; 63
    1122:	f8 94       	cli
    1124:	0f 92       	push	r0
    1126:	80 91 f6 09 	lds	r24, 0x09F6	; 0x8009f6 <uxCurrentNumberOfTasks>
    112a:	8f 5f       	subi	r24, 0xFF	; 255
    112c:	80 93 f6 09 	sts	0x09F6, r24	; 0x8009f6 <uxCurrentNumberOfTasks>
    1130:	80 91 44 0a 	lds	r24, 0x0A44	; 0x800a44 <pxCurrentTCB>
    1134:	90 91 45 0a 	lds	r25, 0x0A45	; 0x800a45 <pxCurrentTCB+0x1>
    1138:	89 2b       	or	r24, r25
    113a:	69 f5       	brne	.+90     	; 0x1196 <xTaskGenericCreate+0x134>
    113c:	d0 93 45 0a 	sts	0x0A45, r29	; 0x800a45 <pxCurrentTCB+0x1>
    1140:	c0 93 44 0a 	sts	0x0A44, r28	; 0x800a44 <pxCurrentTCB>
    1144:	80 91 f6 09 	lds	r24, 0x09F6	; 0x8009f6 <uxCurrentNumberOfTasks>
    1148:	81 30       	cpi	r24, 0x01	; 1
    114a:	a1 f5       	brne	.+104    	; 0x11b4 <xTaskGenericCreate+0x152>
    114c:	80 e2       	ldi	r24, 0x20	; 32
    114e:	9a e0       	ldi	r25, 0x0A	; 10
    1150:	d2 d8       	rcall	.-3676   	; 0x2f6 <vListInitialise>
    1152:	89 e2       	ldi	r24, 0x29	; 41
    1154:	9a e0       	ldi	r25, 0x0A	; 10
    1156:	cf d8       	rcall	.-3682   	; 0x2f6 <vListInitialise>
    1158:	82 e3       	ldi	r24, 0x32	; 50
    115a:	9a e0       	ldi	r25, 0x0A	; 10
    115c:	cc d8       	rcall	.-3688   	; 0x2f6 <vListInitialise>
    115e:	8b e3       	ldi	r24, 0x3B	; 59
    1160:	9a e0       	ldi	r25, 0x0A	; 10
    1162:	c9 d8       	rcall	.-3694   	; 0x2f6 <vListInitialise>
    1164:	87 e1       	ldi	r24, 0x17	; 23
    1166:	9a e0       	ldi	r25, 0x0A	; 10
    1168:	c6 d8       	rcall	.-3700   	; 0x2f6 <vListInitialise>
    116a:	8e e0       	ldi	r24, 0x0E	; 14
    116c:	9a e0       	ldi	r25, 0x0A	; 10
    116e:	c3 d8       	rcall	.-3706   	; 0x2f6 <vListInitialise>
    1170:	81 e0       	ldi	r24, 0x01	; 1
    1172:	9a e0       	ldi	r25, 0x0A	; 10
    1174:	c0 d8       	rcall	.-3712   	; 0x2f6 <vListInitialise>
    1176:	88 ef       	ldi	r24, 0xF8	; 248
    1178:	99 e0       	ldi	r25, 0x09	; 9
    117a:	bd d8       	rcall	.-3718   	; 0x2f6 <vListInitialise>
    117c:	87 e1       	ldi	r24, 0x17	; 23
    117e:	9a e0       	ldi	r25, 0x0A	; 10
    1180:	90 93 0d 0a 	sts	0x0A0D, r25	; 0x800a0d <pxDelayedTaskList+0x1>
    1184:	80 93 0c 0a 	sts	0x0A0C, r24	; 0x800a0c <pxDelayedTaskList>
    1188:	8e e0       	ldi	r24, 0x0E	; 14
    118a:	9a e0       	ldi	r25, 0x0A	; 10
    118c:	90 93 0b 0a 	sts	0x0A0B, r25	; 0x800a0b <pxOverflowDelayedTaskList+0x1>
    1190:	80 93 0a 0a 	sts	0x0A0A, r24	; 0x800a0a <pxOverflowDelayedTaskList>
    1194:	0f c0       	rjmp	.+30     	; 0x11b4 <xTaskGenericCreate+0x152>
    1196:	80 91 f1 09 	lds	r24, 0x09F1	; 0x8009f1 <xSchedulerRunning>
    119a:	81 11       	cpse	r24, r1
    119c:	0b c0       	rjmp	.+22     	; 0x11b4 <xTaskGenericCreate+0x152>
    119e:	e0 91 44 0a 	lds	r30, 0x0A44	; 0x800a44 <pxCurrentTCB>
    11a2:	f0 91 45 0a 	lds	r31, 0x0A45	; 0x800a45 <pxCurrentTCB+0x1>
    11a6:	86 89       	ldd	r24, Z+22	; 0x16
    11a8:	08 17       	cp	r16, r24
    11aa:	20 f0       	brcs	.+8      	; 0x11b4 <xTaskGenericCreate+0x152>
    11ac:	d0 93 45 0a 	sts	0x0A45, r29	; 0x800a45 <pxCurrentTCB+0x1>
    11b0:	c0 93 44 0a 	sts	0x0A44, r28	; 0x800a44 <pxCurrentTCB>
    11b4:	8e 89       	ldd	r24, Y+22	; 0x16
    11b6:	90 91 f3 09 	lds	r25, 0x09F3	; 0x8009f3 <uxTopUsedPriority>
    11ba:	98 17       	cp	r25, r24
    11bc:	10 f4       	brcc	.+4      	; 0x11c2 <xTaskGenericCreate+0x160>
    11be:	80 93 f3 09 	sts	0x09F3, r24	; 0x8009f3 <uxTopUsedPriority>
    11c2:	90 91 ec 09 	lds	r25, 0x09EC	; 0x8009ec <uxTaskNumber>
    11c6:	9f 5f       	subi	r25, 0xFF	; 255
    11c8:	90 93 ec 09 	sts	0x09EC, r25	; 0x8009ec <uxTaskNumber>
    11cc:	90 91 f2 09 	lds	r25, 0x09F2	; 0x8009f2 <uxTopReadyPriority>
    11d0:	98 17       	cp	r25, r24
    11d2:	10 f4       	brcc	.+4      	; 0x11d8 <xTaskGenericCreate+0x176>
    11d4:	80 93 f2 09 	sts	0x09F2, r24	; 0x8009f2 <uxTopReadyPriority>
    11d8:	90 e0       	ldi	r25, 0x00	; 0
    11da:	9c 01       	movw	r18, r24
    11dc:	22 0f       	add	r18, r18
    11de:	33 1f       	adc	r19, r19
    11e0:	22 0f       	add	r18, r18
    11e2:	33 1f       	adc	r19, r19
    11e4:	22 0f       	add	r18, r18
    11e6:	33 1f       	adc	r19, r19
    11e8:	82 0f       	add	r24, r18
    11ea:	93 1f       	adc	r25, r19
    11ec:	b6 01       	movw	r22, r12
    11ee:	80 5e       	subi	r24, 0xE0	; 224
    11f0:	95 4f       	sbci	r25, 0xF5	; 245
    11f2:	93 d8       	rcall	.-3802   	; 0x31a <vListInsertEnd>
    11f4:	0f 90       	pop	r0
    11f6:	0f be       	out	0x3f, r0	; 63
    11f8:	80 91 f1 09 	lds	r24, 0x09F1	; 0x8009f1 <xSchedulerRunning>
    11fc:	88 23       	and	r24, r24
    11fe:	51 f0       	breq	.+20     	; 0x1214 <xTaskGenericCreate+0x1b2>
    1200:	e0 91 44 0a 	lds	r30, 0x0A44	; 0x800a44 <pxCurrentTCB>
    1204:	f0 91 45 0a 	lds	r31, 0x0A45	; 0x800a45 <pxCurrentTCB+0x1>
    1208:	86 89       	ldd	r24, Z+22	; 0x16
    120a:	80 17       	cp	r24, r16
    120c:	28 f4       	brcc	.+10     	; 0x1218 <xTaskGenericCreate+0x1b6>
    120e:	41 de       	rcall	.-894    	; 0xe92 <vPortYield>
    1210:	81 e0       	ldi	r24, 0x01	; 1
    1212:	09 c0       	rjmp	.+18     	; 0x1226 <xTaskGenericCreate+0x1c4>
    1214:	81 e0       	ldi	r24, 0x01	; 1
    1216:	07 c0       	rjmp	.+14     	; 0x1226 <xTaskGenericCreate+0x1c4>
    1218:	81 e0       	ldi	r24, 0x01	; 1
    121a:	05 c0       	rjmp	.+10     	; 0x1226 <xTaskGenericCreate+0x1c4>
    121c:	d8 8e       	std	Y+24, r13	; 0x18
    121e:	cf 8a       	std	Y+23, r12	; 0x17
    1220:	c6 01       	movw	r24, r12
    1222:	47 cf       	rjmp	.-370    	; 0x10b2 <xTaskGenericCreate+0x50>
    1224:	8f ef       	ldi	r24, 0xFF	; 255
    1226:	df 91       	pop	r29
    1228:	cf 91       	pop	r28
    122a:	1f 91       	pop	r17
    122c:	0f 91       	pop	r16
    122e:	ff 90       	pop	r15
    1230:	ef 90       	pop	r14
    1232:	df 90       	pop	r13
    1234:	cf 90       	pop	r12
    1236:	bf 90       	pop	r11
    1238:	af 90       	pop	r10
    123a:	9f 90       	pop	r9
    123c:	8f 90       	pop	r8
    123e:	7f 90       	pop	r7
    1240:	6f 90       	pop	r6
    1242:	5f 90       	pop	r5
    1244:	4f 90       	pop	r4
    1246:	08 95       	ret

00001248 <vTaskStartScheduler>:
    1248:	af 92       	push	r10
    124a:	bf 92       	push	r11
    124c:	cf 92       	push	r12
    124e:	df 92       	push	r13
    1250:	ef 92       	push	r14
    1252:	ff 92       	push	r15
    1254:	0f 93       	push	r16
    1256:	a1 2c       	mov	r10, r1
    1258:	b1 2c       	mov	r11, r1
    125a:	c1 2c       	mov	r12, r1
    125c:	d1 2c       	mov	r13, r1
    125e:	e1 2c       	mov	r14, r1
    1260:	f1 2c       	mov	r15, r1
    1262:	00 e0       	ldi	r16, 0x00	; 0
    1264:	20 e0       	ldi	r18, 0x00	; 0
    1266:	30 e0       	ldi	r19, 0x00	; 0
    1268:	45 e5       	ldi	r20, 0x55	; 85
    126a:	50 e0       	ldi	r21, 0x00	; 0
    126c:	60 e0       	ldi	r22, 0x00	; 0
    126e:	72 e0       	ldi	r23, 0x02	; 2
    1270:	85 eb       	ldi	r24, 0xB5	; 181
    1272:	9a e0       	ldi	r25, 0x0A	; 10
    1274:	f6 de       	rcall	.-532    	; 0x1062 <xTaskGenericCreate>
    1276:	81 30       	cpi	r24, 0x01	; 1
    1278:	41 f4       	brne	.+16     	; 0x128a <vTaskStartScheduler+0x42>
    127a:	f8 94       	cli
    127c:	80 93 f1 09 	sts	0x09F1, r24	; 0x8009f1 <xSchedulerRunning>
    1280:	10 92 f5 09 	sts	0x09F5, r1	; 0x8009f5 <xTickCount+0x1>
    1284:	10 92 f4 09 	sts	0x09F4, r1	; 0x8009f4 <xTickCount>
    1288:	ca dd       	rcall	.-1132   	; 0xe1e <xPortStartScheduler>
    128a:	0f 91       	pop	r16
    128c:	ff 90       	pop	r15
    128e:	ef 90       	pop	r14
    1290:	df 90       	pop	r13
    1292:	cf 90       	pop	r12
    1294:	bf 90       	pop	r11
    1296:	af 90       	pop	r10
    1298:	08 95       	ret

0000129a <vTaskSuspendAll>:
    129a:	80 91 f0 09 	lds	r24, 0x09F0	; 0x8009f0 <uxSchedulerSuspended>
    129e:	8f 5f       	subi	r24, 0xFF	; 255
    12a0:	80 93 f0 09 	sts	0x09F0, r24	; 0x8009f0 <uxSchedulerSuspended>
    12a4:	08 95       	ret

000012a6 <vTaskIncrementTick>:
    12a6:	0f 93       	push	r16
    12a8:	1f 93       	push	r17
    12aa:	cf 93       	push	r28
    12ac:	df 93       	push	r29
    12ae:	80 91 f0 09 	lds	r24, 0x09F0	; 0x8009f0 <uxSchedulerSuspended>
    12b2:	81 11       	cpse	r24, r1
    12b4:	b0 c0       	rjmp	.+352    	; 0x1416 <vTaskIncrementTick+0x170>
    12b6:	80 91 f4 09 	lds	r24, 0x09F4	; 0x8009f4 <xTickCount>
    12ba:	90 91 f5 09 	lds	r25, 0x09F5	; 0x8009f5 <xTickCount+0x1>
    12be:	01 96       	adiw	r24, 0x01	; 1
    12c0:	90 93 f5 09 	sts	0x09F5, r25	; 0x8009f5 <xTickCount+0x1>
    12c4:	80 93 f4 09 	sts	0x09F4, r24	; 0x8009f4 <xTickCount>
    12c8:	80 91 f4 09 	lds	r24, 0x09F4	; 0x8009f4 <xTickCount>
    12cc:	90 91 f5 09 	lds	r25, 0x09F5	; 0x8009f5 <xTickCount+0x1>
    12d0:	89 2b       	or	r24, r25
    12d2:	99 f5       	brne	.+102    	; 0x133a <vTaskIncrementTick+0x94>
    12d4:	80 91 0c 0a 	lds	r24, 0x0A0C	; 0x800a0c <pxDelayedTaskList>
    12d8:	90 91 0d 0a 	lds	r25, 0x0A0D	; 0x800a0d <pxDelayedTaskList+0x1>
    12dc:	20 91 0a 0a 	lds	r18, 0x0A0A	; 0x800a0a <pxOverflowDelayedTaskList>
    12e0:	30 91 0b 0a 	lds	r19, 0x0A0B	; 0x800a0b <pxOverflowDelayedTaskList+0x1>
    12e4:	30 93 0d 0a 	sts	0x0A0D, r19	; 0x800a0d <pxDelayedTaskList+0x1>
    12e8:	20 93 0c 0a 	sts	0x0A0C, r18	; 0x800a0c <pxDelayedTaskList>
    12ec:	90 93 0b 0a 	sts	0x0A0B, r25	; 0x800a0b <pxOverflowDelayedTaskList+0x1>
    12f0:	80 93 0a 0a 	sts	0x0A0A, r24	; 0x800a0a <pxOverflowDelayedTaskList>
    12f4:	80 91 ed 09 	lds	r24, 0x09ED	; 0x8009ed <xNumOfOverflows>
    12f8:	8f 5f       	subi	r24, 0xFF	; 255
    12fa:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <xNumOfOverflows>
    12fe:	e0 91 0c 0a 	lds	r30, 0x0A0C	; 0x800a0c <pxDelayedTaskList>
    1302:	f0 91 0d 0a 	lds	r31, 0x0A0D	; 0x800a0d <pxDelayedTaskList+0x1>
    1306:	80 81       	ld	r24, Z
    1308:	81 11       	cpse	r24, r1
    130a:	07 c0       	rjmp	.+14     	; 0x131a <vTaskIncrementTick+0x74>
    130c:	8f ef       	ldi	r24, 0xFF	; 255
    130e:	9f ef       	ldi	r25, 0xFF	; 255
    1310:	90 93 6c 01 	sts	0x016C, r25	; 0x80016c <xNextTaskUnblockTime+0x1>
    1314:	80 93 6b 01 	sts	0x016B, r24	; 0x80016b <xNextTaskUnblockTime>
    1318:	10 c0       	rjmp	.+32     	; 0x133a <vTaskIncrementTick+0x94>
    131a:	e0 91 0c 0a 	lds	r30, 0x0A0C	; 0x800a0c <pxDelayedTaskList>
    131e:	f0 91 0d 0a 	lds	r31, 0x0A0D	; 0x800a0d <pxDelayedTaskList+0x1>
    1322:	05 80       	ldd	r0, Z+5	; 0x05
    1324:	f6 81       	ldd	r31, Z+6	; 0x06
    1326:	e0 2d       	mov	r30, r0
    1328:	06 80       	ldd	r0, Z+6	; 0x06
    132a:	f7 81       	ldd	r31, Z+7	; 0x07
    132c:	e0 2d       	mov	r30, r0
    132e:	82 81       	ldd	r24, Z+2	; 0x02
    1330:	93 81       	ldd	r25, Z+3	; 0x03
    1332:	90 93 6c 01 	sts	0x016C, r25	; 0x80016c <xNextTaskUnblockTime+0x1>
    1336:	80 93 6b 01 	sts	0x016B, r24	; 0x80016b <xNextTaskUnblockTime>
    133a:	20 91 f4 09 	lds	r18, 0x09F4	; 0x8009f4 <xTickCount>
    133e:	30 91 f5 09 	lds	r19, 0x09F5	; 0x8009f5 <xTickCount+0x1>
    1342:	80 91 6b 01 	lds	r24, 0x016B	; 0x80016b <xNextTaskUnblockTime>
    1346:	90 91 6c 01 	lds	r25, 0x016C	; 0x80016c <xNextTaskUnblockTime+0x1>
    134a:	28 17       	cp	r18, r24
    134c:	39 07       	cpc	r19, r25
    134e:	08 f4       	brcc	.+2      	; 0x1352 <vTaskIncrementTick+0xac>
    1350:	67 c0       	rjmp	.+206    	; 0x1420 <vTaskIncrementTick+0x17a>
    1352:	e0 91 0c 0a 	lds	r30, 0x0A0C	; 0x800a0c <pxDelayedTaskList>
    1356:	f0 91 0d 0a 	lds	r31, 0x0A0D	; 0x800a0d <pxDelayedTaskList+0x1>
    135a:	80 81       	ld	r24, Z
    135c:	88 23       	and	r24, r24
    135e:	99 f0       	breq	.+38     	; 0x1386 <vTaskIncrementTick+0xe0>
    1360:	e0 91 0c 0a 	lds	r30, 0x0A0C	; 0x800a0c <pxDelayedTaskList>
    1364:	f0 91 0d 0a 	lds	r31, 0x0A0D	; 0x800a0d <pxDelayedTaskList+0x1>
    1368:	05 80       	ldd	r0, Z+5	; 0x05
    136a:	f6 81       	ldd	r31, Z+6	; 0x06
    136c:	e0 2d       	mov	r30, r0
    136e:	c6 81       	ldd	r28, Z+6	; 0x06
    1370:	d7 81       	ldd	r29, Z+7	; 0x07
    1372:	8a 81       	ldd	r24, Y+2	; 0x02
    1374:	9b 81       	ldd	r25, Y+3	; 0x03
    1376:	20 91 f4 09 	lds	r18, 0x09F4	; 0x8009f4 <xTickCount>
    137a:	30 91 f5 09 	lds	r19, 0x09F5	; 0x8009f5 <xTickCount+0x1>
    137e:	28 17       	cp	r18, r24
    1380:	39 07       	cpc	r19, r25
    1382:	f8 f4       	brcc	.+62     	; 0x13c2 <vTaskIncrementTick+0x11c>
    1384:	19 c0       	rjmp	.+50     	; 0x13b8 <vTaskIncrementTick+0x112>
    1386:	8f ef       	ldi	r24, 0xFF	; 255
    1388:	9f ef       	ldi	r25, 0xFF	; 255
    138a:	90 93 6c 01 	sts	0x016C, r25	; 0x80016c <xNextTaskUnblockTime+0x1>
    138e:	80 93 6b 01 	sts	0x016B, r24	; 0x80016b <xNextTaskUnblockTime>
    1392:	46 c0       	rjmp	.+140    	; 0x1420 <vTaskIncrementTick+0x17a>
    1394:	e0 91 0c 0a 	lds	r30, 0x0A0C	; 0x800a0c <pxDelayedTaskList>
    1398:	f0 91 0d 0a 	lds	r31, 0x0A0D	; 0x800a0d <pxDelayedTaskList+0x1>
    139c:	05 80       	ldd	r0, Z+5	; 0x05
    139e:	f6 81       	ldd	r31, Z+6	; 0x06
    13a0:	e0 2d       	mov	r30, r0
    13a2:	c6 81       	ldd	r28, Z+6	; 0x06
    13a4:	d7 81       	ldd	r29, Z+7	; 0x07
    13a6:	8a 81       	ldd	r24, Y+2	; 0x02
    13a8:	9b 81       	ldd	r25, Y+3	; 0x03
    13aa:	20 91 f4 09 	lds	r18, 0x09F4	; 0x8009f4 <xTickCount>
    13ae:	30 91 f5 09 	lds	r19, 0x09F5	; 0x8009f5 <xTickCount+0x1>
    13b2:	28 17       	cp	r18, r24
    13b4:	39 07       	cpc	r19, r25
    13b6:	28 f4       	brcc	.+10     	; 0x13c2 <vTaskIncrementTick+0x11c>
    13b8:	90 93 6c 01 	sts	0x016C, r25	; 0x80016c <xNextTaskUnblockTime+0x1>
    13bc:	80 93 6b 01 	sts	0x016B, r24	; 0x80016b <xNextTaskUnblockTime>
    13c0:	2f c0       	rjmp	.+94     	; 0x1420 <vTaskIncrementTick+0x17a>
    13c2:	8e 01       	movw	r16, r28
    13c4:	0e 5f       	subi	r16, 0xFE	; 254
    13c6:	1f 4f       	sbci	r17, 0xFF	; 255
    13c8:	c8 01       	movw	r24, r16
    13ca:	09 d8       	rcall	.-4078   	; 0x3de <vListRemove>
    13cc:	8c 89       	ldd	r24, Y+20	; 0x14
    13ce:	9d 89       	ldd	r25, Y+21	; 0x15
    13d0:	89 2b       	or	r24, r25
    13d2:	19 f0       	breq	.+6      	; 0x13da <vTaskIncrementTick+0x134>
    13d4:	ce 01       	movw	r24, r28
    13d6:	0c 96       	adiw	r24, 0x0c	; 12
    13d8:	02 d8       	rcall	.-4092   	; 0x3de <vListRemove>
    13da:	8e 89       	ldd	r24, Y+22	; 0x16
    13dc:	90 91 f2 09 	lds	r25, 0x09F2	; 0x8009f2 <uxTopReadyPriority>
    13e0:	98 17       	cp	r25, r24
    13e2:	10 f4       	brcc	.+4      	; 0x13e8 <vTaskIncrementTick+0x142>
    13e4:	80 93 f2 09 	sts	0x09F2, r24	; 0x8009f2 <uxTopReadyPriority>
    13e8:	90 e0       	ldi	r25, 0x00	; 0
    13ea:	9c 01       	movw	r18, r24
    13ec:	22 0f       	add	r18, r18
    13ee:	33 1f       	adc	r19, r19
    13f0:	22 0f       	add	r18, r18
    13f2:	33 1f       	adc	r19, r19
    13f4:	22 0f       	add	r18, r18
    13f6:	33 1f       	adc	r19, r19
    13f8:	82 0f       	add	r24, r18
    13fa:	93 1f       	adc	r25, r19
    13fc:	b8 01       	movw	r22, r16
    13fe:	80 5e       	subi	r24, 0xE0	; 224
    1400:	95 4f       	sbci	r25, 0xF5	; 245
    1402:	0e 94 8d 01 	call	0x31a	; 0x31a <vListInsertEnd>
    1406:	e0 91 0c 0a 	lds	r30, 0x0A0C	; 0x800a0c <pxDelayedTaskList>
    140a:	f0 91 0d 0a 	lds	r31, 0x0A0D	; 0x800a0d <pxDelayedTaskList+0x1>
    140e:	80 81       	ld	r24, Z
    1410:	81 11       	cpse	r24, r1
    1412:	c0 cf       	rjmp	.-128    	; 0x1394 <vTaskIncrementTick+0xee>
    1414:	b8 cf       	rjmp	.-144    	; 0x1386 <vTaskIncrementTick+0xe0>
    1416:	80 91 ef 09 	lds	r24, 0x09EF	; 0x8009ef <uxMissedTicks>
    141a:	8f 5f       	subi	r24, 0xFF	; 255
    141c:	80 93 ef 09 	sts	0x09EF, r24	; 0x8009ef <uxMissedTicks>
    1420:	df 91       	pop	r29
    1422:	cf 91       	pop	r28
    1424:	1f 91       	pop	r17
    1426:	0f 91       	pop	r16
    1428:	08 95       	ret

0000142a <xTaskResumeAll>:
    142a:	cf 92       	push	r12
    142c:	df 92       	push	r13
    142e:	ef 92       	push	r14
    1430:	ff 92       	push	r15
    1432:	0f 93       	push	r16
    1434:	1f 93       	push	r17
    1436:	cf 93       	push	r28
    1438:	df 93       	push	r29
    143a:	0f b6       	in	r0, 0x3f	; 63
    143c:	f8 94       	cli
    143e:	0f 92       	push	r0
    1440:	80 91 f0 09 	lds	r24, 0x09F0	; 0x8009f0 <uxSchedulerSuspended>
    1444:	81 50       	subi	r24, 0x01	; 1
    1446:	80 93 f0 09 	sts	0x09F0, r24	; 0x8009f0 <uxSchedulerSuspended>
    144a:	80 91 f0 09 	lds	r24, 0x09F0	; 0x8009f0 <uxSchedulerSuspended>
    144e:	81 11       	cpse	r24, r1
    1450:	62 c0       	rjmp	.+196    	; 0x1516 <xTaskResumeAll+0xec>
    1452:	80 91 f6 09 	lds	r24, 0x09F6	; 0x8009f6 <uxCurrentNumberOfTasks>
    1456:	81 11       	cpse	r24, r1
    1458:	32 c0       	rjmp	.+100    	; 0x14be <xTaskResumeAll+0x94>
    145a:	60 c0       	rjmp	.+192    	; 0x151c <xTaskResumeAll+0xf2>
    145c:	d7 01       	movw	r26, r14
    145e:	15 96       	adiw	r26, 0x05	; 5
    1460:	ed 91       	ld	r30, X+
    1462:	fc 91       	ld	r31, X
    1464:	16 97       	sbiw	r26, 0x06	; 6
    1466:	c6 81       	ldd	r28, Z+6	; 0x06
    1468:	d7 81       	ldd	r29, Z+7	; 0x07
    146a:	ce 01       	movw	r24, r28
    146c:	0c 96       	adiw	r24, 0x0c	; 12
    146e:	0e 94 ef 01 	call	0x3de	; 0x3de <vListRemove>
    1472:	8e 01       	movw	r16, r28
    1474:	0e 5f       	subi	r16, 0xFE	; 254
    1476:	1f 4f       	sbci	r17, 0xFF	; 255
    1478:	c8 01       	movw	r24, r16
    147a:	0e 94 ef 01 	call	0x3de	; 0x3de <vListRemove>
    147e:	8e 89       	ldd	r24, Y+22	; 0x16
    1480:	90 91 f2 09 	lds	r25, 0x09F2	; 0x8009f2 <uxTopReadyPriority>
    1484:	98 17       	cp	r25, r24
    1486:	10 f4       	brcc	.+4      	; 0x148c <xTaskResumeAll+0x62>
    1488:	80 93 f2 09 	sts	0x09F2, r24	; 0x8009f2 <uxTopReadyPriority>
    148c:	90 e0       	ldi	r25, 0x00	; 0
    148e:	9c 01       	movw	r18, r24
    1490:	22 0f       	add	r18, r18
    1492:	33 1f       	adc	r19, r19
    1494:	22 0f       	add	r18, r18
    1496:	33 1f       	adc	r19, r19
    1498:	22 0f       	add	r18, r18
    149a:	33 1f       	adc	r19, r19
    149c:	82 0f       	add	r24, r18
    149e:	93 1f       	adc	r25, r19
    14a0:	b8 01       	movw	r22, r16
    14a2:	80 5e       	subi	r24, 0xE0	; 224
    14a4:	95 4f       	sbci	r25, 0xF5	; 245
    14a6:	0e 94 8d 01 	call	0x31a	; 0x31a <vListInsertEnd>
    14aa:	e0 91 44 0a 	lds	r30, 0x0A44	; 0x800a44 <pxCurrentTCB>
    14ae:	f0 91 45 0a 	lds	r31, 0x0A45	; 0x800a45 <pxCurrentTCB+0x1>
    14b2:	9e 89       	ldd	r25, Y+22	; 0x16
    14b4:	86 89       	ldd	r24, Z+22	; 0x16
    14b6:	98 17       	cp	r25, r24
    14b8:	58 f0       	brcs	.+22     	; 0x14d0 <xTaskResumeAll+0xa6>
    14ba:	dc 2c       	mov	r13, r12
    14bc:	09 c0       	rjmp	.+18     	; 0x14d0 <xTaskResumeAll+0xa6>
    14be:	d1 2c       	mov	r13, r1
    14c0:	0f 2e       	mov	r0, r31
    14c2:	f1 e0       	ldi	r31, 0x01	; 1
    14c4:	ef 2e       	mov	r14, r31
    14c6:	fa e0       	ldi	r31, 0x0A	; 10
    14c8:	ff 2e       	mov	r15, r31
    14ca:	f0 2d       	mov	r31, r0
    14cc:	cc 24       	eor	r12, r12
    14ce:	c3 94       	inc	r12
    14d0:	f7 01       	movw	r30, r14
    14d2:	80 81       	ld	r24, Z
    14d4:	81 11       	cpse	r24, r1
    14d6:	c2 cf       	rjmp	.-124    	; 0x145c <xTaskResumeAll+0x32>
    14d8:	80 91 ef 09 	lds	r24, 0x09EF	; 0x8009ef <uxMissedTicks>
    14dc:	88 23       	and	r24, r24
    14de:	79 f0       	breq	.+30     	; 0x14fe <xTaskResumeAll+0xd4>
    14e0:	80 91 ef 09 	lds	r24, 0x09EF	; 0x8009ef <uxMissedTicks>
    14e4:	88 23       	and	r24, r24
    14e6:	91 f0       	breq	.+36     	; 0x150c <xTaskResumeAll+0xe2>
    14e8:	de de       	rcall	.-580    	; 0x12a6 <vTaskIncrementTick>
    14ea:	80 91 ef 09 	lds	r24, 0x09EF	; 0x8009ef <uxMissedTicks>
    14ee:	81 50       	subi	r24, 0x01	; 1
    14f0:	80 93 ef 09 	sts	0x09EF, r24	; 0x8009ef <uxMissedTicks>
    14f4:	80 91 ef 09 	lds	r24, 0x09EF	; 0x8009ef <uxMissedTicks>
    14f8:	81 11       	cpse	r24, r1
    14fa:	f6 cf       	rjmp	.-20     	; 0x14e8 <xTaskResumeAll+0xbe>
    14fc:	07 c0       	rjmp	.+14     	; 0x150c <xTaskResumeAll+0xe2>
    14fe:	f1 e0       	ldi	r31, 0x01	; 1
    1500:	df 16       	cp	r13, r31
    1502:	21 f0       	breq	.+8      	; 0x150c <xTaskResumeAll+0xe2>
    1504:	80 91 ee 09 	lds	r24, 0x09EE	; 0x8009ee <xMissedYield>
    1508:	81 30       	cpi	r24, 0x01	; 1
    150a:	39 f4       	brne	.+14     	; 0x151a <xTaskResumeAll+0xf0>
    150c:	10 92 ee 09 	sts	0x09EE, r1	; 0x8009ee <xMissedYield>
    1510:	c0 dc       	rcall	.-1664   	; 0xe92 <vPortYield>
    1512:	81 e0       	ldi	r24, 0x01	; 1
    1514:	03 c0       	rjmp	.+6      	; 0x151c <xTaskResumeAll+0xf2>
    1516:	80 e0       	ldi	r24, 0x00	; 0
    1518:	01 c0       	rjmp	.+2      	; 0x151c <xTaskResumeAll+0xf2>
    151a:	80 e0       	ldi	r24, 0x00	; 0
    151c:	0f 90       	pop	r0
    151e:	0f be       	out	0x3f, r0	; 63
    1520:	df 91       	pop	r29
    1522:	cf 91       	pop	r28
    1524:	1f 91       	pop	r17
    1526:	0f 91       	pop	r16
    1528:	ff 90       	pop	r15
    152a:	ef 90       	pop	r14
    152c:	df 90       	pop	r13
    152e:	cf 90       	pop	r12
    1530:	08 95       	ret

00001532 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1532:	cf 93       	push	r28
    1534:	df 93       	push	r29
    1536:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1538:	89 2b       	or	r24, r25
    153a:	99 f0       	breq	.+38     	; 0x1562 <vTaskDelay+0x30>
		{
			vTaskSuspendAll();
    153c:	ae de       	rcall	.-676    	; 0x129a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    153e:	80 91 f4 09 	lds	r24, 0x09F4	; 0x8009f4 <xTickCount>
    1542:	90 91 f5 09 	lds	r25, 0x09F5	; 0x8009f5 <xTickCount+0x1>
    1546:	c8 0f       	add	r28, r24
    1548:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    154a:	80 91 44 0a 	lds	r24, 0x0A44	; 0x800a44 <pxCurrentTCB>
    154e:	90 91 45 0a 	lds	r25, 0x0A45	; 0x800a45 <pxCurrentTCB+0x1>
    1552:	02 96       	adiw	r24, 0x02	; 2
    1554:	0e 94 ef 01 	call	0x3de	; 0x3de <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1558:	ce 01       	movw	r24, r28
			}
			xAlreadyYielded = xTaskResumeAll();
    155a:	4e dd       	rcall	.-1380   	; 0xff8 <prvAddCurrentTaskToDelayedList>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    155c:	66 df       	rcall	.-308    	; 0x142a <xTaskResumeAll>
    155e:	81 11       	cpse	r24, r1
		{
			portYIELD_WITHIN_API();
    1560:	01 c0       	rjmp	.+2      	; 0x1564 <vTaskDelay+0x32>
    1562:	97 dc       	rcall	.-1746   	; 0xe92 <vPortYield>
		}
	}
    1564:	df 91       	pop	r29
    1566:	cf 91       	pop	r28
    1568:	08 95       	ret

0000156a <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    156a:	0f 2e       	mov	r0, r31
    156c:	f8 ef       	ldi	r31, 0xF8	; 248
    156e:	ef 2e       	mov	r14, r31
    1570:	f9 e0       	ldi	r31, 0x09	; 9
    1572:	ff 2e       	mov	r15, r31
    1574:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1576:	c0 e2       	ldi	r28, 0x20	; 32
    1578:	da e0       	ldi	r29, 0x0A	; 10
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    157a:	80 91 f7 09 	lds	r24, 0x09F7	; 0x8009f7 <uxTasksDeleted>
    157e:	88 23       	and	r24, r24
    1580:	41 f1       	breq	.+80     	; 0x15d2 <prvIdleTask+0x68>
		{
			vTaskSuspendAll();
    1582:	8b de       	rcall	.-746    	; 0x129a <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1584:	d7 01       	movw	r26, r14
			xTaskResumeAll();
    1586:	1c 91       	ld	r17, X
    1588:	50 df       	rcall	.-352    	; 0x142a <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    158a:	11 23       	and	r17, r17
    158c:	11 f1       	breq	.+68     	; 0x15d2 <prvIdleTask+0x68>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    158e:	0f b6       	in	r0, 0x3f	; 63
    1590:	f8 94       	cli
    1592:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    1594:	d7 01       	movw	r26, r14
    1596:	15 96       	adiw	r26, 0x05	; 5
    1598:	ed 91       	ld	r30, X+
    159a:	fc 91       	ld	r31, X
    159c:	16 97       	sbiw	r26, 0x06	; 6
    159e:	06 81       	ldd	r16, Z+6	; 0x06
    15a0:	17 81       	ldd	r17, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    15a2:	c8 01       	movw	r24, r16
    15a4:	02 96       	adiw	r24, 0x02	; 2
    15a6:	0e 94 ef 01 	call	0x3de	; 0x3de <vListRemove>
					--uxCurrentNumberOfTasks;
    15aa:	80 91 f6 09 	lds	r24, 0x09F6	; 0x8009f6 <uxCurrentNumberOfTasks>
    15ae:	81 50       	subi	r24, 0x01	; 1
    15b0:	80 93 f6 09 	sts	0x09F6, r24	; 0x8009f6 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    15b4:	80 91 f7 09 	lds	r24, 0x09F7	; 0x8009f7 <uxTasksDeleted>
    15b8:	81 50       	subi	r24, 0x01	; 1
    15ba:	80 93 f7 09 	sts	0x09F7, r24	; 0x8009f7 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    15be:	0f 90       	pop	r0
    15c0:	0f be       	out	0x3f, r0	; 63
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    15c2:	f8 01       	movw	r30, r16
    15c4:	87 89       	ldd	r24, Z+23	; 0x17
    15c6:	90 8d       	ldd	r25, Z+24	; 0x18
    15c8:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <vPortFree>
		vPortFree( pxTCB );
    15cc:	c8 01       	movw	r24, r16
    15ce:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    15d2:	88 81       	ld	r24, Y
    15d4:	82 30       	cpi	r24, 0x02	; 2
			{
				taskYIELD();
    15d6:	88 f2       	brcs	.-94     	; 0x157a <prvIdleTask+0x10>
    15d8:	5c dc       	rcall	.-1864   	; 0xe92 <vPortYield>
    15da:	cf cf       	rjmp	.-98     	; 0x157a <prvIdleTask+0x10>

000015dc <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    15dc:	80 91 f0 09 	lds	r24, 0x09F0	; 0x8009f0 <uxSchedulerSuspended>
    15e0:	81 11       	cpse	r24, r1
    15e2:	13 c0       	rjmp	.+38     	; 0x160a <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    15e4:	80 91 f2 09 	lds	r24, 0x09F2	; 0x8009f2 <uxTopReadyPriority>
    15e8:	90 e0       	ldi	r25, 0x00	; 0
    15ea:	fc 01       	movw	r30, r24
    15ec:	ee 0f       	add	r30, r30
    15ee:	ff 1f       	adc	r31, r31
    15f0:	ee 0f       	add	r30, r30
    15f2:	ff 1f       	adc	r31, r31
    15f4:	ee 0f       	add	r30, r30
    15f6:	ff 1f       	adc	r31, r31
    15f8:	8e 0f       	add	r24, r30
    15fa:	9f 1f       	adc	r25, r31
    15fc:	fc 01       	movw	r30, r24
    15fe:	e0 5e       	subi	r30, 0xE0	; 224
    1600:	f5 4f       	sbci	r31, 0xF5	; 245
    1602:	80 81       	ld	r24, Z
    1604:	88 23       	and	r24, r24
    1606:	29 f0       	breq	.+10     	; 0x1612 <vTaskSwitchContext+0x36>
    1608:	1b c0       	rjmp	.+54     	; 0x1640 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    160a:	81 e0       	ldi	r24, 0x01	; 1
    160c:	80 93 ee 09 	sts	0x09EE, r24	; 0x8009ee <xMissedYield>
    1610:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1612:	80 91 f2 09 	lds	r24, 0x09F2	; 0x8009f2 <uxTopReadyPriority>
    1616:	81 50       	subi	r24, 0x01	; 1
    1618:	80 93 f2 09 	sts	0x09F2, r24	; 0x8009f2 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    161c:	80 91 f2 09 	lds	r24, 0x09F2	; 0x8009f2 <uxTopReadyPriority>
    1620:	90 e0       	ldi	r25, 0x00	; 0
    1622:	fc 01       	movw	r30, r24
    1624:	ee 0f       	add	r30, r30
    1626:	ff 1f       	adc	r31, r31
    1628:	ee 0f       	add	r30, r30
    162a:	ff 1f       	adc	r31, r31
    162c:	ee 0f       	add	r30, r30
    162e:	ff 1f       	adc	r31, r31
    1630:	8e 0f       	add	r24, r30
    1632:	9f 1f       	adc	r25, r31
    1634:	fc 01       	movw	r30, r24
    1636:	e0 5e       	subi	r30, 0xE0	; 224
    1638:	f5 4f       	sbci	r31, 0xF5	; 245
    163a:	80 81       	ld	r24, Z
    163c:	88 23       	and	r24, r24
    163e:	49 f3       	breq	.-46     	; 0x1612 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1640:	80 91 f2 09 	lds	r24, 0x09F2	; 0x8009f2 <uxTopReadyPriority>
    1644:	90 e0       	ldi	r25, 0x00	; 0
    1646:	9c 01       	movw	r18, r24
    1648:	22 0f       	add	r18, r18
    164a:	33 1f       	adc	r19, r19
    164c:	22 0f       	add	r18, r18
    164e:	33 1f       	adc	r19, r19
    1650:	22 0f       	add	r18, r18
    1652:	33 1f       	adc	r19, r19
    1654:	28 0f       	add	r18, r24
    1656:	39 1f       	adc	r19, r25
    1658:	d9 01       	movw	r26, r18
    165a:	a0 5e       	subi	r26, 0xE0	; 224
    165c:	b5 4f       	sbci	r27, 0xF5	; 245
    165e:	11 96       	adiw	r26, 0x01	; 1
    1660:	ed 91       	ld	r30, X+
    1662:	fc 91       	ld	r31, X
    1664:	12 97       	sbiw	r26, 0x02	; 2
    1666:	02 80       	ldd	r0, Z+2	; 0x02
    1668:	f3 81       	ldd	r31, Z+3	; 0x03
    166a:	e0 2d       	mov	r30, r0
    166c:	12 96       	adiw	r26, 0x02	; 2
    166e:	fc 93       	st	X, r31
    1670:	ee 93       	st	-X, r30
    1672:	11 97       	sbiw	r26, 0x01	; 1
    1674:	2d 5d       	subi	r18, 0xDD	; 221
    1676:	35 4f       	sbci	r19, 0xF5	; 245
    1678:	e2 17       	cp	r30, r18
    167a:	f3 07       	cpc	r31, r19
    167c:	29 f4       	brne	.+10     	; 0x1688 <vTaskSwitchContext+0xac>
    167e:	22 81       	ldd	r18, Z+2	; 0x02
    1680:	33 81       	ldd	r19, Z+3	; 0x03
    1682:	fd 01       	movw	r30, r26
    1684:	32 83       	std	Z+2, r19	; 0x02
    1686:	21 83       	std	Z+1, r18	; 0x01
    1688:	fc 01       	movw	r30, r24
    168a:	ee 0f       	add	r30, r30
    168c:	ff 1f       	adc	r31, r31
    168e:	ee 0f       	add	r30, r30
    1690:	ff 1f       	adc	r31, r31
    1692:	ee 0f       	add	r30, r30
    1694:	ff 1f       	adc	r31, r31
    1696:	8e 0f       	add	r24, r30
    1698:	9f 1f       	adc	r25, r31
    169a:	fc 01       	movw	r30, r24
    169c:	e0 5e       	subi	r30, 0xE0	; 224
    169e:	f5 4f       	sbci	r31, 0xF5	; 245
    16a0:	01 80       	ldd	r0, Z+1	; 0x01
    16a2:	f2 81       	ldd	r31, Z+2	; 0x02
    16a4:	e0 2d       	mov	r30, r0
    16a6:	86 81       	ldd	r24, Z+6	; 0x06
    16a8:	97 81       	ldd	r25, Z+7	; 0x07
    16aa:	90 93 45 0a 	sts	0x0A45, r25	; 0x800a45 <pxCurrentTCB+0x1>
    16ae:	80 93 44 0a 	sts	0x0A44, r24	; 0x800a44 <pxCurrentTCB>
    16b2:	08 95       	ret

000016b4 <__udivmodqi4>:
    16b4:	99 1b       	sub	r25, r25
    16b6:	79 e0       	ldi	r23, 0x09	; 9
    16b8:	04 c0       	rjmp	.+8      	; 0x16c2 <__udivmodqi4_ep>

000016ba <__udivmodqi4_loop>:
    16ba:	99 1f       	adc	r25, r25
    16bc:	96 17       	cp	r25, r22
    16be:	08 f0       	brcs	.+2      	; 0x16c2 <__udivmodqi4_ep>
    16c0:	96 1b       	sub	r25, r22

000016c2 <__udivmodqi4_ep>:
    16c2:	88 1f       	adc	r24, r24
    16c4:	7a 95       	dec	r23
    16c6:	c9 f7       	brne	.-14     	; 0x16ba <__udivmodqi4_loop>
    16c8:	80 95       	com	r24
    16ca:	08 95       	ret

000016cc <memset>:
    16cc:	dc 01       	movw	r26, r24
    16ce:	01 c0       	rjmp	.+2      	; 0x16d2 <memset+0x6>
    16d0:	6d 93       	st	X+, r22
    16d2:	41 50       	subi	r20, 0x01	; 1
    16d4:	50 40       	sbci	r21, 0x00	; 0
    16d6:	e0 f7       	brcc	.-8      	; 0x16d0 <memset+0x4>
    16d8:	08 95       	ret

000016da <strncpy>:
    16da:	fb 01       	movw	r30, r22
    16dc:	dc 01       	movw	r26, r24
    16de:	41 50       	subi	r20, 0x01	; 1
    16e0:	50 40       	sbci	r21, 0x00	; 0
    16e2:	48 f0       	brcs	.+18     	; 0x16f6 <strncpy+0x1c>
    16e4:	01 90       	ld	r0, Z+
    16e6:	0d 92       	st	X+, r0
    16e8:	00 20       	and	r0, r0
    16ea:	c9 f7       	brne	.-14     	; 0x16de <strncpy+0x4>
    16ec:	01 c0       	rjmp	.+2      	; 0x16f0 <strncpy+0x16>
    16ee:	1d 92       	st	X+, r1
    16f0:	41 50       	subi	r20, 0x01	; 1
    16f2:	50 40       	sbci	r21, 0x00	; 0
    16f4:	e0 f7       	brcc	.-8      	; 0x16ee <strncpy+0x14>
    16f6:	08 95       	ret

000016f8 <_exit>:
    16f8:	f8 94       	cli

000016fa <__stop_program>:
    16fa:	ff cf       	rjmp	.-2      	; 0x16fa <__stop_program>
