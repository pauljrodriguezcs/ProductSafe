
RemoveUser.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000de  00800100  0000191c  000019b0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000191c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000841  008001de  008001de  00001a8e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001a8e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001ac0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000250  00000000  00000000  00001b00  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000037f8  00000000  00000000  00001d50  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000125d  00000000  00000000  00005548  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001e3c  00000000  00000000  000067a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000062c  00000000  00000000  000085e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000f90  00000000  00000000  00008c10  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001d55  00000000  00000000  00009ba0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000270  00000000  00000000  0000b8f5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	35 c1       	rjmp	.+618    	; 0x26c <__ctors_end>
       2:	00 00       	nop
       4:	51 c1       	rjmp	.+674    	; 0x2a8 <__bad_interrupt>
       6:	00 00       	nop
       8:	4f c1       	rjmp	.+670    	; 0x2a8 <__bad_interrupt>
       a:	00 00       	nop
       c:	4d c1       	rjmp	.+666    	; 0x2a8 <__bad_interrupt>
       e:	00 00       	nop
      10:	4b c1       	rjmp	.+662    	; 0x2a8 <__bad_interrupt>
      12:	00 00       	nop
      14:	49 c1       	rjmp	.+658    	; 0x2a8 <__bad_interrupt>
      16:	00 00       	nop
      18:	47 c1       	rjmp	.+654    	; 0x2a8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	45 c1       	rjmp	.+650    	; 0x2a8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	43 c1       	rjmp	.+646    	; 0x2a8 <__bad_interrupt>
      22:	00 00       	nop
      24:	41 c1       	rjmp	.+642    	; 0x2a8 <__bad_interrupt>
      26:	00 00       	nop
      28:	3f c1       	rjmp	.+638    	; 0x2a8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	3d c1       	rjmp	.+634    	; 0x2a8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	3b c1       	rjmp	.+630    	; 0x2a8 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 fe 08 	jmp	0x11fc	; 0x11fc <__vector_13>
      38:	37 c1       	rjmp	.+622    	; 0x2a8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	35 c1       	rjmp	.+618    	; 0x2a8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	33 c1       	rjmp	.+614    	; 0x2a8 <__bad_interrupt>
      42:	00 00       	nop
      44:	31 c1       	rjmp	.+610    	; 0x2a8 <__bad_interrupt>
      46:	00 00       	nop
      48:	2f c1       	rjmp	.+606    	; 0x2a8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	2d c1       	rjmp	.+602    	; 0x2a8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	2b c1       	rjmp	.+598    	; 0x2a8 <__bad_interrupt>
      52:	00 00       	nop
      54:	29 c1       	rjmp	.+594    	; 0x2a8 <__bad_interrupt>
      56:	00 00       	nop
      58:	27 c1       	rjmp	.+590    	; 0x2a8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	25 c1       	rjmp	.+586    	; 0x2a8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	23 c1       	rjmp	.+582    	; 0x2a8 <__bad_interrupt>
      62:	00 00       	nop
      64:	21 c1       	rjmp	.+578    	; 0x2a8 <__bad_interrupt>
      66:	00 00       	nop
      68:	1f c1       	rjmp	.+574    	; 0x2a8 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	1d c1       	rjmp	.+570    	; 0x2a8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	1b c1       	rjmp	.+566    	; 0x2a8 <__bad_interrupt>
      72:	00 00       	nop
      74:	19 c1       	rjmp	.+562    	; 0x2a8 <__bad_interrupt>
      76:	00 00       	nop
      78:	17 c1       	rjmp	.+558    	; 0x2a8 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	15 c1       	rjmp	.+554    	; 0x2a8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	13 c1       	rjmp	.+550    	; 0x2a8 <__bad_interrupt>
      82:	00 00       	nop
      84:	11 c1       	rjmp	.+546    	; 0x2a8 <__bad_interrupt>
      86:	00 00       	nop
      88:	0f c1       	rjmp	.+542    	; 0x2a8 <__bad_interrupt>
	...

0000008c <CHARSET>:
      8c:	00 00 00 00 00 00 00 5f 00 00 00 07 00 07 00 14     ......._........
      9c:	7f 14 7f 14 24 2a 7f 2a 12 23 13 08 64 62 36 49     ....$*.*.#..db6I
      ac:	55 22 50 00 05 03 00 00 00 1c 22 41 00 00 41 22     U"P......."A..A"
      bc:	1c 00 14 08 3e 08 14 08 08 3e 08 08 00 50 30 00     ....>....>...P0.
      cc:	00 08 08 08 08 08 00 60 60 00 00 20 10 08 04 02     .......``.. ....
      dc:	3e 51 49 45 3e 00 42 7f 40 00 42 61 51 49 46 21     >QIE>.B.@.BaQIF!
      ec:	41 45 4b 31 18 14 12 7f 10 27 45 45 45 39 3c 4a     AEK1.....'EEE9<J
      fc:	49 49 30 01 71 09 05 03 36 49 49 49 36 06 49 49     II0.q...6III6.II
     10c:	29 1e 00 36 36 00 00 00 56 36 00 00 08 14 22 41     )..66...V6...."A
     11c:	00 14 14 14 14 14 00 41 22 14 08 02 01 51 09 06     .......A"....Q..
     12c:	32 49 79 41 3e 7e 11 11 11 7e 7f 49 49 49 36 3e     2IyA>~...~.III6>
     13c:	41 41 41 22 7f 41 41 22 1c 7f 49 49 49 41 7f 09     AAA".AA"..IIIA..
     14c:	09 09 01 3e 41 49 49 7a 7f 08 08 08 7f 00 41 7f     ...>AIIz......A.
     15c:	41 00 20 40 41 3f 01 7f 08 14 22 41 7f 40 40 40     A. @A?...."A.@@@
     16c:	40 7f 02 0c 02 7f 7f 04 08 10 7f 3e 41 41 41 3e     @..........>AAA>
     17c:	7f 09 09 09 06 3e 41 51 21 5e 7f 09 19 29 46 46     .....>AQ!^...)FF
     18c:	49 49 49 31 01 01 7f 01 01 3f 40 40 40 3f 1f 20     III1.....?@@@?. 
     19c:	40 20 1f 3f 40 38 40 3f 63 14 08 14 63 07 08 70     @ .?@8@?c...c..p
     1ac:	08 07 61 51 49 45 43 00 7f 41 41 00 02 04 08 10     ..aQIEC..AA.....
     1bc:	20 00 41 41 7f 00 04 02 01 02 04 40 40 40 40 40      .AA.......@@@@@
     1cc:	00 01 02 04 00 20 54 54 54 78 7f 48 44 44 38 38     ..... TTTx.HDD88
     1dc:	44 44 44 20 38 44 44 48 7f 38 54 54 54 18 08 7e     DDD 8DDH.8TTT..~
     1ec:	09 01 02 0c 52 52 52 3e 7f 08 04 04 78 00 44 7d     ....RRR>....x.D}
     1fc:	40 00 20 40 44 3d 00 7f 10 28 44 00 00 41 7f 40     @. @D=...(D..A.@
     20c:	00 7c 04 18 04 78 7c 08 04 04 78 38 44 44 44 38     .|...x|...x8DDD8
     21c:	7c 14 14 14 08 08 14 14 18 7c 7c 08 04 04 08 48     |........||....H
     22c:	54 54 54 20 04 3f 44 40 20 3c 40 40 20 7c 1c 20     TTT .?D@ <@@ |. 
     23c:	40 20 1c 3c 40 30 40 3c 44 28 10 28 44 0c 50 50     @ .<@0@<D(.(D.PP
     24c:	50 3c 44 64 54 4c 44 00 08 36 41 00 00 00 7f 00     P<DdTLD..6A.....
     25c:	00 00 41 36 08 00 10 08 08 10 08 00 00 00 00 00     ..A6............

0000026c <__ctors_end>:
     26c:	11 24       	eor	r1, r1
     26e:	1f be       	out	0x3f, r1	; 63
     270:	cf ef       	ldi	r28, 0xFF	; 255
     272:	d0 e4       	ldi	r29, 0x40	; 64
     274:	de bf       	out	0x3e, r29	; 62
     276:	cd bf       	out	0x3d, r28	; 61

00000278 <__do_copy_data>:
     278:	11 e0       	ldi	r17, 0x01	; 1
     27a:	a0 e0       	ldi	r26, 0x00	; 0
     27c:	b1 e0       	ldi	r27, 0x01	; 1
     27e:	ec e1       	ldi	r30, 0x1C	; 28
     280:	f9 e1       	ldi	r31, 0x19	; 25
     282:	00 e0       	ldi	r16, 0x00	; 0
     284:	0b bf       	out	0x3b, r16	; 59
     286:	02 c0       	rjmp	.+4      	; 0x28c <__do_copy_data+0x14>
     288:	07 90       	elpm	r0, Z+
     28a:	0d 92       	st	X+, r0
     28c:	ae 3d       	cpi	r26, 0xDE	; 222
     28e:	b1 07       	cpc	r27, r17
     290:	d9 f7       	brne	.-10     	; 0x288 <__do_copy_data+0x10>

00000292 <__do_clear_bss>:
     292:	2a e0       	ldi	r18, 0x0A	; 10
     294:	ae ed       	ldi	r26, 0xDE	; 222
     296:	b1 e0       	ldi	r27, 0x01	; 1
     298:	01 c0       	rjmp	.+2      	; 0x29c <.do_clear_bss_start>

0000029a <.do_clear_bss_loop>:
     29a:	1d 92       	st	X+, r1

0000029c <.do_clear_bss_start>:
     29c:	af 31       	cpi	r26, 0x1F	; 31
     29e:	b2 07       	cpc	r27, r18
     2a0:	e1 f7       	brne	.-8      	; 0x29a <.do_clear_bss_loop>
     2a2:	dc d4       	rcall	.+2488   	; 0xc5c <main>
     2a4:	0c 94 8c 0c 	jmp	0x1918	; 0x1918 <_exit>

000002a8 <__bad_interrupt>:
     2a8:	ab ce       	rjmp	.-682    	; 0x0 <__vectors>

000002aa <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     2aa:	cf 93       	push	r28
     2ac:	df 93       	push	r29
     2ae:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     2b0:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     2b4:	20 91 de 01 	lds	r18, 0x01DE	; 0x8001de <__data_end>
     2b8:	30 91 df 01 	lds	r19, 0x01DF	; 0x8001df <__data_end+0x1>
     2bc:	c9 01       	movw	r24, r18
     2be:	8c 0f       	add	r24, r28
     2c0:	9d 1f       	adc	r25, r29
     2c2:	8c 3d       	cpi	r24, 0xDC	; 220
     2c4:	45 e0       	ldi	r20, 0x05	; 5
     2c6:	94 07       	cpc	r25, r20
     2c8:	58 f4       	brcc	.+22     	; 0x2e0 <pvPortMalloc+0x36>
     2ca:	28 17       	cp	r18, r24
     2cc:	39 07       	cpc	r19, r25
     2ce:	58 f4       	brcc	.+22     	; 0x2e6 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     2d0:	e9 01       	movw	r28, r18
     2d2:	c0 52       	subi	r28, 0x20	; 32
     2d4:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
     2d6:	90 93 df 01 	sts	0x01DF, r25	; 0x8001df <__data_end+0x1>
     2da:	80 93 de 01 	sts	0x01DE, r24	; 0x8001de <__data_end>
     2de:	05 c0       	rjmp	.+10     	; 0x2ea <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     2e0:	c0 e0       	ldi	r28, 0x00	; 0
     2e2:	d0 e0       	ldi	r29, 0x00	; 0
     2e4:	02 c0       	rjmp	.+4      	; 0x2ea <pvPortMalloc+0x40>
     2e6:	c0 e0       	ldi	r28, 0x00	; 0
     2e8:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     2ea:	0e 94 25 0b 	call	0x164a	; 0x164a <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     2ee:	ce 01       	movw	r24, r28
     2f0:	df 91       	pop	r29
     2f2:	cf 91       	pop	r28
     2f4:	08 95       	ret

000002f6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     2f6:	08 95       	ret

000002f8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     2f8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     2fa:	03 96       	adiw	r24, 0x03	; 3
     2fc:	92 83       	std	Z+2, r25	; 0x02
     2fe:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     300:	2f ef       	ldi	r18, 0xFF	; 255
     302:	3f ef       	ldi	r19, 0xFF	; 255
     304:	34 83       	std	Z+4, r19	; 0x04
     306:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     308:	96 83       	std	Z+6, r25	; 0x06
     30a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     30c:	90 87       	std	Z+8, r25	; 0x08
     30e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     310:	10 82       	st	Z, r1
     312:	08 95       	ret

00000314 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     314:	fc 01       	movw	r30, r24
     316:	11 86       	std	Z+9, r1	; 0x09
     318:	10 86       	std	Z+8, r1	; 0x08
     31a:	08 95       	ret

0000031c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     31c:	cf 93       	push	r28
     31e:	df 93       	push	r29
     320:	fc 01       	movw	r30, r24
     322:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     324:	21 81       	ldd	r18, Z+1	; 0x01
     326:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     328:	e9 01       	movw	r28, r18
     32a:	8a 81       	ldd	r24, Y+2	; 0x02
     32c:	9b 81       	ldd	r25, Y+3	; 0x03
     32e:	13 96       	adiw	r26, 0x03	; 3
     330:	9c 93       	st	X, r25
     332:	8e 93       	st	-X, r24
     334:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     336:	81 81       	ldd	r24, Z+1	; 0x01
     338:	92 81       	ldd	r25, Z+2	; 0x02
     33a:	15 96       	adiw	r26, 0x05	; 5
     33c:	9c 93       	st	X, r25
     33e:	8e 93       	st	-X, r24
     340:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     342:	8a 81       	ldd	r24, Y+2	; 0x02
     344:	9b 81       	ldd	r25, Y+3	; 0x03
     346:	ec 01       	movw	r28, r24
     348:	7d 83       	std	Y+5, r23	; 0x05
     34a:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     34c:	e9 01       	movw	r28, r18
     34e:	7b 83       	std	Y+3, r23	; 0x03
     350:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     352:	72 83       	std	Z+2, r23	; 0x02
     354:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     356:	19 96       	adiw	r26, 0x09	; 9
     358:	fc 93       	st	X, r31
     35a:	ee 93       	st	-X, r30
     35c:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     35e:	80 81       	ld	r24, Z
     360:	8f 5f       	subi	r24, 0xFF	; 255
     362:	80 83       	st	Z, r24
}
     364:	df 91       	pop	r29
     366:	cf 91       	pop	r28
     368:	08 95       	ret

0000036a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     36a:	cf 93       	push	r28
     36c:	df 93       	push	r29
     36e:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     370:	48 81       	ld	r20, Y
     372:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     374:	4f 3f       	cpi	r20, 0xFF	; 255
     376:	2f ef       	ldi	r18, 0xFF	; 255
     378:	52 07       	cpc	r21, r18
     37a:	31 f4       	brne	.+12     	; 0x388 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     37c:	dc 01       	movw	r26, r24
     37e:	17 96       	adiw	r26, 0x07	; 7
     380:	ed 91       	ld	r30, X+
     382:	fc 91       	ld	r31, X
     384:	18 97       	sbiw	r26, 0x08	; 8
     386:	17 c0       	rjmp	.+46     	; 0x3b6 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     388:	fc 01       	movw	r30, r24
     38a:	33 96       	adiw	r30, 0x03	; 3
     38c:	dc 01       	movw	r26, r24
     38e:	15 96       	adiw	r26, 0x05	; 5
     390:	2d 91       	ld	r18, X+
     392:	3c 91       	ld	r19, X
     394:	16 97       	sbiw	r26, 0x06	; 6
     396:	d9 01       	movw	r26, r18
     398:	2d 91       	ld	r18, X+
     39a:	3c 91       	ld	r19, X
     39c:	42 17       	cp	r20, r18
     39e:	53 07       	cpc	r21, r19
     3a0:	50 f0       	brcs	.+20     	; 0x3b6 <vListInsert+0x4c>
     3a2:	02 80       	ldd	r0, Z+2	; 0x02
     3a4:	f3 81       	ldd	r31, Z+3	; 0x03
     3a6:	e0 2d       	mov	r30, r0
     3a8:	a2 81       	ldd	r26, Z+2	; 0x02
     3aa:	b3 81       	ldd	r27, Z+3	; 0x03
     3ac:	2d 91       	ld	r18, X+
     3ae:	3c 91       	ld	r19, X
     3b0:	42 17       	cp	r20, r18
     3b2:	53 07       	cpc	r21, r19
     3b4:	b0 f7       	brcc	.-20     	; 0x3a2 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     3b6:	a2 81       	ldd	r26, Z+2	; 0x02
     3b8:	b3 81       	ldd	r27, Z+3	; 0x03
     3ba:	bb 83       	std	Y+3, r27	; 0x03
     3bc:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     3be:	15 96       	adiw	r26, 0x05	; 5
     3c0:	dc 93       	st	X, r29
     3c2:	ce 93       	st	-X, r28
     3c4:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     3c6:	fd 83       	std	Y+5, r31	; 0x05
     3c8:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     3ca:	d3 83       	std	Z+3, r29	; 0x03
     3cc:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3ce:	99 87       	std	Y+9, r25	; 0x09
     3d0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     3d2:	fc 01       	movw	r30, r24
     3d4:	20 81       	ld	r18, Z
     3d6:	2f 5f       	subi	r18, 0xFF	; 255
     3d8:	20 83       	st	Z, r18
}
     3da:	df 91       	pop	r29
     3dc:	cf 91       	pop	r28
     3de:	08 95       	ret

000003e0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     3e0:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     3e2:	a2 81       	ldd	r26, Z+2	; 0x02
     3e4:	b3 81       	ldd	r27, Z+3	; 0x03
     3e6:	84 81       	ldd	r24, Z+4	; 0x04
     3e8:	95 81       	ldd	r25, Z+5	; 0x05
     3ea:	15 96       	adiw	r26, 0x05	; 5
     3ec:	9c 93       	st	X, r25
     3ee:	8e 93       	st	-X, r24
     3f0:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     3f2:	a4 81       	ldd	r26, Z+4	; 0x04
     3f4:	b5 81       	ldd	r27, Z+5	; 0x05
     3f6:	82 81       	ldd	r24, Z+2	; 0x02
     3f8:	93 81       	ldd	r25, Z+3	; 0x03
     3fa:	13 96       	adiw	r26, 0x03	; 3
     3fc:	9c 93       	st	X, r25
     3fe:	8e 93       	st	-X, r24
     400:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     402:	a0 85       	ldd	r26, Z+8	; 0x08
     404:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     406:	11 96       	adiw	r26, 0x01	; 1
     408:	8d 91       	ld	r24, X+
     40a:	9c 91       	ld	r25, X
     40c:	12 97       	sbiw	r26, 0x02	; 2
     40e:	e8 17       	cp	r30, r24
     410:	f9 07       	cpc	r31, r25
     412:	31 f4       	brne	.+12     	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     414:	84 81       	ldd	r24, Z+4	; 0x04
     416:	95 81       	ldd	r25, Z+5	; 0x05
     418:	12 96       	adiw	r26, 0x02	; 2
     41a:	9c 93       	st	X, r25
     41c:	8e 93       	st	-X, r24
     41e:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     420:	11 86       	std	Z+9, r1	; 0x09
     422:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     424:	8c 91       	ld	r24, X
     426:	81 50       	subi	r24, 0x01	; 1
     428:	8c 93       	st	X, r24
     42a:	08 95       	ret

0000042c <GetKeypadKey>:
//Parameter: None
//Returns: A keypad button press else '\0'
unsigned char GetKeypadKey() {

	// Check keys in col 1
	KEYPADPORT = 0xFE; // Set Px0 to 0; others 1
     42c:	8e ef       	ldi	r24, 0xFE	; 254
     42e:	88 b9       	out	0x08, r24	; 8
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
     430:	00 00       	nop
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '1'; }
     432:	86 b1       	in	r24, 0x06	; 6
     434:	80 95       	com	r24
     436:	84 fd       	sbrc	r24, 4
     438:	46 c0       	rjmp	.+140    	; 0x4c6 <GetKeypadKey+0x9a>
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '4'; }
     43a:	86 b1       	in	r24, 0x06	; 6
     43c:	80 95       	com	r24
     43e:	85 fd       	sbrc	r24, 5
     440:	44 c0       	rjmp	.+136    	; 0x4ca <GetKeypadKey+0x9e>
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '7'; }
     442:	86 b1       	in	r24, 0x06	; 6
     444:	80 95       	com	r24
     446:	86 fd       	sbrc	r24, 6
     448:	42 c0       	rjmp	.+132    	; 0x4ce <GetKeypadKey+0xa2>
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '*'; }
     44a:	86 b1       	in	r24, 0x06	; 6
     44c:	80 95       	com	r24
     44e:	90 e0       	ldi	r25, 0x00	; 0
     450:	88 0f       	add	r24, r24
     452:	89 2f       	mov	r24, r25
     454:	88 1f       	adc	r24, r24
     456:	99 0b       	sbc	r25, r25
     458:	91 95       	neg	r25
     45a:	89 2b       	or	r24, r25
     45c:	d1 f5       	brne	.+116    	; 0x4d2 <GetKeypadKey+0xa6>

	// Check keys in col 2
	KEYPADPORT = 0xFD;; // Set Px1 to 0; others 1
     45e:	8d ef       	ldi	r24, 0xFD	; 253
     460:	88 b9       	out	0x08, r24	; 8
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
     462:	00 00       	nop
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '2'; }
     464:	86 b1       	in	r24, 0x06	; 6
     466:	80 95       	com	r24
     468:	84 fd       	sbrc	r24, 4
     46a:	35 c0       	rjmp	.+106    	; 0x4d6 <GetKeypadKey+0xaa>
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '5'; }
     46c:	86 b1       	in	r24, 0x06	; 6
     46e:	80 95       	com	r24
     470:	85 fd       	sbrc	r24, 5
     472:	33 c0       	rjmp	.+102    	; 0x4da <GetKeypadKey+0xae>
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '8'; }
     474:	86 b1       	in	r24, 0x06	; 6
     476:	80 95       	com	r24
     478:	86 fd       	sbrc	r24, 6
     47a:	31 c0       	rjmp	.+98     	; 0x4de <GetKeypadKey+0xb2>
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '0'; }
     47c:	86 b1       	in	r24, 0x06	; 6
     47e:	80 95       	com	r24
     480:	90 e0       	ldi	r25, 0x00	; 0
     482:	88 0f       	add	r24, r24
     484:	89 2f       	mov	r24, r25
     486:	88 1f       	adc	r24, r24
     488:	99 0b       	sbc	r25, r25
     48a:	91 95       	neg	r25
     48c:	89 2b       	or	r24, r25
     48e:	49 f5       	brne	.+82     	; 0x4e2 <GetKeypadKey+0xb6>

	// Check keys in col 3
	KEYPADPORT = 0xFB;; // Set Px2 to 0; others 1
     490:	8b ef       	ldi	r24, 0xFB	; 251
     492:	88 b9       	out	0x08, r24	; 8
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
     494:	00 00       	nop
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '3'; }
     496:	86 b1       	in	r24, 0x06	; 6
     498:	80 95       	com	r24
     49a:	84 fd       	sbrc	r24, 4
     49c:	24 c0       	rjmp	.+72     	; 0x4e6 <GetKeypadKey+0xba>
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '6'; }
     49e:	86 b1       	in	r24, 0x06	; 6
     4a0:	80 95       	com	r24
     4a2:	85 fd       	sbrc	r24, 5
     4a4:	22 c0       	rjmp	.+68     	; 0x4ea <GetKeypadKey+0xbe>
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '9'; }
     4a6:	86 b1       	in	r24, 0x06	; 6
     4a8:	80 95       	com	r24
     4aa:	86 fd       	sbrc	r24, 6
     4ac:	20 c0       	rjmp	.+64     	; 0x4ee <GetKeypadKey+0xc2>
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '#'; }
     4ae:	86 b1       	in	r24, 0x06	; 6
     4b0:	80 95       	com	r24
     4b2:	90 e0       	ldi	r25, 0x00	; 0
     4b4:	88 0f       	add	r24, r24
     4b6:	89 2f       	mov	r24, r25
     4b8:	88 1f       	adc	r24, r24
     4ba:	99 0b       	sbc	r25, r25
     4bc:	91 95       	neg	r25
     4be:	89 2b       	or	r24, r25
     4c0:	c1 f4       	brne	.+48     	; 0x4f2 <GetKeypadKey+0xc6>
	
	return '\0';
     4c2:	80 e0       	ldi	r24, 0x00	; 0
     4c4:	08 95       	ret
unsigned char GetKeypadKey() {

	// Check keys in col 1
	KEYPADPORT = 0xFE; // Set Px0 to 0; others 1
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '1'; }
     4c6:	81 e3       	ldi	r24, 0x31	; 49
     4c8:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '4'; }
     4ca:	84 e3       	ldi	r24, 0x34	; 52
     4cc:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '7'; }
     4ce:	87 e3       	ldi	r24, 0x37	; 55
     4d0:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '*'; }
     4d2:	8a e2       	ldi	r24, 0x2A	; 42
     4d4:	08 95       	ret

	// Check keys in col 2
	KEYPADPORT = 0xFD;; // Set Px1 to 0; others 1
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '2'; }
     4d6:	82 e3       	ldi	r24, 0x32	; 50
     4d8:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '5'; }
     4da:	85 e3       	ldi	r24, 0x35	; 53
     4dc:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '8'; }
     4de:	88 e3       	ldi	r24, 0x38	; 56
     4e0:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '0'; }
     4e2:	80 e3       	ldi	r24, 0x30	; 48
     4e4:	08 95       	ret

	// Check keys in col 3
	KEYPADPORT = 0xFB;; // Set Px2 to 0; others 1
	asm("nop"); // add a delay to allow PORTx to stabilize before checking
	if ( GetBit(~KEYPADPIN,ROW1) ) { return '3'; }
     4e6:	83 e3       	ldi	r24, 0x33	; 51
     4e8:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW2) ) { return '6'; }
     4ea:	86 e3       	ldi	r24, 0x36	; 54
     4ec:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW3) ) { return '9'; }
     4ee:	89 e3       	ldi	r24, 0x39	; 57
     4f0:	08 95       	ret
	if ( GetBit(~KEYPADPIN,ROW4) ) { return '#'; }
     4f2:	83 e2       	ldi	r24, 0x23	; 35
	
	return '\0';
}
     4f4:	08 95       	ret

000004f6 <swap_users>:
unsigned char number_of_users = 4;
char temporary_password[9] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0'};
unsigned char password_size = 0;
unsigned char user_to_remove = 5;

void swap_users(unsigned char dest, unsigned char source){
     4f6:	af 92       	push	r10
     4f8:	bf 92       	push	r11
     4fa:	cf 92       	push	r12
     4fc:	df 92       	push	r13
     4fe:	ef 92       	push	r14
     500:	ff 92       	push	r15
     502:	0f 93       	push	r16
     504:	1f 93       	push	r17
     506:	cf 93       	push	r28
     508:	df 93       	push	r29
     50a:	cd b7       	in	r28, 0x3d	; 61
     50c:	de b7       	in	r29, 0x3e	; 62
     50e:	67 97       	sbiw	r28, 0x17	; 23
     510:	0f b6       	in	r0, 0x3f	; 63
     512:	f8 94       	cli
     514:	de bf       	out	0x3e, r29	; 62
     516:	0f be       	out	0x3f, r0	; 63
     518:	cd bf       	out	0x3d, r28	; 61
     51a:	06 2f       	mov	r16, r22
	char tempname[14] = " ";
     51c:	20 e2       	ldi	r18, 0x20	; 32
     51e:	30 e0       	ldi	r19, 0x00	; 0
     520:	3a 83       	std	Y+2, r19	; 0x02
     522:	29 83       	std	Y+1, r18	; 0x01
     524:	fe 01       	movw	r30, r28
     526:	33 96       	adiw	r30, 0x03	; 3
     528:	9c e0       	ldi	r25, 0x0C	; 12
     52a:	df 01       	movw	r26, r30
     52c:	1d 92       	st	X+, r1
     52e:	9a 95       	dec	r25
     530:	e9 f7       	brne	.-6      	; 0x52c <swap_users+0x36>
	char temppass[9] = " ";
     532:	38 8b       	std	Y+16, r19	; 0x10
     534:	2f 87       	std	Y+15, r18	; 0x0f
     536:	3e 96       	adiw	r30, 0x0e	; 14
     538:	97 e0       	ldi	r25, 0x07	; 7
     53a:	df 01       	movw	r26, r30
     53c:	1d 92       	st	X+, r1
     53e:	9a 95       	dec	r25
     540:	e9 f7       	brne	.-6      	; 0x53c <swap_users+0x46>
	unsigned int tempweight = 0;
	unsigned char tempgender = 0;
	
	strncpy(tempname,List_of_Users[dest].name,sizeof(tempname));
     542:	1a e1       	ldi	r17, 0x1A	; 26
     544:	18 9f       	mul	r17, r24
     546:	50 01       	movw	r10, r0
     548:	11 24       	eor	r1, r1
     54a:	f5 01       	movw	r30, r10
     54c:	ee 5f       	subi	r30, 0xFE	; 254
     54e:	fe 4f       	sbci	r31, 0xFE	; 254
     550:	6f 01       	movw	r12, r30
     552:	4e e0       	ldi	r20, 0x0E	; 14
     554:	50 e0       	ldi	r21, 0x00	; 0
     556:	bf 01       	movw	r22, r30
     558:	ce 01       	movw	r24, r28
     55a:	01 96       	adiw	r24, 0x01	; 1
     55c:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <strncpy>
	strncpy(List_of_Users[dest].name,List_of_Users[source].name,sizeof(List_of_Users[dest].name));
     560:	10 9f       	mul	r17, r16
     562:	80 01       	movw	r16, r0
     564:	11 24       	eor	r1, r1
     566:	c8 01       	movw	r24, r16
     568:	8e 5f       	subi	r24, 0xFE	; 254
     56a:	9e 4f       	sbci	r25, 0xFE	; 254
     56c:	7c 01       	movw	r14, r24
     56e:	4e e0       	ldi	r20, 0x0E	; 14
     570:	50 e0       	ldi	r21, 0x00	; 0
     572:	bc 01       	movw	r22, r24
     574:	c6 01       	movw	r24, r12
     576:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <strncpy>
	strncpy(List_of_Users[source].name,tempname,sizeof(List_of_Users[source].name));
     57a:	4e e0       	ldi	r20, 0x0E	; 14
     57c:	50 e0       	ldi	r21, 0x00	; 0
     57e:	be 01       	movw	r22, r28
     580:	6f 5f       	subi	r22, 0xFF	; 255
     582:	7f 4f       	sbci	r23, 0xFF	; 255
     584:	c7 01       	movw	r24, r14
     586:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <strncpy>
	
	strncpy(temppass,List_of_Users[dest].password,sizeof(temppass));
     58a:	d5 01       	movw	r26, r10
     58c:	ad 5e       	subi	r26, 0xED	; 237
     58e:	be 4f       	sbci	r27, 0xFE	; 254
     590:	5d 01       	movw	r10, r26
     592:	49 e0       	ldi	r20, 0x09	; 9
     594:	50 e0       	ldi	r21, 0x00	; 0
     596:	bd 01       	movw	r22, r26
     598:	ce 01       	movw	r24, r28
     59a:	0f 96       	adiw	r24, 0x0f	; 15
     59c:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <strncpy>
	strncpy(List_of_Users[dest].password,List_of_Users[source].password,sizeof(List_of_Users[dest].password));
     5a0:	0d 5e       	subi	r16, 0xED	; 237
     5a2:	1e 4f       	sbci	r17, 0xFE	; 254
     5a4:	49 e0       	ldi	r20, 0x09	; 9
     5a6:	50 e0       	ldi	r21, 0x00	; 0
     5a8:	b8 01       	movw	r22, r16
     5aa:	c5 01       	movw	r24, r10
     5ac:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <strncpy>
	strncpy(List_of_Users[source].password,temppass,sizeof(List_of_Users[source].password));
     5b0:	49 e0       	ldi	r20, 0x09	; 9
     5b2:	50 e0       	ldi	r21, 0x00	; 0
     5b4:	be 01       	movw	r22, r28
     5b6:	61 5f       	subi	r22, 0xF1	; 241
     5b8:	7f 4f       	sbci	r23, 0xFF	; 255
     5ba:	c8 01       	movw	r24, r16
     5bc:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <strncpy>
	
	tempweight = List_of_Users[dest].weight;
     5c0:	f6 01       	movw	r30, r12
     5c2:	86 85       	ldd	r24, Z+14	; 0x0e
     5c4:	97 85       	ldd	r25, Z+15	; 0x0f
	List_of_Users[dest].weight = List_of_Users[source].weight;
     5c6:	d7 01       	movw	r26, r14
     5c8:	1e 96       	adiw	r26, 0x0e	; 14
     5ca:	2d 91       	ld	r18, X+
     5cc:	3c 91       	ld	r19, X
     5ce:	1f 97       	sbiw	r26, 0x0f	; 15
     5d0:	37 87       	std	Z+15, r19	; 0x0f
     5d2:	26 87       	std	Z+14, r18	; 0x0e
	List_of_Users[source].weight = tempweight;
     5d4:	1f 96       	adiw	r26, 0x0f	; 15
     5d6:	9c 93       	st	X, r25
     5d8:	8e 93       	st	-X, r24
     5da:	1e 97       	sbiw	r26, 0x0e	; 14
	
	tempgender = List_of_Users[dest].gender;
     5dc:	80 89       	ldd	r24, Z+16	; 0x10
	List_of_Users[dest].gender = List_of_Users[source].gender;
     5de:	50 96       	adiw	r26, 0x10	; 16
     5e0:	9c 91       	ld	r25, X
     5e2:	50 97       	sbiw	r26, 0x10	; 16
     5e4:	90 8b       	std	Z+16, r25	; 0x10
	List_of_Users[source].gender = tempgender;
     5e6:	50 96       	adiw	r26, 0x10	; 16
     5e8:	8c 93       	st	X, r24
}
     5ea:	67 96       	adiw	r28, 0x17	; 23
     5ec:	0f b6       	in	r0, 0x3f	; 63
     5ee:	f8 94       	cli
     5f0:	de bf       	out	0x3e, r29	; 62
     5f2:	0f be       	out	0x3f, r0	; 63
     5f4:	cd bf       	out	0x3d, r28	; 61
     5f6:	df 91       	pop	r29
     5f8:	cf 91       	pop	r28
     5fa:	1f 91       	pop	r17
     5fc:	0f 91       	pop	r16
     5fe:	ff 90       	pop	r15
     600:	ef 90       	pop	r14
     602:	df 90       	pop	r13
     604:	cf 90       	pop	r12
     606:	bf 90       	pop	r11
     608:	af 90       	pop	r10
     60a:	08 95       	ret

0000060c <password_verification>:

unsigned char password_verification(){
	for(unsigned char i = 0; i < 8; ++i){
		if(List_of_Users[user_to_remove].password[i] != temporary_password[i]){
     60c:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <__data_start>
     610:	8a e1       	ldi	r24, 0x1A	; 26
     612:	e8 9f       	mul	r30, r24
     614:	d0 01       	movw	r26, r0
     616:	11 24       	eor	r1, r1
     618:	ae 5f       	subi	r26, 0xFE	; 254
     61a:	be 4f       	sbci	r27, 0xFE	; 254
     61c:	51 96       	adiw	r26, 0x11	; 17
     61e:	9c 91       	ld	r25, X
     620:	80 91 bd 07 	lds	r24, 0x07BD	; 0x8007bd <temporary_password>
     624:	98 13       	cpse	r25, r24
     626:	13 c0       	rjmp	.+38     	; 0x64e <password_verification+0x42>
     628:	8a e1       	ldi	r24, 0x1A	; 26
     62a:	e8 9f       	mul	r30, r24
     62c:	f0 01       	movw	r30, r0
     62e:	11 24       	eor	r1, r1
     630:	ec 5e       	subi	r30, 0xEC	; 236
     632:	fe 4f       	sbci	r31, 0xFE	; 254
     634:	ae eb       	ldi	r26, 0xBE	; 190
     636:	b7 e0       	ldi	r27, 0x07	; 7
     638:	25 ec       	ldi	r18, 0xC5	; 197
     63a:	37 e0       	ldi	r19, 0x07	; 7
     63c:	91 91       	ld	r25, Z+
     63e:	8d 91       	ld	r24, X+
     640:	98 13       	cpse	r25, r24
     642:	07 c0       	rjmp	.+14     	; 0x652 <password_verification+0x46>
	List_of_Users[dest].gender = List_of_Users[source].gender;
	List_of_Users[source].gender = tempgender;
}

unsigned char password_verification(){
	for(unsigned char i = 0; i < 8; ++i){
     644:	a2 17       	cp	r26, r18
     646:	b3 07       	cpc	r27, r19
     648:	c9 f7       	brne	.-14     	; 0x63c <password_verification+0x30>
		if(List_of_Users[user_to_remove].password[i] != temporary_password[i]){
			return 0;
		}
	}
	
	return 1;
     64a:	81 e0       	ldi	r24, 0x01	; 1
     64c:	08 95       	ret
}

unsigned char password_verification(){
	for(unsigned char i = 0; i < 8; ++i){
		if(List_of_Users[user_to_remove].password[i] != temporary_password[i]){
			return 0;
     64e:	80 e0       	ldi	r24, 0x00	; 0
     650:	08 95       	ret
     652:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	
	return 1;
}
     654:	08 95       	ret

00000656 <removeusers_intro>:

void removeusers_intro(){
	nokia_lcd_clear();
     656:	67 d3       	rcall	.+1742   	; 0xd26 <nokia_lcd_clear>
	if(number_of_users == 1){
     658:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <number_of_users>
     65c:	81 30       	cpi	r24, 0x01	; 1
     65e:	89 f4       	brne	.+34     	; 0x682 <removeusers_intro+0x2c>
		nokia_lcd_write_string("Select User",1);
     660:	61 e0       	ldi	r22, 0x01	; 1
     662:	8c e6       	ldi	r24, 0x6C	; 108
     664:	91 e0       	ldi	r25, 0x01	; 1
     666:	45 d4       	rcall	.+2186   	; 0xef2 <nokia_lcd_write_string>
		nokia_lcd_set_cursor(0,10);
     668:	6a e0       	ldi	r22, 0x0A	; 10
     66a:	80 e0       	ldi	r24, 0x00	; 0
     66c:	54 d4       	rcall	.+2216   	; 0xf16 <nokia_lcd_set_cursor>
		nokia_lcd_write_string("1: ",1);
     66e:	61 e0       	ldi	r22, 0x01	; 1
     670:	88 e7       	ldi	r24, 0x78	; 120
     672:	91 e0       	ldi	r25, 0x01	; 1
     674:	3e d4       	rcall	.+2172   	; 0xef2 <nokia_lcd_write_string>
		nokia_lcd_write_string(List_of_Users[0].name,1);
     676:	61 e0       	ldi	r22, 0x01	; 1
     678:	82 e0       	ldi	r24, 0x02	; 2
     67a:	91 e0       	ldi	r25, 0x01	; 1
     67c:	3a d4       	rcall	.+2164   	; 0xef2 <nokia_lcd_write_string>
		nokia_lcd_render();
     67e:	50 c4       	rjmp	.+2208   	; 0xf20 <nokia_lcd_render>
     680:	08 95       	ret
	}
	
	else if(number_of_users == 2){
     682:	82 30       	cpi	r24, 0x02	; 2
     684:	e1 f4       	brne	.+56     	; 0x6be <removeusers_intro+0x68>
		nokia_lcd_write_string("Select User",1);
     686:	61 e0       	ldi	r22, 0x01	; 1
     688:	8c e6       	ldi	r24, 0x6C	; 108
     68a:	91 e0       	ldi	r25, 0x01	; 1
     68c:	32 d4       	rcall	.+2148   	; 0xef2 <nokia_lcd_write_string>
		nokia_lcd_set_cursor(0,10);
     68e:	6a e0       	ldi	r22, 0x0A	; 10
     690:	80 e0       	ldi	r24, 0x00	; 0
     692:	41 d4       	rcall	.+2178   	; 0xf16 <nokia_lcd_set_cursor>
		nokia_lcd_write_string("1: ",1);
     694:	61 e0       	ldi	r22, 0x01	; 1
     696:	88 e7       	ldi	r24, 0x78	; 120
     698:	91 e0       	ldi	r25, 0x01	; 1
     69a:	2b d4       	rcall	.+2134   	; 0xef2 <nokia_lcd_write_string>
		nokia_lcd_write_string(List_of_Users[0].name,1);
     69c:	61 e0       	ldi	r22, 0x01	; 1
     69e:	82 e0       	ldi	r24, 0x02	; 2
     6a0:	91 e0       	ldi	r25, 0x01	; 1
     6a2:	27 d4       	rcall	.+2126   	; 0xef2 <nokia_lcd_write_string>
		nokia_lcd_set_cursor(0,20);
     6a4:	64 e1       	ldi	r22, 0x14	; 20
     6a6:	80 e0       	ldi	r24, 0x00	; 0
		nokia_lcd_write_string("2: ",1);
     6a8:	36 d4       	rcall	.+2156   	; 0xf16 <nokia_lcd_set_cursor>
     6aa:	61 e0       	ldi	r22, 0x01	; 1
     6ac:	8c e7       	ldi	r24, 0x7C	; 124
     6ae:	91 e0       	ldi	r25, 0x01	; 1
		nokia_lcd_write_string(List_of_Users[1].name,1);
     6b0:	20 d4       	rcall	.+2112   	; 0xef2 <nokia_lcd_write_string>
     6b2:	61 e0       	ldi	r22, 0x01	; 1
     6b4:	8c e1       	ldi	r24, 0x1C	; 28
     6b6:	91 e0       	ldi	r25, 0x01	; 1
		nokia_lcd_render();
     6b8:	1c d4       	rcall	.+2104   	; 0xef2 <nokia_lcd_write_string>
     6ba:	32 c4       	rjmp	.+2148   	; 0xf20 <nokia_lcd_render>
	}
	
	else if(number_of_users == 3){
     6bc:	08 95       	ret
     6be:	83 30       	cpi	r24, 0x03	; 3
		nokia_lcd_write_string("Select User",1);
     6c0:	39 f5       	brne	.+78     	; 0x710 <removeusers_intro+0xba>
     6c2:	61 e0       	ldi	r22, 0x01	; 1
     6c4:	8c e6       	ldi	r24, 0x6C	; 108
		nokia_lcd_set_cursor(0,10);
     6c6:	91 e0       	ldi	r25, 0x01	; 1
     6c8:	14 d4       	rcall	.+2088   	; 0xef2 <nokia_lcd_write_string>
     6ca:	6a e0       	ldi	r22, 0x0A	; 10
		nokia_lcd_write_string("1: ",1);
     6cc:	80 e0       	ldi	r24, 0x00	; 0
     6ce:	23 d4       	rcall	.+2118   	; 0xf16 <nokia_lcd_set_cursor>
     6d0:	61 e0       	ldi	r22, 0x01	; 1
     6d2:	88 e7       	ldi	r24, 0x78	; 120
		nokia_lcd_write_string(List_of_Users[0].name,1);
     6d4:	91 e0       	ldi	r25, 0x01	; 1
     6d6:	0d d4       	rcall	.+2074   	; 0xef2 <nokia_lcd_write_string>
     6d8:	61 e0       	ldi	r22, 0x01	; 1
     6da:	82 e0       	ldi	r24, 0x02	; 2
		nokia_lcd_set_cursor(0,20);
     6dc:	91 e0       	ldi	r25, 0x01	; 1
     6de:	09 d4       	rcall	.+2066   	; 0xef2 <nokia_lcd_write_string>
     6e0:	64 e1       	ldi	r22, 0x14	; 20
		nokia_lcd_write_string("2: ",1);
     6e2:	80 e0       	ldi	r24, 0x00	; 0
     6e4:	18 d4       	rcall	.+2096   	; 0xf16 <nokia_lcd_set_cursor>
     6e6:	61 e0       	ldi	r22, 0x01	; 1
     6e8:	8c e7       	ldi	r24, 0x7C	; 124
		nokia_lcd_write_string(List_of_Users[1].name,1);
     6ea:	91 e0       	ldi	r25, 0x01	; 1
     6ec:	02 d4       	rcall	.+2052   	; 0xef2 <nokia_lcd_write_string>
     6ee:	61 e0       	ldi	r22, 0x01	; 1
     6f0:	8c e1       	ldi	r24, 0x1C	; 28
		nokia_lcd_set_cursor(0,30);
     6f2:	91 e0       	ldi	r25, 0x01	; 1
     6f4:	fe d3       	rcall	.+2044   	; 0xef2 <nokia_lcd_write_string>
     6f6:	6e e1       	ldi	r22, 0x1E	; 30
		nokia_lcd_write_string("3: ",1);
     6f8:	80 e0       	ldi	r24, 0x00	; 0
     6fa:	0d d4       	rcall	.+2074   	; 0xf16 <nokia_lcd_set_cursor>
     6fc:	61 e0       	ldi	r22, 0x01	; 1
     6fe:	80 e8       	ldi	r24, 0x80	; 128
		nokia_lcd_write_string(List_of_Users[2].name,1);
     700:	91 e0       	ldi	r25, 0x01	; 1
     702:	f7 d3       	rcall	.+2030   	; 0xef2 <nokia_lcd_write_string>
     704:	61 e0       	ldi	r22, 0x01	; 1
		nokia_lcd_render();
     706:	86 e3       	ldi	r24, 0x36	; 54
     708:	91 e0       	ldi	r25, 0x01	; 1
	}
	
	else if(number_of_users == 4){
     70a:	f3 d3       	rcall	.+2022   	; 0xef2 <nokia_lcd_write_string>
     70c:	09 c4       	rjmp	.+2066   	; 0xf20 <nokia_lcd_render>
     70e:	08 95       	ret
		nokia_lcd_write_string("Select User",1);
     710:	84 30       	cpi	r24, 0x04	; 4
     712:	09 f0       	breq	.+2      	; 0x716 <removeusers_intro+0xc0>
     714:	32 c0       	rjmp	.+100    	; 0x77a <removeusers_intro+0x124>
		nokia_lcd_set_cursor(0,10);
     716:	61 e0       	ldi	r22, 0x01	; 1
     718:	8c e6       	ldi	r24, 0x6C	; 108
     71a:	91 e0       	ldi	r25, 0x01	; 1
		nokia_lcd_write_string("1: ",1);
     71c:	ea d3       	rcall	.+2004   	; 0xef2 <nokia_lcd_write_string>
     71e:	6a e0       	ldi	r22, 0x0A	; 10
     720:	80 e0       	ldi	r24, 0x00	; 0
     722:	f9 d3       	rcall	.+2034   	; 0xf16 <nokia_lcd_set_cursor>
		nokia_lcd_write_string(List_of_Users[0].name,1);
     724:	61 e0       	ldi	r22, 0x01	; 1
     726:	88 e7       	ldi	r24, 0x78	; 120
     728:	91 e0       	ldi	r25, 0x01	; 1
     72a:	e3 d3       	rcall	.+1990   	; 0xef2 <nokia_lcd_write_string>
		nokia_lcd_set_cursor(0,20);
     72c:	61 e0       	ldi	r22, 0x01	; 1
     72e:	82 e0       	ldi	r24, 0x02	; 2
     730:	91 e0       	ldi	r25, 0x01	; 1
		nokia_lcd_write_string("2: ",1);
     732:	df d3       	rcall	.+1982   	; 0xef2 <nokia_lcd_write_string>
     734:	64 e1       	ldi	r22, 0x14	; 20
     736:	80 e0       	ldi	r24, 0x00	; 0
     738:	ee d3       	rcall	.+2012   	; 0xf16 <nokia_lcd_set_cursor>
		nokia_lcd_write_string(List_of_Users[1].name,1);
     73a:	61 e0       	ldi	r22, 0x01	; 1
     73c:	8c e7       	ldi	r24, 0x7C	; 124
     73e:	91 e0       	ldi	r25, 0x01	; 1
		nokia_lcd_set_cursor(0,30);
     740:	d8 d3       	rcall	.+1968   	; 0xef2 <nokia_lcd_write_string>
     742:	61 e0       	ldi	r22, 0x01	; 1
     744:	8c e1       	ldi	r24, 0x1C	; 28
     746:	91 e0       	ldi	r25, 0x01	; 1
		nokia_lcd_write_string("3: ",1);
     748:	d4 d3       	rcall	.+1960   	; 0xef2 <nokia_lcd_write_string>
     74a:	6e e1       	ldi	r22, 0x1E	; 30
     74c:	80 e0       	ldi	r24, 0x00	; 0
     74e:	e3 d3       	rcall	.+1990   	; 0xf16 <nokia_lcd_set_cursor>
     750:	61 e0       	ldi	r22, 0x01	; 1
		nokia_lcd_write_string(List_of_Users[2].name,1);
     752:	80 e8       	ldi	r24, 0x80	; 128
     754:	91 e0       	ldi	r25, 0x01	; 1
     756:	cd d3       	rcall	.+1946   	; 0xef2 <nokia_lcd_write_string>
     758:	61 e0       	ldi	r22, 0x01	; 1
     75a:	86 e3       	ldi	r24, 0x36	; 54
		nokia_lcd_set_cursor(0,40);
     75c:	91 e0       	ldi	r25, 0x01	; 1
     75e:	c9 d3       	rcall	.+1938   	; 0xef2 <nokia_lcd_write_string>
     760:	68 e2       	ldi	r22, 0x28	; 40
     762:	80 e0       	ldi	r24, 0x00	; 0
		nokia_lcd_write_string("4: ",1);
     764:	d8 d3       	rcall	.+1968   	; 0xf16 <nokia_lcd_set_cursor>
     766:	61 e0       	ldi	r22, 0x01	; 1
     768:	84 e8       	ldi	r24, 0x84	; 132
     76a:	91 e0       	ldi	r25, 0x01	; 1
     76c:	c2 d3       	rcall	.+1924   	; 0xef2 <nokia_lcd_write_string>
		nokia_lcd_write_string(List_of_Users[3].name,1);
     76e:	61 e0       	ldi	r22, 0x01	; 1
     770:	80 e5       	ldi	r24, 0x50	; 80
     772:	91 e0       	ldi	r25, 0x01	; 1
     774:	be d3       	rcall	.+1916   	; 0xef2 <nokia_lcd_write_string>
     776:	d4 c3       	rjmp	.+1960   	; 0xf20 <nokia_lcd_render>
		nokia_lcd_render();
     778:	08 95       	ret
     77a:	61 e0       	ldi	r22, 0x01	; 1
     77c:	88 e8       	ldi	r24, 0x88	; 136
	}
	
	else{
		nokia_lcd_write_string("No Users!",1);
     77e:	91 e0       	ldi	r25, 0x01	; 1
     780:	b8 d3       	rcall	.+1904   	; 0xef2 <nokia_lcd_write_string>
     782:	ce c3       	rjmp	.+1948   	; 0xf20 <nokia_lcd_render>
     784:	08 95       	ret

00000786 <RemoveUsers_Init>:
     786:	81 e0       	ldi	r24, 0x01	; 1
		nokia_lcd_render();
     788:	80 93 c9 07 	sts	0x07C9, r24	; 0x8007c9 <removeusers_flag>
     78c:	10 92 1e 0a 	sts	0x0A1E, r1	; 0x800a1e <removeusers>

enum RemoveUsers {removeusers_init, removeuser_select, removeuser_password, removeuser_confirm} removeusers;

void RemoveUsers_Init(){
	removeusers_flag = 1;
	removeusers = removeusers_init;
     790:	08 95       	ret

00000792 <RemoveUsers_Tick>:
}

void RemoveUsers_Tick(){
     792:	ff 92       	push	r15
     794:	0f 93       	push	r16
     796:	1f 93       	push	r17
     798:	cf 93       	push	r28
     79a:	df 93       	push	r29
	//Actions
	switch(removeusers){
     79c:	80 91 1e 0a 	lds	r24, 0x0A1E	; 0x800a1e <removeusers>
     7a0:	82 30       	cpi	r24, 0x02	; 2
     7a2:	51 f1       	breq	.+84     	; 0x7f8 <RemoveUsers_Tick+0x66>
     7a4:	83 30       	cpi	r24, 0x03	; 3
     7a6:	09 f4       	brne	.+2      	; 0x7aa <RemoveUsers_Tick+0x18>
     7a8:	e7 c0       	rjmp	.+462    	; 0x978 <RemoveUsers_Tick+0x1e6>
     7aa:	81 30       	cpi	r24, 0x01	; 1
     7ac:	09 f0       	breq	.+2      	; 0x7b0 <RemoveUsers_Tick+0x1e>
     7ae:	f7 c0       	rjmp	.+494    	; 0x99e <RemoveUsers_Tick+0x20c>
     7b0:	06 c0       	rjmp	.+12     	; 0x7be <RemoveUsers_Tick+0x2c>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     7b2:	8f e4       	ldi	r24, 0x4F	; 79
     7b4:	93 ec       	ldi	r25, 0xC3	; 195
     7b6:	01 97       	sbiw	r24, 0x01	; 1
     7b8:	f1 f7       	brne	.-4      	; 0x7b6 <RemoveUsers_Tick+0x24>
     7ba:	00 c0       	rjmp	.+0      	; 0x7bc <RemoveUsers_Tick+0x2a>
     7bc:	00 00       	nop
		case removeusers_init:
			break;
			
		case removeuser_select:
			while((removeuser_selection = GetKeypadKey()) == '\0'){ _delay_ms(200); }
     7be:	36 de       	rcall	.-916    	; 0x42c <GetKeypadKey>
     7c0:	80 93 c8 07 	sts	0x07C8, r24	; 0x8007c8 <removeuser_selection>
     7c4:	88 23       	and	r24, r24
     7c6:	a9 f3       	breq	.-22     	; 0x7b2 <RemoveUsers_Tick+0x20>
     7c8:	06 c0       	rjmp	.+12     	; 0x7d6 <RemoveUsers_Tick+0x44>
     7ca:	ef e4       	ldi	r30, 0x4F	; 79
     7cc:	f3 ec       	ldi	r31, 0xC3	; 195
     7ce:	31 97       	sbiw	r30, 0x01	; 1
     7d0:	f1 f7       	brne	.-4      	; 0x7ce <RemoveUsers_Tick+0x3c>
     7d2:	00 c0       	rjmp	.+0      	; 0x7d4 <RemoveUsers_Tick+0x42>
			while((removeuser_prev_selection = GetKeypadKey()) == removeuser_selection){ _delay_ms(200); }
     7d4:	00 00       	nop
     7d6:	2a de       	rcall	.-940    	; 0x42c <GetKeypadKey>
     7d8:	80 93 c7 07 	sts	0x07C7, r24	; 0x8007c7 <removeuser_prev_selection>
     7dc:	90 91 c8 07 	lds	r25, 0x07C8	; 0x8007c8 <removeuser_selection>
     7e0:	89 17       	cp	r24, r25
     7e2:	99 f3       	breq	.-26     	; 0x7ca <RemoveUsers_Tick+0x38>
			
			removeuser_selection = removeuser_selection - '1';
     7e4:	91 53       	subi	r25, 0x31	; 49
     7e6:	90 93 c8 07 	sts	0x07C8, r25	; 0x8007c8 <removeuser_selection>
					
			break;
     7ea:	d9 c0       	rjmp	.+434    	; 0x99e <RemoveUsers_Tick+0x20c>
     7ec:	8f e4       	ldi	r24, 0x4F	; 79
     7ee:	93 ec       	ldi	r25, 0xC3	; 195
     7f0:	01 97       	sbiw	r24, 0x01	; 1
     7f2:	f1 f7       	brne	.-4      	; 0x7f0 <RemoveUsers_Tick+0x5e>
     7f4:	00 c0       	rjmp	.+0      	; 0x7f6 <RemoveUsers_Tick+0x64>
		
		case removeuser_password:
			while((removeuser_selection = GetKeypadKey()) == '\0'){ _delay_ms(200); }
     7f6:	00 00       	nop
     7f8:	19 de       	rcall	.-974    	; 0x42c <GetKeypadKey>
     7fa:	80 93 c8 07 	sts	0x07C8, r24	; 0x8007c8 <removeuser_selection>
     7fe:	88 23       	and	r24, r24
     800:	a9 f3       	breq	.-22     	; 0x7ec <RemoveUsers_Tick+0x5a>
     802:	06 c0       	rjmp	.+12     	; 0x810 <RemoveUsers_Tick+0x7e>
     804:	ef e4       	ldi	r30, 0x4F	; 79
     806:	f3 ec       	ldi	r31, 0xC3	; 195
     808:	31 97       	sbiw	r30, 0x01	; 1
     80a:	f1 f7       	brne	.-4      	; 0x808 <RemoveUsers_Tick+0x76>
     80c:	00 c0       	rjmp	.+0      	; 0x80e <RemoveUsers_Tick+0x7c>
			while((removeuser_prev_selection = GetKeypadKey()) == removeuser_selection){ _delay_ms(200); }
     80e:	00 00       	nop
     810:	0d de       	rcall	.-998    	; 0x42c <GetKeypadKey>
     812:	80 93 c7 07 	sts	0x07C7, r24	; 0x8007c7 <removeuser_prev_selection>
     816:	90 91 c8 07 	lds	r25, 0x07C8	; 0x8007c8 <removeuser_selection>
     81a:	89 17       	cp	r24, r25
     81c:	99 f3       	breq	.-26     	; 0x804 <RemoveUsers_Tick+0x72>
     81e:	c5 ec       	ldi	r28, 0xC5	; 197
     820:	d7 e0       	ldi	r29, 0x07	; 7
				if(removeuser_selection == '*'){
					password_size = 0;
					for(unsigned char i = 0; i < 8; ++i){
						temporary_password[i] = '\0';
					}
					temporary_password[0] = '*';
     822:	0d eb       	ldi	r16, 0xBD	; 189
     824:	17 e0       	ldi	r17, 0x07	; 7
     826:	0f 2e       	mov	r0, r31
     828:	fa e2       	ldi	r31, 0x2A	; 42
     82a:	ff 2e       	mov	r15, r31
     82c:	f0 2d       	mov	r31, r0
     82e:	75 c0       	rjmp	.+234    	; 0x91a <RemoveUsers_Tick+0x188>
		case removeuser_password:
			while((removeuser_selection = GetKeypadKey()) == '\0'){ _delay_ms(200); }
			while((removeuser_prev_selection = GetKeypadKey()) == removeuser_selection){ _delay_ms(200); }
			
			while(removeuser_selection != '#'){
				if(removeuser_selection != '\0' && removeuser_selection != '*'){
     830:	88 23       	and	r24, r24
     832:	09 f4       	brne	.+2      	; 0x836 <RemoveUsers_Tick+0xa4>
     834:	5f c0       	rjmp	.+190    	; 0x8f4 <RemoveUsers_Tick+0x162>
     836:	8a 32       	cpi	r24, 0x2A	; 42
     838:	a1 f1       	breq	.+104    	; 0x8a2 <RemoveUsers_Tick+0x110>
					if(password_size < 8){
     83a:	20 91 bc 07 	lds	r18, 0x07BC	; 0x8007bc <password_size>
     83e:	28 30       	cpi	r18, 0x08	; 8
     840:	08 f0       	brcs	.+2      	; 0x844 <RemoveUsers_Tick+0xb2>
     842:	58 c0       	rjmp	.+176    	; 0x8f4 <RemoveUsers_Tick+0x162>
						temporary_password[password_size] = removeuser_selection;
     844:	30 e0       	ldi	r19, 0x00	; 0
     846:	f9 01       	movw	r30, r18
     848:	e3 54       	subi	r30, 0x43	; 67
     84a:	f8 4f       	sbci	r31, 0xF8	; 248
     84c:	80 83       	st	Z, r24
						if(password_size + 1 < 8){
     84e:	2f 5f       	subi	r18, 0xFF	; 255
     850:	3f 4f       	sbci	r19, 0xFF	; 255
     852:	28 30       	cpi	r18, 0x08	; 8
     854:	31 05       	cpc	r19, r1
     856:	24 f4       	brge	.+8      	; 0x860 <RemoveUsers_Tick+0xce>
							temporary_password[password_size + 1] = '*';
     858:	f9 01       	movw	r30, r18
     85a:	e3 54       	subi	r30, 0x43	; 67
     85c:	f8 4f       	sbci	r31, 0xF8	; 248
						}
						nokia_lcd_clear();
     85e:	f0 82       	st	Z, r15
						nokia_lcd_write_string("Enter",1);
     860:	62 d2       	rcall	.+1220   	; 0xd26 <nokia_lcd_clear>
     862:	61 e0       	ldi	r22, 0x01	; 1
     864:	82 e9       	ldi	r24, 0x92	; 146
     866:	91 e0       	ldi	r25, 0x01	; 1
						nokia_lcd_set_cursor(0,10);
     868:	44 d3       	rcall	.+1672   	; 0xef2 <nokia_lcd_write_string>
     86a:	6a e0       	ldi	r22, 0x0A	; 10
     86c:	80 e0       	ldi	r24, 0x00	; 0
						nokia_lcd_write_string("Password: ",1);
     86e:	53 d3       	rcall	.+1702   	; 0xf16 <nokia_lcd_set_cursor>
     870:	61 e0       	ldi	r22, 0x01	; 1
     872:	88 e9       	ldi	r24, 0x98	; 152
     874:	91 e0       	ldi	r25, 0x01	; 1
						nokia_lcd_write_char(removeuser_password_fails + '0',1);
     876:	3d d3       	rcall	.+1658   	; 0xef2 <nokia_lcd_write_string>
     878:	80 91 c6 07 	lds	r24, 0x07C6	; 0x8007c6 <removeuser_password_fails>
     87c:	61 e0       	ldi	r22, 0x01	; 1
						nokia_lcd_set_cursor(0,20);
     87e:	80 5d       	subi	r24, 0xD0	; 208
     880:	8e d2       	rcall	.+1308   	; 0xd9e <nokia_lcd_write_char>
     882:	64 e1       	ldi	r22, 0x14	; 20
     884:	80 e0       	ldi	r24, 0x00	; 0
						nokia_lcd_write_string(temporary_password,1);
     886:	47 d3       	rcall	.+1678   	; 0xf16 <nokia_lcd_set_cursor>
     888:	61 e0       	ldi	r22, 0x01	; 1
     88a:	c8 01       	movw	r24, r16
     88c:	32 d3       	rcall	.+1636   	; 0xef2 <nokia_lcd_write_string>
						nokia_lcd_render();
     88e:	48 d3       	rcall	.+1680   	; 0xf20 <nokia_lcd_render>
     890:	80 91 bc 07 	lds	r24, 0x07BC	; 0x8007bc <password_size>
						
						++password_size;
     894:	8f 5f       	subi	r24, 0xFF	; 255
     896:	80 93 bc 07 	sts	0x07BC, r24	; 0x8007bc <password_size>
     89a:	80 91 c8 07 	lds	r24, 0x07C8	; 0x8007c8 <removeuser_selection>
					}
				}
				
				if(removeuser_selection == '*'){
     89e:	8a 32       	cpi	r24, 0x2A	; 42
     8a0:	49 f5       	brne	.+82     	; 0x8f4 <RemoveUsers_Tick+0x162>
					password_size = 0;
     8a2:	10 92 bc 07 	sts	0x07BC, r1	; 0x8007bc <password_size>
     8a6:	ed eb       	ldi	r30, 0xBD	; 189
					for(unsigned char i = 0; i < 8; ++i){
						temporary_password[i] = '\0';
     8a8:	f7 e0       	ldi	r31, 0x07	; 7
					}
				}
				
				if(removeuser_selection == '*'){
					password_size = 0;
					for(unsigned char i = 0; i < 8; ++i){
     8aa:	11 92       	st	Z+, r1
     8ac:	ec 17       	cp	r30, r28
						temporary_password[i] = '\0';
					}
					temporary_password[0] = '*';
     8ae:	fd 07       	cpc	r31, r29
					nokia_lcd_clear();
     8b0:	e1 f7       	brne	.-8      	; 0x8aa <RemoveUsers_Tick+0x118>
     8b2:	f8 01       	movw	r30, r16
					nokia_lcd_write_string("Enter",1);
     8b4:	f0 82       	st	Z, r15
     8b6:	37 d2       	rcall	.+1134   	; 0xd26 <nokia_lcd_clear>
     8b8:	61 e0       	ldi	r22, 0x01	; 1
     8ba:	82 e9       	ldi	r24, 0x92	; 146
					nokia_lcd_set_cursor(0,10);
     8bc:	91 e0       	ldi	r25, 0x01	; 1
     8be:	19 d3       	rcall	.+1586   	; 0xef2 <nokia_lcd_write_string>
     8c0:	6a e0       	ldi	r22, 0x0A	; 10
					nokia_lcd_write_string("Password: ",1);
     8c2:	80 e0       	ldi	r24, 0x00	; 0
     8c4:	28 d3       	rcall	.+1616   	; 0xf16 <nokia_lcd_set_cursor>
     8c6:	61 e0       	ldi	r22, 0x01	; 1
     8c8:	88 e9       	ldi	r24, 0x98	; 152
					nokia_lcd_write_char(removeuser_password_fails + '0',1);
     8ca:	91 e0       	ldi	r25, 0x01	; 1
     8cc:	12 d3       	rcall	.+1572   	; 0xef2 <nokia_lcd_write_string>
     8ce:	80 91 c6 07 	lds	r24, 0x07C6	; 0x8007c6 <removeuser_password_fails>
     8d2:	61 e0       	ldi	r22, 0x01	; 1
					nokia_lcd_set_cursor(0,20);
     8d4:	80 5d       	subi	r24, 0xD0	; 208
     8d6:	63 d2       	rcall	.+1222   	; 0xd9e <nokia_lcd_write_char>
     8d8:	64 e1       	ldi	r22, 0x14	; 20
     8da:	80 e0       	ldi	r24, 0x00	; 0
					nokia_lcd_write_string(temporary_password,1);
     8dc:	1c d3       	rcall	.+1592   	; 0xf16 <nokia_lcd_set_cursor>
     8de:	61 e0       	ldi	r22, 0x01	; 1
     8e0:	c8 01       	movw	r24, r16
     8e2:	07 d3       	rcall	.+1550   	; 0xef2 <nokia_lcd_write_string>
					nokia_lcd_render();
     8e4:	1d d3       	rcall	.+1594   	; 0xf20 <nokia_lcd_render>
     8e6:	06 c0       	rjmp	.+12     	; 0x8f4 <RemoveUsers_Tick+0x162>
     8e8:	8f e4       	ldi	r24, 0x4F	; 79
     8ea:	93 ec       	ldi	r25, 0xC3	; 195
     8ec:	01 97       	sbiw	r24, 0x01	; 1
     8ee:	f1 f7       	brne	.-4      	; 0x8ec <RemoveUsers_Tick+0x15a>
     8f0:	00 c0       	rjmp	.+0      	; 0x8f2 <RemoveUsers_Tick+0x160>
     8f2:	00 00       	nop
				}
				
				while((removeuser_selection = GetKeypadKey()) == '\0'){ _delay_ms(200); }
     8f4:	9b dd       	rcall	.-1226   	; 0x42c <GetKeypadKey>
     8f6:	80 93 c8 07 	sts	0x07C8, r24	; 0x8007c8 <removeuser_selection>
     8fa:	88 23       	and	r24, r24
     8fc:	a9 f3       	breq	.-22     	; 0x8e8 <RemoveUsers_Tick+0x156>
     8fe:	06 c0       	rjmp	.+12     	; 0x90c <RemoveUsers_Tick+0x17a>
     900:	ef e4       	ldi	r30, 0x4F	; 79
     902:	f3 ec       	ldi	r31, 0xC3	; 195
     904:	31 97       	sbiw	r30, 0x01	; 1
     906:	f1 f7       	brne	.-4      	; 0x904 <RemoveUsers_Tick+0x172>
     908:	00 c0       	rjmp	.+0      	; 0x90a <RemoveUsers_Tick+0x178>
     90a:	00 00       	nop
				
				while((removeuser_prev_selection = GetKeypadKey()) == removeuser_selection){ _delay_ms(200); }
     90c:	8f dd       	rcall	.-1250   	; 0x42c <GetKeypadKey>
     90e:	80 93 c7 07 	sts	0x07C7, r24	; 0x8007c7 <removeuser_prev_selection>
     912:	90 91 c8 07 	lds	r25, 0x07C8	; 0x8007c8 <removeuser_selection>
     916:	89 17       	cp	r24, r25
     918:	99 f3       	breq	.-26     	; 0x900 <RemoveUsers_Tick+0x16e>
     91a:	80 91 c8 07 	lds	r24, 0x07C8	; 0x8007c8 <removeuser_selection>
		
		case removeuser_password:
			while((removeuser_selection = GetKeypadKey()) == '\0'){ _delay_ms(200); }
			while((removeuser_prev_selection = GetKeypadKey()) == removeuser_selection){ _delay_ms(200); }
			
			while(removeuser_selection != '#'){
     91e:	83 32       	cpi	r24, 0x23	; 35
     920:	09 f0       	breq	.+2      	; 0x924 <RemoveUsers_Tick+0x192>
     922:	86 cf       	rjmp	.-244    	; 0x830 <RemoveUsers_Tick+0x9e>
     924:	73 de       	rcall	.-794    	; 0x60c <password_verification>
				while((removeuser_prev_selection = GetKeypadKey()) == removeuser_selection){ _delay_ms(200); }
				
			}
			
			
			if(!password_verification()){
     926:	81 11       	cpse	r24, r1
     928:	12 c0       	rjmp	.+36     	; 0x94e <RemoveUsers_Tick+0x1bc>
     92a:	80 91 c6 07 	lds	r24, 0x07C6	; 0x8007c6 <removeuser_password_fails>
				++removeuser_password_fails;
     92e:	8f 5f       	subi	r24, 0xFF	; 255
     930:	80 93 c6 07 	sts	0x07C6, r24	; 0x8007c6 <removeuser_password_fails>
     934:	80 91 1e 0a 	lds	r24, 0x0A1E	; 0x800a1e <removeusers>
		
		default:
			break;
	}
	//Transitions
	switch(removeusers){
     938:	81 30       	cpi	r24, 0x01	; 1
     93a:	09 f4       	brne	.+2      	; 0x93e <RemoveUsers_Tick+0x1ac>
     93c:	53 c0       	rjmp	.+166    	; 0x9e4 <RemoveUsers_Tick+0x252>
     93e:	d8 f1       	brcs	.+118    	; 0x9b6 <RemoveUsers_Tick+0x224>
     940:	82 30       	cpi	r24, 0x02	; 2
     942:	09 f4       	brne	.+2      	; 0x946 <RemoveUsers_Tick+0x1b4>
     944:	82 c0       	rjmp	.+260    	; 0xa4a <RemoveUsers_Tick+0x2b8>
     946:	83 30       	cpi	r24, 0x03	; 3
     948:	09 f4       	brne	.+2      	; 0x94c <RemoveUsers_Tick+0x1ba>
     94a:	03 c1       	rjmp	.+518    	; 0xb52 <RemoveUsers_Tick+0x3c0>
     94c:	50 c1       	rjmp	.+672    	; 0xbee <RemoveUsers_Tick+0x45c>
     94e:	10 92 c6 07 	sts	0x07C6, r1	; 0x8007c6 <removeuser_password_fails>
			if(!password_verification()){
				++removeuser_password_fails;
			}
			
			else{
				removeuser_password_fails = 0;
     952:	80 91 1e 0a 	lds	r24, 0x0A1E	; 0x800a1e <removeusers>
		
		default:
			break;
	}
	//Transitions
	switch(removeusers){
     956:	81 30       	cpi	r24, 0x01	; 1
     958:	09 f4       	brne	.+2      	; 0x95c <RemoveUsers_Tick+0x1ca>
     95a:	44 c0       	rjmp	.+136    	; 0x9e4 <RemoveUsers_Tick+0x252>
     95c:	60 f1       	brcs	.+88     	; 0x9b6 <RemoveUsers_Tick+0x224>
     95e:	82 30       	cpi	r24, 0x02	; 2
     960:	09 f4       	brne	.+2      	; 0x964 <RemoveUsers_Tick+0x1d2>
     962:	77 c0       	rjmp	.+238    	; 0xa52 <RemoveUsers_Tick+0x2c0>
     964:	83 30       	cpi	r24, 0x03	; 3
     966:	09 f4       	brne	.+2      	; 0x96a <RemoveUsers_Tick+0x1d8>
     968:	ef c0       	rjmp	.+478    	; 0xb48 <RemoveUsers_Tick+0x3b6>
     96a:	41 c1       	rjmp	.+642    	; 0xbee <RemoveUsers_Tick+0x45c>
     96c:	8f e4       	ldi	r24, 0x4F	; 79
     96e:	93 ec       	ldi	r25, 0xC3	; 195
     970:	01 97       	sbiw	r24, 0x01	; 1
     972:	f1 f7       	brne	.-4      	; 0x970 <RemoveUsers_Tick+0x1de>
     974:	00 c0       	rjmp	.+0      	; 0x976 <RemoveUsers_Tick+0x1e4>
     976:	00 00       	nop
				removeuser_password_fails = 0;
			}
			break;
		
		case removeuser_confirm:
			while((removeuser_selection = GetKeypadKey()) == '\0'){ _delay_ms(200); }
     978:	59 dd       	rcall	.-1358   	; 0x42c <GetKeypadKey>
     97a:	80 93 c8 07 	sts	0x07C8, r24	; 0x8007c8 <removeuser_selection>
     97e:	88 23       	and	r24, r24
     980:	a9 f3       	breq	.-22     	; 0x96c <RemoveUsers_Tick+0x1da>
     982:	06 c0       	rjmp	.+12     	; 0x990 <RemoveUsers_Tick+0x1fe>
     984:	ef e4       	ldi	r30, 0x4F	; 79
     986:	f3 ec       	ldi	r31, 0xC3	; 195
     988:	31 97       	sbiw	r30, 0x01	; 1
     98a:	f1 f7       	brne	.-4      	; 0x988 <RemoveUsers_Tick+0x1f6>
     98c:	00 c0       	rjmp	.+0      	; 0x98e <RemoveUsers_Tick+0x1fc>
     98e:	00 00       	nop
     990:	4d dd       	rcall	.-1382   	; 0x42c <GetKeypadKey>
			while((removeuser_prev_selection = GetKeypadKey()) == removeuser_selection){ _delay_ms(200); }
     992:	80 93 c7 07 	sts	0x07C7, r24	; 0x8007c7 <removeuser_prev_selection>
     996:	90 91 c8 07 	lds	r25, 0x07C8	; 0x8007c8 <removeuser_selection>
     99a:	89 17       	cp	r24, r25
     99c:	99 f3       	breq	.-26     	; 0x984 <RemoveUsers_Tick+0x1f2>
		
		default:
			break;
	}
	//Transitions
	switch(removeusers){
     99e:	80 91 1e 0a 	lds	r24, 0x0A1E	; 0x800a1e <removeusers>
     9a2:	81 30       	cpi	r24, 0x01	; 1
     9a4:	f9 f0       	breq	.+62     	; 0x9e4 <RemoveUsers_Tick+0x252>
     9a6:	38 f0       	brcs	.+14     	; 0x9b6 <RemoveUsers_Tick+0x224>
     9a8:	82 30       	cpi	r24, 0x02	; 2
     9aa:	09 f4       	brne	.+2      	; 0x9ae <RemoveUsers_Tick+0x21c>
     9ac:	4e c0       	rjmp	.+156    	; 0xa4a <RemoveUsers_Tick+0x2b8>
     9ae:	83 30       	cpi	r24, 0x03	; 3
     9b0:	09 f4       	brne	.+2      	; 0x9b4 <RemoveUsers_Tick+0x222>
     9b2:	ca c0       	rjmp	.+404    	; 0xb48 <RemoveUsers_Tick+0x3b6>
		case removeusers_init:
			if(removeusers_flag){
     9b4:	1c c1       	rjmp	.+568    	; 0xbee <RemoveUsers_Tick+0x45c>
     9b6:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <removeusers_flag>
     9ba:	88 23       	and	r24, r24
     9bc:	09 f4       	brne	.+2      	; 0x9c0 <RemoveUsers_Tick+0x22e>
				nokia_lcd_clear();
     9be:	23 c1       	rjmp	.+582    	; 0xc06 <RemoveUsers_Tick+0x474>
     9c0:	b2 d1       	rcall	.+868    	; 0xd26 <nokia_lcd_clear>
				if(number_of_users > 0 && number_of_users < 5){
     9c2:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <number_of_users>
     9c6:	81 50       	subi	r24, 0x01	; 1
     9c8:	84 30       	cpi	r24, 0x04	; 4
					removeusers_intro();
     9ca:	28 f4       	brcc	.+10     	; 0x9d6 <RemoveUsers_Tick+0x244>
     9cc:	44 de       	rcall	.-888    	; 0x656 <removeusers_intro>
					removeusers = removeuser_select;
     9ce:	81 e0       	ldi	r24, 0x01	; 1
     9d0:	80 93 1e 0a 	sts	0x0A1E, r24	; 0x800a1e <removeusers>
				}
				
				else{
					nokia_lcd_write_string("No Users!",1);
     9d4:	18 c1       	rjmp	.+560    	; 0xc06 <RemoveUsers_Tick+0x474>
     9d6:	61 e0       	ldi	r22, 0x01	; 1
     9d8:	88 e8       	ldi	r24, 0x88	; 136
     9da:	91 e0       	ldi	r25, 0x01	; 1
					removeusers = removeusers_init;
     9dc:	8a d2       	rcall	.+1300   	; 0xef2 <nokia_lcd_write_string>
     9de:	10 92 1e 0a 	sts	0x0A1E, r1	; 0x800a1e <removeusers>
			}
			
			break;
		
		case removeuser_select:
			if(removeuser_selection < number_of_users){
     9e2:	11 c1       	rjmp	.+546    	; 0xc06 <RemoveUsers_Tick+0x474>
     9e4:	80 91 c8 07 	lds	r24, 0x07C8	; 0x8007c8 <removeuser_selection>
     9e8:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <number_of_users>
				user_to_remove = removeuser_selection;
     9ec:	89 17       	cp	r24, r25
				nokia_lcd_clear();
     9ee:	08 f0       	brcs	.+2      	; 0x9f2 <RemoveUsers_Tick+0x260>
     9f0:	0a c1       	rjmp	.+532    	; 0xc06 <RemoveUsers_Tick+0x474>
				nokia_lcd_write_string("Enter",1);
     9f2:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     9f6:	97 d1       	rcall	.+814    	; 0xd26 <nokia_lcd_clear>
     9f8:	61 e0       	ldi	r22, 0x01	; 1
     9fa:	82 e9       	ldi	r24, 0x92	; 146
				nokia_lcd_set_cursor(0,10);
     9fc:	91 e0       	ldi	r25, 0x01	; 1
     9fe:	79 d2       	rcall	.+1266   	; 0xef2 <nokia_lcd_write_string>
     a00:	6a e0       	ldi	r22, 0x0A	; 10
     a02:	80 e0       	ldi	r24, 0x00	; 0
				nokia_lcd_write_string("Password: ",1);
     a04:	88 d2       	rcall	.+1296   	; 0xf16 <nokia_lcd_set_cursor>
     a06:	61 e0       	ldi	r22, 0x01	; 1
     a08:	88 e9       	ldi	r24, 0x98	; 152
     a0a:	91 e0       	ldi	r25, 0x01	; 1
     a0c:	72 d2       	rcall	.+1252   	; 0xef2 <nokia_lcd_write_string>
				nokia_lcd_write_char(removeuser_password_fails + '0',1);
     a0e:	80 91 c6 07 	lds	r24, 0x07C6	; 0x8007c6 <removeuser_password_fails>
     a12:	61 e0       	ldi	r22, 0x01	; 1
     a14:	80 5d       	subi	r24, 0xD0	; 208
     a16:	c3 d1       	rcall	.+902    	; 0xd9e <nokia_lcd_write_char>
     a18:	64 e1       	ldi	r22, 0x14	; 20
				nokia_lcd_set_cursor(0,20);
     a1a:	80 e0       	ldi	r24, 0x00	; 0
     a1c:	7c d2       	rcall	.+1272   	; 0xf16 <nokia_lcd_set_cursor>
     a1e:	61 e0       	ldi	r22, 0x01	; 1
				nokia_lcd_write_string("*",1);
     a20:	83 ea       	ldi	r24, 0xA3	; 163
     a22:	91 e0       	ldi	r25, 0x01	; 1
     a24:	66 d2       	rcall	.+1228   	; 0xef2 <nokia_lcd_write_string>
     a26:	7c d2       	rcall	.+1272   	; 0xf20 <nokia_lcd_render>
				nokia_lcd_render();
     a28:	10 92 c6 07 	sts	0x07C6, r1	; 0x8007c6 <removeuser_password_fails>
				removeuser_password_fails = 0;
     a2c:	ed eb       	ldi	r30, 0xBD	; 189
     a2e:	f7 e0       	ldi	r31, 0x07	; 7
     a30:	85 ec       	ldi	r24, 0xC5	; 197
     a32:	97 e0       	ldi	r25, 0x07	; 7
     a34:	11 92       	st	Z+, r1
     a36:	8e 17       	cp	r24, r30
				for(unsigned char i = 0; i < 8; ++i){
					temporary_password[i] = '\0';
     a38:	9f 07       	cpc	r25, r31
				nokia_lcd_write_char(removeuser_password_fails + '0',1);
				nokia_lcd_set_cursor(0,20);
				nokia_lcd_write_string("*",1);
				nokia_lcd_render();
				removeuser_password_fails = 0;
				for(unsigned char i = 0; i < 8; ++i){
     a3a:	e1 f7       	brne	.-8      	; 0xa34 <RemoveUsers_Tick+0x2a2>
     a3c:	8a e2       	ldi	r24, 0x2A	; 42
					temporary_password[i] = '\0';
				}
				temporary_password[0] = '*';
     a3e:	80 93 bd 07 	sts	0x07BD, r24	; 0x8007bd <temporary_password>
				removeusers = removeuser_password;
     a42:	82 e0       	ldi	r24, 0x02	; 2
     a44:	80 93 1e 0a 	sts	0x0A1E, r24	; 0x800a1e <removeusers>
			}
			
			break;
		
		case removeuser_password:
			if(removeuser_password_fails == 0 && removeusers_flag){
     a48:	de c0       	rjmp	.+444    	; 0xc06 <RemoveUsers_Tick+0x474>
     a4a:	80 91 c6 07 	lds	r24, 0x07C6	; 0x8007c6 <removeuser_password_fails>
     a4e:	81 11       	cpse	r24, r1
     a50:	31 c0       	rjmp	.+98     	; 0xab4 <RemoveUsers_Tick+0x322>
     a52:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <removeusers_flag>
				nokia_lcd_clear();
     a56:	88 23       	and	r24, r24
				nokia_lcd_write_string("Remove",1);
     a58:	09 f4       	brne	.+2      	; 0xa5c <RemoveUsers_Tick+0x2ca>
     a5a:	73 c0       	rjmp	.+230    	; 0xb42 <RemoveUsers_Tick+0x3b0>
     a5c:	64 d1       	rcall	.+712    	; 0xd26 <nokia_lcd_clear>
				nokia_lcd_set_cursor(0,10);
     a5e:	61 e0       	ldi	r22, 0x01	; 1
     a60:	85 ea       	ldi	r24, 0xA5	; 165
     a62:	91 e0       	ldi	r25, 0x01	; 1
     a64:	46 d2       	rcall	.+1164   	; 0xef2 <nokia_lcd_write_string>
				nokia_lcd_write_string(List_of_Users[user_to_remove].name,1);
     a66:	6a e0       	ldi	r22, 0x0A	; 10
     a68:	80 e0       	ldi	r24, 0x00	; 0
     a6a:	55 d2       	rcall	.+1194   	; 0xf16 <nokia_lcd_set_cursor>
     a6c:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     a70:	fa e1       	ldi	r31, 0x1A	; 26
     a72:	8f 9f       	mul	r24, r31
     a74:	c0 01       	movw	r24, r0
     a76:	11 24       	eor	r1, r1
     a78:	61 e0       	ldi	r22, 0x01	; 1
				nokia_lcd_set_cursor(0,20);
     a7a:	8e 5f       	subi	r24, 0xFE	; 254
     a7c:	9e 4f       	sbci	r25, 0xFE	; 254
     a7e:	39 d2       	rcall	.+1138   	; 0xef2 <nokia_lcd_write_string>
     a80:	64 e1       	ldi	r22, 0x14	; 20
				nokia_lcd_write_string("from system?",1);
     a82:	80 e0       	ldi	r24, 0x00	; 0
     a84:	48 d2       	rcall	.+1168   	; 0xf16 <nokia_lcd_set_cursor>
     a86:	61 e0       	ldi	r22, 0x01	; 1
     a88:	8c ea       	ldi	r24, 0xAC	; 172
     a8a:	91 e0       	ldi	r25, 0x01	; 1
				nokia_lcd_set_cursor(0,30);
     a8c:	32 d2       	rcall	.+1124   	; 0xef2 <nokia_lcd_write_string>
     a8e:	6e e1       	ldi	r22, 0x1E	; 30
     a90:	80 e0       	ldi	r24, 0x00	; 0
     a92:	41 d2       	rcall	.+1154   	; 0xf16 <nokia_lcd_set_cursor>
				nokia_lcd_write_string("* = no",1);
     a94:	61 e0       	ldi	r22, 0x01	; 1
     a96:	89 eb       	ldi	r24, 0xB9	; 185
     a98:	91 e0       	ldi	r25, 0x01	; 1
     a9a:	2b d2       	rcall	.+1110   	; 0xef2 <nokia_lcd_write_string>
				nokia_lcd_set_cursor(0,40);
     a9c:	68 e2       	ldi	r22, 0x28	; 40
     a9e:	80 e0       	ldi	r24, 0x00	; 0
     aa0:	3a d2       	rcall	.+1140   	; 0xf16 <nokia_lcd_set_cursor>
				nokia_lcd_write_string("# = yes",1);				
     aa2:	61 e0       	ldi	r22, 0x01	; 1
     aa4:	80 ec       	ldi	r24, 0xC0	; 192
     aa6:	91 e0       	ldi	r25, 0x01	; 1
     aa8:	24 d2       	rcall	.+1096   	; 0xef2 <nokia_lcd_write_string>
				nokia_lcd_render();
     aaa:	3a d2       	rcall	.+1140   	; 0xf20 <nokia_lcd_render>
     aac:	83 e0       	ldi	r24, 0x03	; 3
				removeusers = removeuser_confirm;
     aae:	80 93 1e 0a 	sts	0x0A1E, r24	; 0x800a1e <removeusers>
     ab2:	a9 c0       	rjmp	.+338    	; 0xc06 <RemoveUsers_Tick+0x474>
			}
			
			else if(removeuser_password_fails == 3 && removeusers_flag){
     ab4:	83 30       	cpi	r24, 0x03	; 3
     ab6:	b9 f4       	brne	.+46     	; 0xae6 <RemoveUsers_Tick+0x354>
     ab8:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <removeusers_flag>
     abc:	88 23       	and	r24, r24
				removeusers_intro();
     abe:	09 f4       	brne	.+2      	; 0xac2 <RemoveUsers_Tick+0x330>
     ac0:	40 c0       	rjmp	.+128    	; 0xb42 <RemoveUsers_Tick+0x3b0>
				removeuser_password_fails = 0;
     ac2:	c9 dd       	rcall	.-1134   	; 0x656 <removeusers_intro>
     ac4:	10 92 c6 07 	sts	0x07C6, r1	; 0x8007c6 <removeuser_password_fails>
				password_size = 0;
     ac8:	10 92 bc 07 	sts	0x07BC, r1	; 0x8007bc <password_size>
     acc:	ed eb       	ldi	r30, 0xBD	; 189
     ace:	f7 e0       	ldi	r31, 0x07	; 7
     ad0:	85 ec       	ldi	r24, 0xC5	; 197
				for(unsigned char i = 0; i < 8; ++i){
					temporary_password[i] = '\0';
     ad2:	97 e0       	ldi	r25, 0x07	; 7
			
			else if(removeuser_password_fails == 3 && removeusers_flag){
				removeusers_intro();
				removeuser_password_fails = 0;
				password_size = 0;
				for(unsigned char i = 0; i < 8; ++i){
     ad4:	11 92       	st	Z+, r1
     ad6:	e8 17       	cp	r30, r24
     ad8:	f9 07       	cpc	r31, r25
					temporary_password[i] = '\0';
				}
				temporary_password[0] = '\0';
     ada:	e1 f7       	brne	.-8      	; 0xad4 <RemoveUsers_Tick+0x342>
     adc:	10 92 bd 07 	sts	0x07BD, r1	; 0x8007bd <temporary_password>
				
				removeusers = removeusers_init;
     ae0:	10 92 1e 0a 	sts	0x0A1E, r1	; 0x800a1e <removeusers>
			}
			
			else if(removeuser_password_fails != 0 && removeuser_password_fails != 3 && removeusers_flag){
     ae4:	90 c0       	rjmp	.+288    	; 0xc06 <RemoveUsers_Tick+0x474>
     ae6:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <removeusers_flag>
     aea:	88 23       	and	r24, r24
				nokia_lcd_clear();
     aec:	51 f1       	breq	.+84     	; 0xb42 <RemoveUsers_Tick+0x3b0>
     aee:	1b d1       	rcall	.+566    	; 0xd26 <nokia_lcd_clear>
				nokia_lcd_write_string("Enter",1);
     af0:	61 e0       	ldi	r22, 0x01	; 1
     af2:	82 e9       	ldi	r24, 0x92	; 146
     af4:	91 e0       	ldi	r25, 0x01	; 1
     af6:	fd d1       	rcall	.+1018   	; 0xef2 <nokia_lcd_write_string>
     af8:	6a e0       	ldi	r22, 0x0A	; 10
				nokia_lcd_set_cursor(0,10);
     afa:	80 e0       	ldi	r24, 0x00	; 0
     afc:	0c d2       	rcall	.+1048   	; 0xf16 <nokia_lcd_set_cursor>
     afe:	61 e0       	ldi	r22, 0x01	; 1
				nokia_lcd_write_string("Password: ",1);
     b00:	88 e9       	ldi	r24, 0x98	; 152
     b02:	91 e0       	ldi	r25, 0x01	; 1
     b04:	f6 d1       	rcall	.+1004   	; 0xef2 <nokia_lcd_write_string>
     b06:	80 91 c6 07 	lds	r24, 0x07C6	; 0x8007c6 <removeuser_password_fails>
				nokia_lcd_write_char(removeuser_password_fails + '0',1);
     b0a:	61 e0       	ldi	r22, 0x01	; 1
     b0c:	80 5d       	subi	r24, 0xD0	; 208
     b0e:	47 d1       	rcall	.+654    	; 0xd9e <nokia_lcd_write_char>
     b10:	64 e1       	ldi	r22, 0x14	; 20
     b12:	80 e0       	ldi	r24, 0x00	; 0
				nokia_lcd_set_cursor(0,20);
     b14:	00 d2       	rcall	.+1024   	; 0xf16 <nokia_lcd_set_cursor>
     b16:	61 e0       	ldi	r22, 0x01	; 1
     b18:	83 ea       	ldi	r24, 0xA3	; 163
				nokia_lcd_write_string("*",1);
     b1a:	91 e0       	ldi	r25, 0x01	; 1
     b1c:	ea d1       	rcall	.+980    	; 0xef2 <nokia_lcd_write_string>
     b1e:	00 d2       	rcall	.+1024   	; 0xf20 <nokia_lcd_render>
     b20:	10 92 bc 07 	sts	0x07BC, r1	; 0x8007bc <password_size>
				nokia_lcd_render();
     b24:	ed eb       	ldi	r30, 0xBD	; 189
				password_size = 0;
     b26:	f7 e0       	ldi	r31, 0x07	; 7
     b28:	85 ec       	ldi	r24, 0xC5	; 197
     b2a:	97 e0       	ldi	r25, 0x07	; 7
     b2c:	11 92       	st	Z+, r1
     b2e:	e8 17       	cp	r30, r24
     b30:	f9 07       	cpc	r31, r25
				for(unsigned char i = 0; i < 8; ++i){
					temporary_password[i] = '\0';
     b32:	e1 f7       	brne	.-8      	; 0xb2c <RemoveUsers_Tick+0x39a>
				nokia_lcd_write_char(removeuser_password_fails + '0',1);
				nokia_lcd_set_cursor(0,20);
				nokia_lcd_write_string("*",1);
				nokia_lcd_render();
				password_size = 0;
				for(unsigned char i = 0; i < 8; ++i){
     b34:	8a e2       	ldi	r24, 0x2A	; 42
     b36:	80 93 bd 07 	sts	0x07BD, r24	; 0x8007bd <temporary_password>
					temporary_password[i] = '\0';
				}
				temporary_password[0] = '*';
     b3a:	82 e0       	ldi	r24, 0x02	; 2
     b3c:	80 93 1e 0a 	sts	0x0A1E, r24	; 0x800a1e <removeusers>
				removeusers = removeuser_password;
     b40:	62 c0       	rjmp	.+196    	; 0xc06 <RemoveUsers_Tick+0x474>
     b42:	10 92 1e 0a 	sts	0x0A1E, r1	; 0x800a1e <removeusers>
			}
			
			else if(!removeusers_flag){
				removeusers = removeusers_init;
     b46:	5f c0       	rjmp	.+190    	; 0xc06 <RemoveUsers_Tick+0x474>
     b48:	80 91 c8 07 	lds	r24, 0x07C8	; 0x8007c8 <removeuser_selection>
			}
			break;
		
		case removeuser_confirm:
			if(removeuser_selection == '#'){
     b4c:	83 32       	cpi	r24, 0x23	; 35
     b4e:	09 f0       	breq	.+2      	; 0xb52 <RemoveUsers_Tick+0x3c0>
     b50:	3a c0       	rjmp	.+116    	; 0xbc6 <RemoveUsers_Tick+0x434>
     b52:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
				if(user_to_remove == 0){
     b56:	81 11       	cpse	r24, r1
     b58:	0e c0       	rjmp	.+28     	; 0xb76 <RemoveUsers_Tick+0x3e4>
     b5a:	61 e0       	ldi	r22, 0x01	; 1
     b5c:	cc dc       	rcall	.-1640   	; 0x4f6 <swap_users>
					for(unsigned char i = 0; i < 3; ++i){
						swap_users(i,i+1);
     b5e:	62 e0       	ldi	r22, 0x02	; 2
     b60:	81 e0       	ldi	r24, 0x01	; 1
     b62:	c9 dc       	rcall	.-1646   	; 0x4f6 <swap_users>
     b64:	63 e0       	ldi	r22, 0x03	; 3
     b66:	82 e0       	ldi	r24, 0x02	; 2
     b68:	c6 dc       	rcall	.-1652   	; 0x4f6 <swap_users>
     b6a:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <number_of_users>
     b6e:	81 50       	subi	r24, 0x01	; 1
     b70:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <number_of_users>
					}
					--number_of_users;
     b74:	16 c0       	rjmp	.+44     	; 0xba2 <RemoveUsers_Tick+0x410>
     b76:	81 30       	cpi	r24, 0x01	; 1
     b78:	59 f4       	brne	.+22     	; 0xb90 <RemoveUsers_Tick+0x3fe>
     b7a:	62 e0       	ldi	r22, 0x02	; 2
     b7c:	bc dc       	rcall	.-1672   	; 0x4f6 <swap_users>
				}
				
				else if(user_to_remove == 1){
     b7e:	63 e0       	ldi	r22, 0x03	; 3
     b80:	82 e0       	ldi	r24, 0x02	; 2
					for(unsigned char i = 1; i < 3; ++i){
						swap_users(i,i+1);
     b82:	b9 dc       	rcall	.-1678   	; 0x4f6 <swap_users>
     b84:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <number_of_users>
     b88:	81 50       	subi	r24, 0x01	; 1
     b8a:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <number_of_users>
					}
					--number_of_users;
     b8e:	09 c0       	rjmp	.+18     	; 0xba2 <RemoveUsers_Tick+0x410>
     b90:	82 30       	cpi	r24, 0x02	; 2
     b92:	81 f1       	breq	.+96     	; 0xbf4 <RemoveUsers_Tick+0x462>
     b94:	83 30       	cpi	r24, 0x03	; 3
     b96:	29 f4       	brne	.+10     	; 0xba2 <RemoveUsers_Tick+0x410>
     b98:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <number_of_users>
				}
				
				else if(user_to_remove == 2){
     b9c:	81 50       	subi	r24, 0x01	; 1
						swap_users(i,i+1);
					}
					--number_of_users;
				}
				
				else if(user_to_remove == 3){
     b9e:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <number_of_users>
					--number_of_users;
     ba2:	59 dd       	rcall	.-1358   	; 0x656 <removeusers_intro>
     ba4:	10 92 c6 07 	sts	0x07C6, r1	; 0x8007c6 <removeuser_password_fails>
     ba8:	10 92 bc 07 	sts	0x07BC, r1	; 0x8007bc <password_size>
				}
				
				removeusers_intro();
     bac:	ed eb       	ldi	r30, 0xBD	; 189
     bae:	f7 e0       	ldi	r31, 0x07	; 7
				removeuser_password_fails = 0;
     bb0:	85 ec       	ldi	r24, 0xC5	; 197
     bb2:	97 e0       	ldi	r25, 0x07	; 7
				password_size = 0;
     bb4:	11 92       	st	Z+, r1
     bb6:	e8 17       	cp	r30, r24
     bb8:	f9 07       	cpc	r31, r25
     bba:	e1 f7       	brne	.-8      	; 0xbb4 <RemoveUsers_Tick+0x422>
     bbc:	10 92 bd 07 	sts	0x07BD, r1	; 0x8007bd <temporary_password>
				for(unsigned char i = 0; i < 8; ++i){
					temporary_password[i] = '\0';
     bc0:	10 92 1e 0a 	sts	0x0A1E, r1	; 0x800a1e <removeusers>
				}
				
				removeusers_intro();
				removeuser_password_fails = 0;
				password_size = 0;
				for(unsigned char i = 0; i < 8; ++i){
     bc4:	20 c0       	rjmp	.+64     	; 0xc06 <RemoveUsers_Tick+0x474>
     bc6:	8a 32       	cpi	r24, 0x2A	; 42
					temporary_password[i] = '\0';
				}
				temporary_password[0] = '\0';
     bc8:	f1 f4       	brne	.+60     	; 0xc06 <RemoveUsers_Tick+0x474>
     bca:	45 dd       	rcall	.-1398   	; 0x656 <removeusers_intro>
				
				removeusers = removeusers_init;
     bcc:	10 92 c6 07 	sts	0x07C6, r1	; 0x8007c6 <removeuser_password_fails>
     bd0:	10 92 bc 07 	sts	0x07BC, r1	; 0x8007bc <password_size>
			}
			
			else if(removeuser_selection == '*'){
     bd4:	ed eb       	ldi	r30, 0xBD	; 189
				removeusers_intro();
     bd6:	f7 e0       	ldi	r31, 0x07	; 7
     bd8:	85 ec       	ldi	r24, 0xC5	; 197
				removeuser_password_fails = 0;
     bda:	97 e0       	ldi	r25, 0x07	; 7
     bdc:	11 92       	st	Z+, r1
				password_size = 0;
     bde:	e8 17       	cp	r30, r24
     be0:	f9 07       	cpc	r31, r25
     be2:	e1 f7       	brne	.-8      	; 0xbdc <RemoveUsers_Tick+0x44a>
     be4:	10 92 bd 07 	sts	0x07BD, r1	; 0x8007bd <temporary_password>
     be8:	10 92 1e 0a 	sts	0x0A1E, r1	; 0x800a1e <removeusers>
				for(unsigned char i = 0; i < 8; ++i){
     bec:	0c c0       	rjmp	.+24     	; 0xc06 <RemoveUsers_Tick+0x474>
     bee:	10 92 1e 0a 	sts	0x0A1E, r1	; 0x800a1e <removeusers>
					temporary_password[i] = '\0';
				}
				temporary_password[0] = '\0';
     bf2:	09 c0       	rjmp	.+18     	; 0xc06 <RemoveUsers_Tick+0x474>
     bf4:	63 e0       	ldi	r22, 0x03	; 3
				
				removeusers = removeusers_init;
     bf6:	82 e0       	ldi	r24, 0x02	; 2
     bf8:	7e dc       	rcall	.-1796   	; 0x4f6 <swap_users>
     bfa:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <number_of_users>
			}
			
			break;
		
		default:
			removeusers = removeusers_init;
     bfe:	81 50       	subi	r24, 0x01	; 1
			break;
	}
}
     c00:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <number_of_users>
					--number_of_users;
				}
				
				else if(user_to_remove == 2){
					for(unsigned char i = 2; i < 3; ++i){
						swap_users(i,i+1);
     c04:	ce cf       	rjmp	.-100    	; 0xba2 <RemoveUsers_Tick+0x410>
     c06:	df 91       	pop	r29
     c08:	cf 91       	pop	r28
					}
					--number_of_users;
     c0a:	1f 91       	pop	r17
     c0c:	0f 91       	pop	r16
     c0e:	ff 90       	pop	r15
     c10:	08 95       	ret

00000c12 <RemoveUsersTask>:
     c12:	b9 dd       	rcall	.-1166   	; 0x786 <RemoveUsers_Init>
     c14:	be dd       	rcall	.-1156   	; 0x792 <RemoveUsers_Tick>
		
		default:
			removeusers = removeusers_init;
			break;
	}
}
     c16:	84 e6       	ldi	r24, 0x64	; 100
     c18:	90 e0       	ldi	r25, 0x00	; 0
     c1a:	9b d5       	rcall	.+2870   	; 0x1752 <vTaskDelay>
     c1c:	fb cf       	rjmp	.-10     	; 0xc14 <RemoveUsersTask+0x2>

00000c1e <RemoveUsersPulse>:
     c1e:	af 92       	push	r10
     c20:	bf 92       	push	r11
		vTaskDelay(100); 
	} 
}

void RemoveUsersPulse(unsigned portBASE_TYPE Priority)
{
     c22:	cf 92       	push	r12
     c24:	df 92       	push	r13
     c26:	ef 92       	push	r14
     c28:	ff 92       	push	r15
     c2a:	0f 93       	push	r16
	xTaskCreate(RemoveUsersTask, (signed portCHAR *)"RemoveUsersTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     c2c:	a1 2c       	mov	r10, r1
     c2e:	b1 2c       	mov	r11, r1
     c30:	c1 2c       	mov	r12, r1
     c32:	d1 2c       	mov	r13, r1
     c34:	e1 2c       	mov	r14, r1
     c36:	f1 2c       	mov	r15, r1
     c38:	08 2f       	mov	r16, r24
     c3a:	20 e0       	ldi	r18, 0x00	; 0
     c3c:	30 e0       	ldi	r19, 0x00	; 0
     c3e:	45 e5       	ldi	r20, 0x55	; 85
     c40:	50 e0       	ldi	r21, 0x00	; 0
     c42:	68 ec       	ldi	r22, 0xC8	; 200
     c44:	71 e0       	ldi	r23, 0x01	; 1
     c46:	89 e0       	ldi	r24, 0x09	; 9
     c48:	96 e0       	ldi	r25, 0x06	; 6
     c4a:	0f d3       	rcall	.+1566   	; 0x126a <xTaskGenericCreate>
}	
     c4c:	0f 91       	pop	r16
     c4e:	ff 90       	pop	r15
     c50:	ef 90       	pop	r14
     c52:	df 90       	pop	r13
     c54:	cf 90       	pop	r12
     c56:	bf 90       	pop	r11
     c58:	af 90       	pop	r10
     c5a:	08 95       	ret

00000c5c <main>:
 
int main(void) 
{ 
	DDRC = 0x0F; PORTC = 0xF0;
     c5c:	8f e0       	ldi	r24, 0x0F	; 15
     c5e:	87 b9       	out	0x07, r24	; 7
     c60:	80 ef       	ldi	r24, 0xF0	; 240
     c62:	88 b9       	out	0x08, r24	; 8
	DDRD = 0xFF; PORTD = 0x00;
     c64:	8f ef       	ldi	r24, 0xFF	; 255
     c66:	8a b9       	out	0x0a, r24	; 10
     c68:	1b b8       	out	0x0b, r1	; 11
	nokia_lcd_init();
     c6a:	27 d0       	rcall	.+78     	; 0xcba <nokia_lcd_init>
	//Start Tasks  
	RemoveUsersPulse(1);
     c6c:	81 e0       	ldi	r24, 0x01	; 1
    //RunSchedular 
	vTaskStartScheduler(); 
     c6e:	d7 df       	rcall	.-82     	; 0xc1e <RemoveUsersPulse>
     c70:	f9 d3       	rcall	.+2034   	; 0x1464 <vTaskStartScheduler>
 
	return 0; 
     c72:	80 e0       	ldi	r24, 0x00	; 0
     c74:	90 e0       	ldi	r25, 0x00	; 0
     c76:	08 95       	ret

00000c78 <write>:
		nokia_lcd.screen[i] = 0x00;
}

void nokia_lcd_power(uint8_t on)
{
	write_cmd(on ? 0x20 : 0x24);
     c78:	59 98       	cbi	0x0b, 1	; 11
     c7a:	66 23       	and	r22, r22
     c7c:	11 f0       	breq	.+4      	; 0xc82 <write+0xa>
     c7e:	5b 9a       	sbi	0x0b, 3	; 11
     c80:	15 c0       	rjmp	.+42     	; 0xcac <write+0x34>
     c82:	5b 98       	cbi	0x0b, 3	; 11
     c84:	13 c0       	rjmp	.+38     	; 0xcac <write+0x34>
     c86:	ac 01       	movw	r20, r24
     c88:	02 2e       	mov	r0, r18
     c8a:	02 c0       	rjmp	.+4      	; 0xc90 <write+0x18>
     c8c:	55 95       	asr	r21
     c8e:	47 95       	ror	r20
     c90:	0a 94       	dec	r0
     c92:	e2 f7       	brpl	.-8      	; 0xc8c <write+0x14>
     c94:	40 ff       	sbrs	r20, 0
     c96:	02 c0       	rjmp	.+4      	; 0xc9c <write+0x24>
     c98:	5c 9a       	sbi	0x0b, 4	; 11
     c9a:	01 c0       	rjmp	.+2      	; 0xc9e <write+0x26>
     c9c:	5c 98       	cbi	0x0b, 4	; 11
     c9e:	5d 9a       	sbi	0x0b, 5	; 11
     ca0:	5d 98       	cbi	0x0b, 5	; 11
     ca2:	21 50       	subi	r18, 0x01	; 1
     ca4:	31 09       	sbc	r19, r1
     ca6:	78 f7       	brcc	.-34     	; 0xc86 <write+0xe>
     ca8:	59 9a       	sbi	0x0b, 1	; 11
     caa:	08 95       	ret
     cac:	27 e0       	ldi	r18, 0x07	; 7
     cae:	30 e0       	ldi	r19, 0x00	; 0
     cb0:	90 e0       	ldi	r25, 0x00	; 0
     cb2:	e9 cf       	rjmp	.-46     	; 0xc86 <write+0xe>

00000cb4 <write_cmd>:
     cb4:	60 e0       	ldi	r22, 0x00	; 0
     cb6:	e0 cf       	rjmp	.-64     	; 0xc78 <write>
     cb8:	08 95       	ret

00000cba <nokia_lcd_init>:
     cba:	cf 93       	push	r28
     cbc:	df 93       	push	r29
     cbe:	51 9a       	sbi	0x0a, 1	; 10
     cc0:	52 9a       	sbi	0x0a, 2	; 10
     cc2:	53 9a       	sbi	0x0a, 3	; 10
     cc4:	54 9a       	sbi	0x0a, 4	; 10
     cc6:	55 9a       	sbi	0x0a, 5	; 10
     cc8:	5a 9a       	sbi	0x0b, 2	; 11
     cca:	59 9a       	sbi	0x0b, 1	; 11
     ccc:	83 ec       	ldi	r24, 0xC3	; 195
     cce:	99 e0       	ldi	r25, 0x09	; 9
     cd0:	01 97       	sbiw	r24, 0x01	; 1
     cd2:	f1 f7       	brne	.-4      	; 0xcd0 <nokia_lcd_init+0x16>
     cd4:	00 c0       	rjmp	.+0      	; 0xcd6 <nokia_lcd_init+0x1c>
     cd6:	00 00       	nop
     cd8:	5a 98       	cbi	0x0b, 2	; 11
     cda:	8b e5       	ldi	r24, 0x5B	; 91
     cdc:	94 e4       	ldi	r25, 0x44	; 68
     cde:	01 97       	sbiw	r24, 0x01	; 1
     ce0:	f1 f7       	brne	.-4      	; 0xcde <nokia_lcd_init+0x24>
     ce2:	00 c0       	rjmp	.+0      	; 0xce4 <nokia_lcd_init+0x2a>
     ce4:	00 00       	nop
     ce6:	5a 9a       	sbi	0x0b, 2	; 11
     ce8:	59 98       	cbi	0x0b, 1	; 11
     cea:	81 e2       	ldi	r24, 0x21	; 33
     cec:	e3 df       	rcall	.-58     	; 0xcb4 <write_cmd>
     cee:	83 e1       	ldi	r24, 0x13	; 19
     cf0:	e1 df       	rcall	.-62     	; 0xcb4 <write_cmd>
     cf2:	86 e0       	ldi	r24, 0x06	; 6
     cf4:	df df       	rcall	.-66     	; 0xcb4 <write_cmd>
     cf6:	82 ec       	ldi	r24, 0xC2	; 194
     cf8:	dd df       	rcall	.-70     	; 0xcb4 <write_cmd>
     cfa:	80 e2       	ldi	r24, 0x20	; 32
     cfc:	db df       	rcall	.-74     	; 0xcb4 <write_cmd>
     cfe:	89 e0       	ldi	r24, 0x09	; 9
     d00:	d9 df       	rcall	.-78     	; 0xcb4 <write_cmd>
     d02:	80 e8       	ldi	r24, 0x80	; 128
     d04:	d7 df       	rcall	.-82     	; 0xcb4 <write_cmd>
     d06:	80 e4       	ldi	r24, 0x40	; 64
     d08:	d5 df       	rcall	.-86     	; 0xcb4 <write_cmd>
     d0a:	c8 ef       	ldi	r28, 0xF8	; 248
     d0c:	d1 e0       	ldi	r29, 0x01	; 1
     d0e:	61 e0       	ldi	r22, 0x01	; 1
     d10:	80 e0       	ldi	r24, 0x00	; 0
     d12:	b2 df       	rcall	.-156    	; 0xc78 <write>
     d14:	21 97       	sbiw	r28, 0x01	; 1
     d16:	d9 f7       	brne	.-10     	; 0xd0e <nokia_lcd_init+0x54>
     d18:	88 e0       	ldi	r24, 0x08	; 8
     d1a:	cc df       	rcall	.-104    	; 0xcb4 <write_cmd>
     d1c:	8c e0       	ldi	r24, 0x0C	; 12
     d1e:	ca df       	rcall	.-108    	; 0xcb4 <write_cmd>
     d20:	df 91       	pop	r29
     d22:	cf 91       	pop	r28
     d24:	08 95       	ret

00000d26 <nokia_lcd_clear>:
     d26:	80 e8       	ldi	r24, 0x80	; 128
     d28:	c5 df       	rcall	.-118    	; 0xcb4 <write_cmd>
     d2a:	80 e4       	ldi	r24, 0x40	; 64
     d2c:	c3 df       	rcall	.-122    	; 0xcb4 <write_cmd>
     d2e:	10 92 c2 09 	sts	0x09C2, r1	; 0x8009c2 <nokia_lcd+0x1f8>
     d32:	10 92 c3 09 	sts	0x09C3, r1	; 0x8009c3 <nokia_lcd+0x1f9>
     d36:	ea ec       	ldi	r30, 0xCA	; 202
     d38:	f7 e0       	ldi	r31, 0x07	; 7
     d3a:	82 ec       	ldi	r24, 0xC2	; 194
     d3c:	99 e0       	ldi	r25, 0x09	; 9
     d3e:	11 92       	st	Z+, r1
     d40:	e8 17       	cp	r30, r24
     d42:	f9 07       	cpc	r31, r25
     d44:	e1 f7       	brne	.-8      	; 0xd3e <nokia_lcd_clear+0x18>
     d46:	08 95       	ret

00000d48 <nokia_lcd_set_pixel>:
}

void nokia_lcd_set_pixel(uint8_t x, uint8_t y, uint8_t value)
{
	uint8_t *byte = &nokia_lcd.screen[y/8*84+x];
     d48:	26 2f       	mov	r18, r22
     d4a:	26 95       	lsr	r18
     d4c:	26 95       	lsr	r18
     d4e:	26 95       	lsr	r18
     d50:	90 e0       	ldi	r25, 0x00	; 0
     d52:	34 e5       	ldi	r19, 0x54	; 84
     d54:	23 9f       	mul	r18, r19
     d56:	80 0d       	add	r24, r0
     d58:	91 1d       	adc	r25, r1
     d5a:	11 24       	eor	r1, r1
	if (value)
     d5c:	44 23       	and	r20, r20
     d5e:	79 f0       	breq	.+30     	; 0xd7e <nokia_lcd_set_pixel+0x36>
		*byte |= (1 << (y % 8));
     d60:	fc 01       	movw	r30, r24
     d62:	e6 53       	subi	r30, 0x36	; 54
     d64:	f8 4f       	sbci	r31, 0xF8	; 248
     d66:	67 70       	andi	r22, 0x07	; 7
     d68:	81 e0       	ldi	r24, 0x01	; 1
     d6a:	90 e0       	ldi	r25, 0x00	; 0
     d6c:	02 c0       	rjmp	.+4      	; 0xd72 <nokia_lcd_set_pixel+0x2a>
     d6e:	88 0f       	add	r24, r24
     d70:	99 1f       	adc	r25, r25
     d72:	6a 95       	dec	r22
     d74:	e2 f7       	brpl	.-8      	; 0xd6e <nokia_lcd_set_pixel+0x26>
     d76:	90 81       	ld	r25, Z
     d78:	89 2b       	or	r24, r25
     d7a:	80 83       	st	Z, r24
     d7c:	08 95       	ret
	else
		*byte &= ~(1 << (y %8 ));
     d7e:	fc 01       	movw	r30, r24
     d80:	e6 53       	subi	r30, 0x36	; 54
     d82:	f8 4f       	sbci	r31, 0xF8	; 248
     d84:	67 70       	andi	r22, 0x07	; 7
     d86:	81 e0       	ldi	r24, 0x01	; 1
     d88:	90 e0       	ldi	r25, 0x00	; 0
     d8a:	02 c0       	rjmp	.+4      	; 0xd90 <nokia_lcd_set_pixel+0x48>
     d8c:	88 0f       	add	r24, r24
     d8e:	99 1f       	adc	r25, r25
     d90:	6a 95       	dec	r22
     d92:	e2 f7       	brpl	.-8      	; 0xd8c <nokia_lcd_set_pixel+0x44>
     d94:	80 95       	com	r24
     d96:	90 81       	ld	r25, Z
     d98:	89 23       	and	r24, r25
     d9a:	80 83       	st	Z, r24
     d9c:	08 95       	ret

00000d9e <nokia_lcd_write_char>:
}

void nokia_lcd_write_char(char code, uint8_t scale)
{
     d9e:	5f 92       	push	r5
     da0:	6f 92       	push	r6
     da2:	7f 92       	push	r7
     da4:	8f 92       	push	r8
     da6:	9f 92       	push	r9
     da8:	af 92       	push	r10
     daa:	bf 92       	push	r11
     dac:	cf 92       	push	r12
     dae:	df 92       	push	r13
     db0:	ef 92       	push	r14
     db2:	ff 92       	push	r15
     db4:	0f 93       	push	r16
     db6:	1f 93       	push	r17
     db8:	cf 93       	push	r28
     dba:	df 93       	push	r29
     dbc:	56 2e       	mov	r5, r22
	register uint8_t x, y;

	for (x = 0; x < 5*scale; x++)
     dbe:	26 2f       	mov	r18, r22
     dc0:	30 e0       	ldi	r19, 0x00	; 0
     dc2:	49 01       	movw	r8, r18
     dc4:	88 0c       	add	r8, r8
     dc6:	99 1c       	adc	r9, r9
     dc8:	88 0c       	add	r8, r8
     dca:	99 1c       	adc	r9, r9
     dcc:	82 0e       	add	r8, r18
     dce:	93 1e       	adc	r9, r19
     dd0:	18 14       	cp	r1, r8
     dd2:	19 04       	cpc	r1, r9
     dd4:	0c f0       	brlt	.+2      	; 0xdd8 <nokia_lcd_write_char+0x3a>
     dd6:	59 c0       	rjmp	.+178    	; 0xe8a <nokia_lcd_write_char+0xec>
		for (y = 0; y < 7*scale; y++)
     dd8:	89 01       	movw	r16, r18
     dda:	00 0f       	add	r16, r16
     ddc:	11 1f       	adc	r17, r17
     dde:	00 0f       	add	r16, r16
     de0:	11 1f       	adc	r17, r17
     de2:	00 0f       	add	r16, r16
     de4:	11 1f       	adc	r17, r17
     de6:	02 1b       	sub	r16, r18
     de8:	13 0b       	sbc	r17, r19
     dea:	61 2c       	mov	r6, r1
			if (pgm_read_byte(&CHARSET[code-32][x/scale]) & (1 << y/scale))
     dec:	a8 2e       	mov	r10, r24
     dee:	b1 2c       	mov	r11, r1
     df0:	c5 01       	movw	r24, r10
     df2:	80 97       	sbiw	r24, 0x20	; 32
     df4:	5c 01       	movw	r10, r24
     df6:	aa 0c       	add	r10, r10
     df8:	bb 1c       	adc	r11, r11
     dfa:	aa 0c       	add	r10, r10
     dfc:	bb 1c       	adc	r11, r11
     dfe:	a8 0e       	add	r10, r24
     e00:	b9 1e       	adc	r11, r25
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 1);
			else
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 0);
     e02:	0f 2e       	mov	r0, r31
     e04:	f3 ec       	ldi	r31, 0xC3	; 195
     e06:	cf 2e       	mov	r12, r31
     e08:	f9 e0       	ldi	r31, 0x09	; 9
     e0a:	df 2e       	mov	r13, r31
     e0c:	f0 2d       	mov	r31, r0
     e0e:	0f 2e       	mov	r0, r31
     e10:	f2 ec       	ldi	r31, 0xC2	; 194
     e12:	ef 2e       	mov	r14, r31
     e14:	f9 e0       	ldi	r31, 0x09	; 9
     e16:	ff 2e       	mov	r15, r31
     e18:	f0 2d       	mov	r31, r0
     e1a:	2a c0       	rjmp	.+84     	; 0xe70 <nokia_lcd_write_char+0xd2>
{
	register uint8_t x, y;

	for (x = 0; x < 5*scale; x++)
		for (y = 0; y < 7*scale; y++)
			if (pgm_read_byte(&CHARSET[code-32][x/scale]) & (1 << y/scale))
     e1c:	fe 01       	movw	r30, r28
     e1e:	24 91       	lpm	r18, Z
     e20:	30 e0       	ldi	r19, 0x00	; 0
     e22:	87 2d       	mov	r24, r7
     e24:	65 2d       	mov	r22, r5
     e26:	56 d5       	rcall	.+2732   	; 0x18d4 <__udivmodqi4>
     e28:	02 c0       	rjmp	.+4      	; 0xe2e <nokia_lcd_write_char+0x90>
     e2a:	35 95       	asr	r19
     e2c:	27 95       	ror	r18
     e2e:	8a 95       	dec	r24
     e30:	e2 f7       	brpl	.-8      	; 0xe2a <nokia_lcd_write_char+0x8c>
     e32:	20 ff       	sbrs	r18, 0
     e34:	09 c0       	rjmp	.+18     	; 0xe48 <nokia_lcd_write_char+0xaa>
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 1);
     e36:	f6 01       	movw	r30, r12
     e38:	60 81       	ld	r22, Z
     e3a:	67 0d       	add	r22, r7
     e3c:	f7 01       	movw	r30, r14
     e3e:	80 81       	ld	r24, Z
     e40:	41 e0       	ldi	r20, 0x01	; 1
     e42:	86 0d       	add	r24, r6
     e44:	81 df       	rcall	.-254    	; 0xd48 <nokia_lcd_set_pixel>
     e46:	08 c0       	rjmp	.+16     	; 0xe58 <nokia_lcd_write_char+0xba>
			else
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 0);
     e48:	f6 01       	movw	r30, r12
     e4a:	60 81       	ld	r22, Z
     e4c:	67 0d       	add	r22, r7
     e4e:	f7 01       	movw	r30, r14
     e50:	80 81       	ld	r24, Z
     e52:	40 e0       	ldi	r20, 0x00	; 0
     e54:	86 0d       	add	r24, r6
     e56:	78 df       	rcall	.-272    	; 0xd48 <nokia_lcd_set_pixel>
void nokia_lcd_write_char(char code, uint8_t scale)
{
	register uint8_t x, y;

	for (x = 0; x < 5*scale; x++)
		for (y = 0; y < 7*scale; y++)
     e58:	73 94       	inc	r7
     e5a:	87 2d       	mov	r24, r7
     e5c:	90 e0       	ldi	r25, 0x00	; 0
     e5e:	80 17       	cp	r24, r16
     e60:	91 07       	cpc	r25, r17
     e62:	e4 f2       	brlt	.-72     	; 0xe1c <nokia_lcd_write_char+0x7e>

void nokia_lcd_write_char(char code, uint8_t scale)
{
	register uint8_t x, y;

	for (x = 0; x < 5*scale; x++)
     e64:	63 94       	inc	r6
     e66:	86 2d       	mov	r24, r6
     e68:	90 e0       	ldi	r25, 0x00	; 0
     e6a:	88 15       	cp	r24, r8
     e6c:	99 05       	cpc	r25, r9
     e6e:	6c f4       	brge	.+26     	; 0xe8a <nokia_lcd_write_char+0xec>
		for (y = 0; y < 7*scale; y++)
     e70:	10 16       	cp	r1, r16
     e72:	11 06       	cpc	r1, r17
			if (pgm_read_byte(&CHARSET[code-32][x/scale]) & (1 << y/scale))
     e74:	bc f7       	brge	.-18     	; 0xe64 <nokia_lcd_write_char+0xc6>
     e76:	86 2d       	mov	r24, r6
     e78:	65 2d       	mov	r22, r5
     e7a:	2c d5       	rcall	.+2648   	; 0x18d4 <__udivmodqi4>
     e7c:	e5 01       	movw	r28, r10
     e7e:	c8 0f       	add	r28, r24
     e80:	d1 1d       	adc	r29, r1
     e82:	c4 57       	subi	r28, 0x74	; 116
     e84:	df 4f       	sbci	r29, 0xFF	; 255
     e86:	71 2c       	mov	r7, r1
     e88:	c9 cf       	rjmp	.-110    	; 0xe1c <nokia_lcd_write_char+0x7e>
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 1);
			else
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 0);

	nokia_lcd.cursor_x += 5*scale + 1;
     e8a:	80 91 c2 09 	lds	r24, 0x09C2	; 0x8009c2 <nokia_lcd+0x1f8>
     e8e:	91 e0       	ldi	r25, 0x01	; 1
     e90:	98 0f       	add	r25, r24
     e92:	85 2d       	mov	r24, r5
     e94:	88 0f       	add	r24, r24
     e96:	88 0f       	add	r24, r24
     e98:	85 0d       	add	r24, r5
     e9a:	89 0f       	add	r24, r25
	if (nokia_lcd.cursor_x >= 84) {
     e9c:	84 35       	cpi	r24, 0x54	; 84
     e9e:	18 f4       	brcc	.+6      	; 0xea6 <nokia_lcd_write_char+0x108>
			if (pgm_read_byte(&CHARSET[code-32][x/scale]) & (1 << y/scale))
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 1);
			else
				nokia_lcd_set_pixel(nokia_lcd.cursor_x + x, nokia_lcd.cursor_y + y, 0);

	nokia_lcd.cursor_x += 5*scale + 1;
     ea0:	80 93 c2 09 	sts	0x09C2, r24	; 0x8009c2 <nokia_lcd+0x1f8>
     ea4:	0e c0       	rjmp	.+28     	; 0xec2 <nokia_lcd_write_char+0x124>
	if (nokia_lcd.cursor_x >= 84) {
		nokia_lcd.cursor_x = 0;
     ea6:	10 92 c2 09 	sts	0x09C2, r1	; 0x8009c2 <nokia_lcd+0x1f8>
		nokia_lcd.cursor_y += 7*scale + 1;
     eaa:	e3 ec       	ldi	r30, 0xC3	; 195
     eac:	f9 e0       	ldi	r31, 0x09	; 9
     eae:	80 81       	ld	r24, Z
     eb0:	91 e0       	ldi	r25, 0x01	; 1
     eb2:	98 0f       	add	r25, r24
     eb4:	85 2d       	mov	r24, r5
     eb6:	88 0f       	add	r24, r24
     eb8:	88 0f       	add	r24, r24
     eba:	88 0f       	add	r24, r24
     ebc:	85 19       	sub	r24, r5
     ebe:	89 0f       	add	r24, r25
     ec0:	80 83       	st	Z, r24
	}
	if (nokia_lcd.cursor_y >= 48) {
     ec2:	80 91 c3 09 	lds	r24, 0x09C3	; 0x8009c3 <nokia_lcd+0x1f9>
     ec6:	80 33       	cpi	r24, 0x30	; 48
     ec8:	20 f0       	brcs	.+8      	; 0xed2 <nokia_lcd_write_char+0x134>
		nokia_lcd.cursor_x = 0;
     eca:	10 92 c2 09 	sts	0x09C2, r1	; 0x8009c2 <nokia_lcd+0x1f8>
		nokia_lcd.cursor_y = 0;
     ece:	10 92 c3 09 	sts	0x09C3, r1	; 0x8009c3 <nokia_lcd+0x1f9>
	}
}
     ed2:	df 91       	pop	r29
     ed4:	cf 91       	pop	r28
     ed6:	1f 91       	pop	r17
     ed8:	0f 91       	pop	r16
     eda:	ff 90       	pop	r15
     edc:	ef 90       	pop	r14
     ede:	df 90       	pop	r13
     ee0:	cf 90       	pop	r12
     ee2:	bf 90       	pop	r11
     ee4:	af 90       	pop	r10
     ee6:	9f 90       	pop	r9
     ee8:	8f 90       	pop	r8
     eea:	7f 90       	pop	r7
     eec:	6f 90       	pop	r6
     eee:	5f 90       	pop	r5
     ef0:	08 95       	ret

00000ef2 <nokia_lcd_write_string>:

void nokia_lcd_write_string(const char *str, uint8_t scale)
{
     ef2:	1f 93       	push	r17
     ef4:	cf 93       	push	r28
     ef6:	df 93       	push	r29
     ef8:	ec 01       	movw	r28, r24
	while(*str)
     efa:	88 81       	ld	r24, Y
     efc:	88 23       	and	r24, r24
     efe:	39 f0       	breq	.+14     	; 0xf0e <nokia_lcd_write_string+0x1c>
     f00:	16 2f       	mov	r17, r22
     f02:	21 96       	adiw	r28, 0x01	; 1
		nokia_lcd_write_char(*str++, scale);
     f04:	61 2f       	mov	r22, r17
     f06:	4b df       	rcall	.-362    	; 0xd9e <nokia_lcd_write_char>
	}
}

void nokia_lcd_write_string(const char *str, uint8_t scale)
{
	while(*str)
     f08:	89 91       	ld	r24, Y+
     f0a:	81 11       	cpse	r24, r1
     f0c:	fb cf       	rjmp	.-10     	; 0xf04 <nokia_lcd_write_string+0x12>
		nokia_lcd_write_char(*str++, scale);
}
     f0e:	df 91       	pop	r29
     f10:	cf 91       	pop	r28
     f12:	1f 91       	pop	r17
     f14:	08 95       	ret

00000f16 <nokia_lcd_set_cursor>:

void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
	nokia_lcd.cursor_x = x;
     f16:	80 93 c2 09 	sts	0x09C2, r24	; 0x8009c2 <nokia_lcd+0x1f8>
	nokia_lcd.cursor_y = y;
     f1a:	60 93 c3 09 	sts	0x09C3, r22	; 0x8009c3 <nokia_lcd+0x1f9>
     f1e:	08 95       	ret

00000f20 <nokia_lcd_render>:
}

void nokia_lcd_render(void)
{
     f20:	0f 93       	push	r16
     f22:	1f 93       	push	r17
     f24:	cf 93       	push	r28
     f26:	df 93       	push	r29
	register unsigned i;
	/* Set column and row to 0 */
	write_cmd(0x80);
     f28:	80 e8       	ldi	r24, 0x80	; 128
     f2a:	c4 de       	rcall	.-632    	; 0xcb4 <write_cmd>
	write_cmd(0x40);
     f2c:	80 e4       	ldi	r24, 0x40	; 64
     f2e:	c2 de       	rcall	.-636    	; 0xcb4 <write_cmd>
     f30:	ca ec       	ldi	r28, 0xCA	; 202
     f32:	d7 e0       	ldi	r29, 0x07	; 7
     f34:	02 ec       	ldi	r16, 0xC2	; 194
     f36:	19 e0       	ldi	r17, 0x09	; 9
	write(cmd, 0);
}

static void write_data(uint8_t data)
{
	write(data, 1);
     f38:	61 e0       	ldi	r22, 0x01	; 1
     f3a:	89 91       	ld	r24, Y+
     f3c:	9d de       	rcall	.-710    	; 0xc78 <write>
	/* Set column and row to 0 */
	write_cmd(0x80);
	write_cmd(0x40);

	/* Write screen to display */
	for (i = 0; i < 504; i++)
     f3e:	c0 17       	cp	r28, r16
     f40:	d1 07       	cpc	r29, r17
     f42:	d1 f7       	brne	.-12     	; 0xf38 <nokia_lcd_render+0x18>
		write_data(nokia_lcd.screen[i]);
}
     f44:	df 91       	pop	r29
     f46:	cf 91       	pop	r28
     f48:	1f 91       	pop	r17
     f4a:	0f 91       	pop	r16
     f4c:	08 95       	ret

00000f4e <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     f4e:	31 e1       	ldi	r19, 0x11	; 17
     f50:	fc 01       	movw	r30, r24
     f52:	30 83       	st	Z, r19
     f54:	31 97       	sbiw	r30, 0x01	; 1
     f56:	22 e2       	ldi	r18, 0x22	; 34
     f58:	20 83       	st	Z, r18
     f5a:	31 97       	sbiw	r30, 0x01	; 1
     f5c:	a3 e3       	ldi	r26, 0x33	; 51
     f5e:	a0 83       	st	Z, r26
     f60:	31 97       	sbiw	r30, 0x01	; 1
     f62:	60 83       	st	Z, r22
     f64:	31 97       	sbiw	r30, 0x01	; 1
     f66:	70 83       	st	Z, r23
     f68:	31 97       	sbiw	r30, 0x01	; 1
     f6a:	10 82       	st	Z, r1
     f6c:	31 97       	sbiw	r30, 0x01	; 1
     f6e:	60 e8       	ldi	r22, 0x80	; 128
     f70:	60 83       	st	Z, r22
     f72:	31 97       	sbiw	r30, 0x01	; 1
     f74:	10 82       	st	Z, r1
     f76:	31 97       	sbiw	r30, 0x01	; 1
     f78:	62 e0       	ldi	r22, 0x02	; 2
     f7a:	60 83       	st	Z, r22
     f7c:	31 97       	sbiw	r30, 0x01	; 1
     f7e:	63 e0       	ldi	r22, 0x03	; 3
     f80:	60 83       	st	Z, r22
     f82:	31 97       	sbiw	r30, 0x01	; 1
     f84:	64 e0       	ldi	r22, 0x04	; 4
     f86:	60 83       	st	Z, r22
     f88:	31 97       	sbiw	r30, 0x01	; 1
     f8a:	65 e0       	ldi	r22, 0x05	; 5
     f8c:	60 83       	st	Z, r22
     f8e:	31 97       	sbiw	r30, 0x01	; 1
     f90:	66 e0       	ldi	r22, 0x06	; 6
     f92:	60 83       	st	Z, r22
     f94:	31 97       	sbiw	r30, 0x01	; 1
     f96:	67 e0       	ldi	r22, 0x07	; 7
     f98:	60 83       	st	Z, r22
     f9a:	31 97       	sbiw	r30, 0x01	; 1
     f9c:	68 e0       	ldi	r22, 0x08	; 8
     f9e:	60 83       	st	Z, r22
     fa0:	31 97       	sbiw	r30, 0x01	; 1
     fa2:	69 e0       	ldi	r22, 0x09	; 9
     fa4:	60 83       	st	Z, r22
     fa6:	31 97       	sbiw	r30, 0x01	; 1
     fa8:	60 e1       	ldi	r22, 0x10	; 16
     faa:	60 83       	st	Z, r22
     fac:	31 97       	sbiw	r30, 0x01	; 1
     fae:	30 83       	st	Z, r19
     fb0:	31 97       	sbiw	r30, 0x01	; 1
     fb2:	32 e1       	ldi	r19, 0x12	; 18
     fb4:	30 83       	st	Z, r19
     fb6:	31 97       	sbiw	r30, 0x01	; 1
     fb8:	33 e1       	ldi	r19, 0x13	; 19
     fba:	30 83       	st	Z, r19
     fbc:	31 97       	sbiw	r30, 0x01	; 1
     fbe:	34 e1       	ldi	r19, 0x14	; 20
     fc0:	30 83       	st	Z, r19
     fc2:	31 97       	sbiw	r30, 0x01	; 1
     fc4:	35 e1       	ldi	r19, 0x15	; 21
     fc6:	30 83       	st	Z, r19
     fc8:	31 97       	sbiw	r30, 0x01	; 1
     fca:	36 e1       	ldi	r19, 0x16	; 22
     fcc:	30 83       	st	Z, r19
     fce:	31 97       	sbiw	r30, 0x01	; 1
     fd0:	37 e1       	ldi	r19, 0x17	; 23
     fd2:	30 83       	st	Z, r19
     fd4:	31 97       	sbiw	r30, 0x01	; 1
     fd6:	38 e1       	ldi	r19, 0x18	; 24
     fd8:	30 83       	st	Z, r19
     fda:	31 97       	sbiw	r30, 0x01	; 1
     fdc:	39 e1       	ldi	r19, 0x19	; 25
     fde:	30 83       	st	Z, r19
     fe0:	31 97       	sbiw	r30, 0x01	; 1
     fe2:	30 e2       	ldi	r19, 0x20	; 32
     fe4:	30 83       	st	Z, r19
     fe6:	31 97       	sbiw	r30, 0x01	; 1
     fe8:	31 e2       	ldi	r19, 0x21	; 33
     fea:	30 83       	st	Z, r19
     fec:	31 97       	sbiw	r30, 0x01	; 1
     fee:	20 83       	st	Z, r18
     ff0:	31 97       	sbiw	r30, 0x01	; 1
     ff2:	23 e2       	ldi	r18, 0x23	; 35
     ff4:	20 83       	st	Z, r18
     ff6:	31 97       	sbiw	r30, 0x01	; 1
     ff8:	40 83       	st	Z, r20
     ffa:	31 97       	sbiw	r30, 0x01	; 1
     ffc:	50 83       	st	Z, r21
     ffe:	31 97       	sbiw	r30, 0x01	; 1
    1000:	26 e2       	ldi	r18, 0x26	; 38
    1002:	20 83       	st	Z, r18
    1004:	31 97       	sbiw	r30, 0x01	; 1
    1006:	27 e2       	ldi	r18, 0x27	; 39
    1008:	20 83       	st	Z, r18
    100a:	31 97       	sbiw	r30, 0x01	; 1
    100c:	28 e2       	ldi	r18, 0x28	; 40
    100e:	20 83       	st	Z, r18
    1010:	31 97       	sbiw	r30, 0x01	; 1
    1012:	29 e2       	ldi	r18, 0x29	; 41
    1014:	20 83       	st	Z, r18
    1016:	31 97       	sbiw	r30, 0x01	; 1
    1018:	20 e3       	ldi	r18, 0x30	; 48
    101a:	20 83       	st	Z, r18
    101c:	31 97       	sbiw	r30, 0x01	; 1
    101e:	21 e3       	ldi	r18, 0x31	; 49
    1020:	20 83       	st	Z, r18
    1022:	86 97       	sbiw	r24, 0x26	; 38
    1024:	08 95       	ret

00001026 <xPortStartScheduler>:
    1026:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    102a:	8c e7       	ldi	r24, 0x7C	; 124
    102c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    1030:	8b e0       	ldi	r24, 0x0B	; 11
    1032:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
    1036:	ef e6       	ldi	r30, 0x6F	; 111
    1038:	f0 e0       	ldi	r31, 0x00	; 0
    103a:	80 81       	ld	r24, Z
    103c:	82 60       	ori	r24, 0x02	; 2
    103e:	80 83       	st	Z, r24
    1040:	a0 91 1c 0a 	lds	r26, 0x0A1C	; 0x800a1c <pxCurrentTCB>
    1044:	b0 91 1d 0a 	lds	r27, 0x0A1D	; 0x800a1d <pxCurrentTCB+0x1>
    1048:	cd 91       	ld	r28, X+
    104a:	cd bf       	out	0x3d, r28	; 61
    104c:	dd 91       	ld	r29, X+
    104e:	de bf       	out	0x3e, r29	; 62
    1050:	ff 91       	pop	r31
    1052:	ef 91       	pop	r30
    1054:	df 91       	pop	r29
    1056:	cf 91       	pop	r28
    1058:	bf 91       	pop	r27
    105a:	af 91       	pop	r26
    105c:	9f 91       	pop	r25
    105e:	8f 91       	pop	r24
    1060:	7f 91       	pop	r23
    1062:	6f 91       	pop	r22
    1064:	5f 91       	pop	r21
    1066:	4f 91       	pop	r20
    1068:	3f 91       	pop	r19
    106a:	2f 91       	pop	r18
    106c:	1f 91       	pop	r17
    106e:	0f 91       	pop	r16
    1070:	ff 90       	pop	r15
    1072:	ef 90       	pop	r14
    1074:	df 90       	pop	r13
    1076:	cf 90       	pop	r12
    1078:	bf 90       	pop	r11
    107a:	af 90       	pop	r10
    107c:	9f 90       	pop	r9
    107e:	8f 90       	pop	r8
    1080:	7f 90       	pop	r7
    1082:	6f 90       	pop	r6
    1084:	5f 90       	pop	r5
    1086:	4f 90       	pop	r4
    1088:	3f 90       	pop	r3
    108a:	2f 90       	pop	r2
    108c:	1f 90       	pop	r1
    108e:	0f 90       	pop	r0
    1090:	0f be       	out	0x3f, r0	; 63
    1092:	0f 90       	pop	r0
    1094:	08 95       	ret
    1096:	81 e0       	ldi	r24, 0x01	; 1
    1098:	08 95       	ret

0000109a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    109a:	0f 92       	push	r0
    109c:	0f b6       	in	r0, 0x3f	; 63
    109e:	f8 94       	cli
    10a0:	0f 92       	push	r0
    10a2:	1f 92       	push	r1
    10a4:	11 24       	eor	r1, r1
    10a6:	2f 92       	push	r2
    10a8:	3f 92       	push	r3
    10aa:	4f 92       	push	r4
    10ac:	5f 92       	push	r5
    10ae:	6f 92       	push	r6
    10b0:	7f 92       	push	r7
    10b2:	8f 92       	push	r8
    10b4:	9f 92       	push	r9
    10b6:	af 92       	push	r10
    10b8:	bf 92       	push	r11
    10ba:	cf 92       	push	r12
    10bc:	df 92       	push	r13
    10be:	ef 92       	push	r14
    10c0:	ff 92       	push	r15
    10c2:	0f 93       	push	r16
    10c4:	1f 93       	push	r17
    10c6:	2f 93       	push	r18
    10c8:	3f 93       	push	r19
    10ca:	4f 93       	push	r20
    10cc:	5f 93       	push	r21
    10ce:	6f 93       	push	r22
    10d0:	7f 93       	push	r23
    10d2:	8f 93       	push	r24
    10d4:	9f 93       	push	r25
    10d6:	af 93       	push	r26
    10d8:	bf 93       	push	r27
    10da:	cf 93       	push	r28
    10dc:	df 93       	push	r29
    10de:	ef 93       	push	r30
    10e0:	ff 93       	push	r31
    10e2:	a0 91 1c 0a 	lds	r26, 0x0A1C	; 0x800a1c <pxCurrentTCB>
    10e6:	b0 91 1d 0a 	lds	r27, 0x0A1D	; 0x800a1d <pxCurrentTCB+0x1>
    10ea:	0d b6       	in	r0, 0x3d	; 61
    10ec:	0d 92       	st	X+, r0
    10ee:	0e b6       	in	r0, 0x3e	; 62
    10f0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    10f2:	84 d3       	rcall	.+1800   	; 0x17fc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    10f4:	a0 91 1c 0a 	lds	r26, 0x0A1C	; 0x800a1c <pxCurrentTCB>
    10f8:	b0 91 1d 0a 	lds	r27, 0x0A1D	; 0x800a1d <pxCurrentTCB+0x1>
    10fc:	cd 91       	ld	r28, X+
    10fe:	cd bf       	out	0x3d, r28	; 61
    1100:	dd 91       	ld	r29, X+
    1102:	de bf       	out	0x3e, r29	; 62
    1104:	ff 91       	pop	r31
    1106:	ef 91       	pop	r30
    1108:	df 91       	pop	r29
    110a:	cf 91       	pop	r28
    110c:	bf 91       	pop	r27
    110e:	af 91       	pop	r26
    1110:	9f 91       	pop	r25
    1112:	8f 91       	pop	r24
    1114:	7f 91       	pop	r23
    1116:	6f 91       	pop	r22
    1118:	5f 91       	pop	r21
    111a:	4f 91       	pop	r20
    111c:	3f 91       	pop	r19
    111e:	2f 91       	pop	r18
    1120:	1f 91       	pop	r17
    1122:	0f 91       	pop	r16
    1124:	ff 90       	pop	r15
    1126:	ef 90       	pop	r14
    1128:	df 90       	pop	r13
    112a:	cf 90       	pop	r12
    112c:	bf 90       	pop	r11
    112e:	af 90       	pop	r10
    1130:	9f 90       	pop	r9
    1132:	8f 90       	pop	r8
    1134:	7f 90       	pop	r7
    1136:	6f 90       	pop	r6
    1138:	5f 90       	pop	r5
    113a:	4f 90       	pop	r4
    113c:	3f 90       	pop	r3
    113e:	2f 90       	pop	r2
    1140:	1f 90       	pop	r1
    1142:	0f 90       	pop	r0
    1144:	0f be       	out	0x3f, r0	; 63
    1146:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1148:	08 95       	ret

0000114a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    114a:	0f 92       	push	r0
    114c:	0f b6       	in	r0, 0x3f	; 63
    114e:	f8 94       	cli
    1150:	0f 92       	push	r0
    1152:	1f 92       	push	r1
    1154:	11 24       	eor	r1, r1
    1156:	2f 92       	push	r2
    1158:	3f 92       	push	r3
    115a:	4f 92       	push	r4
    115c:	5f 92       	push	r5
    115e:	6f 92       	push	r6
    1160:	7f 92       	push	r7
    1162:	8f 92       	push	r8
    1164:	9f 92       	push	r9
    1166:	af 92       	push	r10
    1168:	bf 92       	push	r11
    116a:	cf 92       	push	r12
    116c:	df 92       	push	r13
    116e:	ef 92       	push	r14
    1170:	ff 92       	push	r15
    1172:	0f 93       	push	r16
    1174:	1f 93       	push	r17
    1176:	2f 93       	push	r18
    1178:	3f 93       	push	r19
    117a:	4f 93       	push	r20
    117c:	5f 93       	push	r21
    117e:	6f 93       	push	r22
    1180:	7f 93       	push	r23
    1182:	8f 93       	push	r24
    1184:	9f 93       	push	r25
    1186:	af 93       	push	r26
    1188:	bf 93       	push	r27
    118a:	cf 93       	push	r28
    118c:	df 93       	push	r29
    118e:	ef 93       	push	r30
    1190:	ff 93       	push	r31
    1192:	a0 91 1c 0a 	lds	r26, 0x0A1C	; 0x800a1c <pxCurrentTCB>
    1196:	b0 91 1d 0a 	lds	r27, 0x0A1D	; 0x800a1d <pxCurrentTCB+0x1>
    119a:	0d b6       	in	r0, 0x3d	; 61
    119c:	0d 92       	st	X+, r0
    119e:	0e b6       	in	r0, 0x3e	; 62
    11a0:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    11a2:	8f d1       	rcall	.+798    	; 0x14c2 <vTaskIncrementTick>
	vTaskSwitchContext();
    11a4:	2b d3       	rcall	.+1622   	; 0x17fc <vTaskSwitchContext>
    11a6:	a0 91 1c 0a 	lds	r26, 0x0A1C	; 0x800a1c <pxCurrentTCB>
	portRESTORE_CONTEXT();
    11aa:	b0 91 1d 0a 	lds	r27, 0x0A1D	; 0x800a1d <pxCurrentTCB+0x1>
    11ae:	cd 91       	ld	r28, X+
    11b0:	cd bf       	out	0x3d, r28	; 61
    11b2:	dd 91       	ld	r29, X+
    11b4:	de bf       	out	0x3e, r29	; 62
    11b6:	ff 91       	pop	r31
    11b8:	ef 91       	pop	r30
    11ba:	df 91       	pop	r29
    11bc:	cf 91       	pop	r28
    11be:	bf 91       	pop	r27
    11c0:	af 91       	pop	r26
    11c2:	9f 91       	pop	r25
    11c4:	8f 91       	pop	r24
    11c6:	7f 91       	pop	r23
    11c8:	6f 91       	pop	r22
    11ca:	5f 91       	pop	r21
    11cc:	4f 91       	pop	r20
    11ce:	3f 91       	pop	r19
    11d0:	2f 91       	pop	r18
    11d2:	1f 91       	pop	r17
    11d4:	0f 91       	pop	r16
    11d6:	ff 90       	pop	r15
    11d8:	ef 90       	pop	r14
    11da:	df 90       	pop	r13
    11dc:	cf 90       	pop	r12
    11de:	bf 90       	pop	r11
    11e0:	af 90       	pop	r10
    11e2:	9f 90       	pop	r9
    11e4:	8f 90       	pop	r8
    11e6:	7f 90       	pop	r7
    11e8:	6f 90       	pop	r6
    11ea:	5f 90       	pop	r5
    11ec:	4f 90       	pop	r4
    11ee:	3f 90       	pop	r3
    11f0:	2f 90       	pop	r2
    11f2:	1f 90       	pop	r1
    11f4:	0f 90       	pop	r0
    11f6:	0f be       	out	0x3f, r0	; 63
    11f8:	0f 90       	pop	r0
    11fa:	08 95       	ret

000011fc <__vector_13>:

	asm volatile ( "ret" );
    11fc:	a6 df       	rcall	.-180    	; 0x114a <vPortYieldFromTick>
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    11fe:	18 95       	reti

00001200 <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1200:	cf 93       	push	r28
    1202:	df 93       	push	r29
    1204:	ec 01       	movw	r28, r24
    1206:	e0 91 1c 0a 	lds	r30, 0x0A1C	; 0x800a1c <pxCurrentTCB>
    120a:	f0 91 1d 0a 	lds	r31, 0x0A1D	; 0x800a1d <pxCurrentTCB+0x1>
    120e:	93 83       	std	Z+3, r25	; 0x03
    1210:	82 83       	std	Z+2, r24	; 0x02
    1212:	80 91 cc 09 	lds	r24, 0x09CC	; 0x8009cc <xTickCount>
    1216:	90 91 cd 09 	lds	r25, 0x09CD	; 0x8009cd <xTickCount+0x1>
    121a:	c8 17       	cp	r28, r24
    121c:	d9 07       	cpc	r29, r25
    121e:	60 f4       	brcc	.+24     	; 0x1238 <prvAddCurrentTaskToDelayedList+0x38>
    1220:	60 91 1c 0a 	lds	r22, 0x0A1C	; 0x800a1c <pxCurrentTCB>
    1224:	70 91 1d 0a 	lds	r23, 0x0A1D	; 0x800a1d <pxCurrentTCB+0x1>
    1228:	80 91 e2 09 	lds	r24, 0x09E2	; 0x8009e2 <pxOverflowDelayedTaskList>
    122c:	90 91 e3 09 	lds	r25, 0x09E3	; 0x8009e3 <pxOverflowDelayedTaskList+0x1>
    1230:	6e 5f       	subi	r22, 0xFE	; 254
    1232:	7f 4f       	sbci	r23, 0xFF	; 255
    1234:	9a d8       	rcall	.-3788   	; 0x36a <vListInsert>
    1236:	16 c0       	rjmp	.+44     	; 0x1264 <prvAddCurrentTaskToDelayedList+0x64>
    1238:	60 91 1c 0a 	lds	r22, 0x0A1C	; 0x800a1c <pxCurrentTCB>
    123c:	70 91 1d 0a 	lds	r23, 0x0A1D	; 0x800a1d <pxCurrentTCB+0x1>
    1240:	80 91 e4 09 	lds	r24, 0x09E4	; 0x8009e4 <pxDelayedTaskList>
    1244:	90 91 e5 09 	lds	r25, 0x09E5	; 0x8009e5 <pxDelayedTaskList+0x1>
    1248:	6e 5f       	subi	r22, 0xFE	; 254
    124a:	7f 4f       	sbci	r23, 0xFF	; 255
    124c:	8e d8       	rcall	.-3812   	; 0x36a <vListInsert>
    124e:	80 91 6a 01 	lds	r24, 0x016A	; 0x80016a <xNextTaskUnblockTime>
    1252:	90 91 6b 01 	lds	r25, 0x016B	; 0x80016b <xNextTaskUnblockTime+0x1>
    1256:	c8 17       	cp	r28, r24
    1258:	d9 07       	cpc	r29, r25
    125a:	20 f4       	brcc	.+8      	; 0x1264 <prvAddCurrentTaskToDelayedList+0x64>
    125c:	d0 93 6b 01 	sts	0x016B, r29	; 0x80016b <xNextTaskUnblockTime+0x1>
    1260:	c0 93 6a 01 	sts	0x016A, r28	; 0x80016a <xNextTaskUnblockTime>
    1264:	df 91       	pop	r29
    1266:	cf 91       	pop	r28
    1268:	08 95       	ret

0000126a <xTaskGenericCreate>:
    126a:	4f 92       	push	r4
    126c:	5f 92       	push	r5
    126e:	6f 92       	push	r6
    1270:	7f 92       	push	r7
    1272:	8f 92       	push	r8
    1274:	9f 92       	push	r9
    1276:	af 92       	push	r10
    1278:	bf 92       	push	r11
    127a:	cf 92       	push	r12
    127c:	df 92       	push	r13
    127e:	ef 92       	push	r14
    1280:	ff 92       	push	r15
    1282:	0f 93       	push	r16
    1284:	1f 93       	push	r17
    1286:	cf 93       	push	r28
    1288:	df 93       	push	r29
    128a:	5c 01       	movw	r10, r24
    128c:	4b 01       	movw	r8, r22
    128e:	3a 01       	movw	r6, r20
    1290:	29 01       	movw	r4, r18
    1292:	81 e2       	ldi	r24, 0x21	; 33
    1294:	90 e0       	ldi	r25, 0x00	; 0
    1296:	09 d8       	rcall	.-4078   	; 0x2aa <pvPortMalloc>
    1298:	ec 01       	movw	r28, r24
    129a:	89 2b       	or	r24, r25
    129c:	09 f4       	brne	.+2      	; 0x12a0 <xTaskGenericCreate+0x36>
    129e:	d0 c0       	rjmp	.+416    	; 0x1440 <xTaskGenericCreate+0x1d6>
    12a0:	c1 14       	cp	r12, r1
    12a2:	d1 04       	cpc	r13, r1
    12a4:	09 f0       	breq	.+2      	; 0x12a8 <xTaskGenericCreate+0x3e>
    12a6:	c8 c0       	rjmp	.+400    	; 0x1438 <xTaskGenericCreate+0x1ce>
    12a8:	c3 01       	movw	r24, r6
    12aa:	0e 94 55 01 	call	0x2aa	; 0x2aa <pvPortMalloc>
    12ae:	98 8f       	std	Y+24, r25	; 0x18
    12b0:	8f 8b       	std	Y+23, r24	; 0x17
    12b2:	00 97       	sbiw	r24, 0x00	; 0
    12b4:	19 f4       	brne	.+6      	; 0x12bc <xTaskGenericCreate+0x52>
    12b6:	ce 01       	movw	r24, r28
    12b8:	1e d8       	rcall	.-4036   	; 0x2f6 <vPortFree>
    12ba:	c2 c0       	rjmp	.+388    	; 0x1440 <xTaskGenericCreate+0x1d6>
    12bc:	a3 01       	movw	r20, r6
    12be:	65 ea       	ldi	r22, 0xA5	; 165
    12c0:	70 e0       	ldi	r23, 0x00	; 0
    12c2:	14 d3       	rcall	.+1576   	; 0x18ec <memset>
    12c4:	93 01       	movw	r18, r6
    12c6:	21 50       	subi	r18, 0x01	; 1
    12c8:	31 09       	sbc	r19, r1
    12ca:	8f 89       	ldd	r24, Y+23	; 0x17
    12cc:	98 8d       	ldd	r25, Y+24	; 0x18
    12ce:	3c 01       	movw	r6, r24
    12d0:	62 0e       	add	r6, r18
    12d2:	73 1e       	adc	r7, r19
    12d4:	48 e0       	ldi	r20, 0x08	; 8
    12d6:	50 e0       	ldi	r21, 0x00	; 0
    12d8:	b4 01       	movw	r22, r8
    12da:	ce 01       	movw	r24, r28
    12dc:	49 96       	adiw	r24, 0x19	; 25
    12de:	0d d3       	rcall	.+1562   	; 0x18fa <strncpy>
    12e0:	18 a2       	std	Y+32, r1	; 0x20
    12e2:	10 2f       	mov	r17, r16
    12e4:	04 30       	cpi	r16, 0x04	; 4
    12e6:	08 f0       	brcs	.+2      	; 0x12ea <xTaskGenericCreate+0x80>
    12e8:	13 e0       	ldi	r17, 0x03	; 3
    12ea:	1e 8b       	std	Y+22, r17	; 0x16
    12ec:	6e 01       	movw	r12, r28
    12ee:	82 e0       	ldi	r24, 0x02	; 2
    12f0:	c8 0e       	add	r12, r24
    12f2:	d1 1c       	adc	r13, r1
    12f4:	c6 01       	movw	r24, r12
    12f6:	0e d8       	rcall	.-4068   	; 0x314 <vListInitialiseItem>
    12f8:	ce 01       	movw	r24, r28
    12fa:	0c 96       	adiw	r24, 0x0c	; 12
    12fc:	0b d8       	rcall	.-4074   	; 0x314 <vListInitialiseItem>
    12fe:	d9 87       	std	Y+9, r29	; 0x09
    1300:	c8 87       	std	Y+8, r28	; 0x08
    1302:	84 e0       	ldi	r24, 0x04	; 4
    1304:	90 e0       	ldi	r25, 0x00	; 0
    1306:	81 1b       	sub	r24, r17
    1308:	91 09       	sbc	r25, r1
    130a:	9d 87       	std	Y+13, r25	; 0x0d
    130c:	8c 87       	std	Y+12, r24	; 0x0c
    130e:	db 8b       	std	Y+19, r29	; 0x13
    1310:	ca 8b       	std	Y+18, r28	; 0x12
    1312:	a2 01       	movw	r20, r4
    1314:	b5 01       	movw	r22, r10
    1316:	c3 01       	movw	r24, r6
    1318:	1a de       	rcall	.-972    	; 0xf4e <pxPortInitialiseStack>
    131a:	99 83       	std	Y+1, r25	; 0x01
    131c:	88 83       	st	Y, r24
    131e:	e1 14       	cp	r14, r1
    1320:	f1 04       	cpc	r15, r1
    1322:	19 f0       	breq	.+6      	; 0x132a <xTaskGenericCreate+0xc0>
    1324:	f7 01       	movw	r30, r14
    1326:	d1 83       	std	Z+1, r29	; 0x01
    1328:	c0 83       	st	Z, r28
    132a:	0f b6       	in	r0, 0x3f	; 63
    132c:	f8 94       	cli
    132e:	0f 92       	push	r0
    1330:	80 91 ce 09 	lds	r24, 0x09CE	; 0x8009ce <uxCurrentNumberOfTasks>
    1334:	8f 5f       	subi	r24, 0xFF	; 255
    1336:	80 93 ce 09 	sts	0x09CE, r24	; 0x8009ce <uxCurrentNumberOfTasks>
    133a:	80 91 1c 0a 	lds	r24, 0x0A1C	; 0x800a1c <pxCurrentTCB>
    133e:	90 91 1d 0a 	lds	r25, 0x0A1D	; 0x800a1d <pxCurrentTCB+0x1>
    1342:	89 2b       	or	r24, r25
    1344:	a9 f5       	brne	.+106    	; 0x13b0 <xTaskGenericCreate+0x146>
    1346:	d0 93 1d 0a 	sts	0x0A1D, r29	; 0x800a1d <pxCurrentTCB+0x1>
    134a:	c0 93 1c 0a 	sts	0x0A1C, r28	; 0x800a1c <pxCurrentTCB>
    134e:	80 91 ce 09 	lds	r24, 0x09CE	; 0x8009ce <uxCurrentNumberOfTasks>
    1352:	81 30       	cpi	r24, 0x01	; 1
    1354:	e1 f5       	brne	.+120    	; 0x13ce <xTaskGenericCreate+0x164>
    1356:	88 ef       	ldi	r24, 0xF8	; 248
    1358:	99 e0       	ldi	r25, 0x09	; 9
    135a:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <vListInitialise>
    135e:	81 e0       	ldi	r24, 0x01	; 1
    1360:	9a e0       	ldi	r25, 0x0A	; 10
    1362:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <vListInitialise>
    1366:	8a e0       	ldi	r24, 0x0A	; 10
    1368:	9a e0       	ldi	r25, 0x0A	; 10
    136a:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <vListInitialise>
    136e:	83 e1       	ldi	r24, 0x13	; 19
    1370:	9a e0       	ldi	r25, 0x0A	; 10
    1372:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <vListInitialise>
    1376:	8f ee       	ldi	r24, 0xEF	; 239
    1378:	99 e0       	ldi	r25, 0x09	; 9
    137a:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <vListInitialise>
    137e:	86 ee       	ldi	r24, 0xE6	; 230
    1380:	99 e0       	ldi	r25, 0x09	; 9
    1382:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <vListInitialise>
    1386:	89 ed       	ldi	r24, 0xD9	; 217
    1388:	99 e0       	ldi	r25, 0x09	; 9
    138a:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <vListInitialise>
    138e:	80 ed       	ldi	r24, 0xD0	; 208
    1390:	99 e0       	ldi	r25, 0x09	; 9
    1392:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <vListInitialise>
    1396:	8f ee       	ldi	r24, 0xEF	; 239
    1398:	99 e0       	ldi	r25, 0x09	; 9
    139a:	90 93 e5 09 	sts	0x09E5, r25	; 0x8009e5 <pxDelayedTaskList+0x1>
    139e:	80 93 e4 09 	sts	0x09E4, r24	; 0x8009e4 <pxDelayedTaskList>
    13a2:	86 ee       	ldi	r24, 0xE6	; 230
    13a4:	99 e0       	ldi	r25, 0x09	; 9
    13a6:	90 93 e3 09 	sts	0x09E3, r25	; 0x8009e3 <pxOverflowDelayedTaskList+0x1>
    13aa:	80 93 e2 09 	sts	0x09E2, r24	; 0x8009e2 <pxOverflowDelayedTaskList>
    13ae:	0f c0       	rjmp	.+30     	; 0x13ce <xTaskGenericCreate+0x164>
    13b0:	80 91 c9 09 	lds	r24, 0x09C9	; 0x8009c9 <xSchedulerRunning>
    13b4:	81 11       	cpse	r24, r1
    13b6:	0b c0       	rjmp	.+22     	; 0x13ce <xTaskGenericCreate+0x164>
    13b8:	e0 91 1c 0a 	lds	r30, 0x0A1C	; 0x800a1c <pxCurrentTCB>
    13bc:	f0 91 1d 0a 	lds	r31, 0x0A1D	; 0x800a1d <pxCurrentTCB+0x1>
    13c0:	86 89       	ldd	r24, Z+22	; 0x16
    13c2:	08 17       	cp	r16, r24
    13c4:	20 f0       	brcs	.+8      	; 0x13ce <xTaskGenericCreate+0x164>
    13c6:	d0 93 1d 0a 	sts	0x0A1D, r29	; 0x800a1d <pxCurrentTCB+0x1>
    13ca:	c0 93 1c 0a 	sts	0x0A1C, r28	; 0x800a1c <pxCurrentTCB>
    13ce:	8e 89       	ldd	r24, Y+22	; 0x16
    13d0:	90 91 cb 09 	lds	r25, 0x09CB	; 0x8009cb <uxTopUsedPriority>
    13d4:	98 17       	cp	r25, r24
    13d6:	10 f4       	brcc	.+4      	; 0x13dc <xTaskGenericCreate+0x172>
    13d8:	80 93 cb 09 	sts	0x09CB, r24	; 0x8009cb <uxTopUsedPriority>
    13dc:	90 91 c4 09 	lds	r25, 0x09C4	; 0x8009c4 <uxTaskNumber>
    13e0:	9f 5f       	subi	r25, 0xFF	; 255
    13e2:	90 93 c4 09 	sts	0x09C4, r25	; 0x8009c4 <uxTaskNumber>
    13e6:	90 91 ca 09 	lds	r25, 0x09CA	; 0x8009ca <uxTopReadyPriority>
    13ea:	98 17       	cp	r25, r24
    13ec:	10 f4       	brcc	.+4      	; 0x13f2 <xTaskGenericCreate+0x188>
    13ee:	80 93 ca 09 	sts	0x09CA, r24	; 0x8009ca <uxTopReadyPriority>
    13f2:	90 e0       	ldi	r25, 0x00	; 0
    13f4:	9c 01       	movw	r18, r24
    13f6:	22 0f       	add	r18, r18
    13f8:	33 1f       	adc	r19, r19
    13fa:	22 0f       	add	r18, r18
    13fc:	33 1f       	adc	r19, r19
    13fe:	22 0f       	add	r18, r18
    1400:	33 1f       	adc	r19, r19
    1402:	82 0f       	add	r24, r18
    1404:	93 1f       	adc	r25, r19
    1406:	b6 01       	movw	r22, r12
    1408:	88 50       	subi	r24, 0x08	; 8
    140a:	96 4f       	sbci	r25, 0xF6	; 246
    140c:	0e 94 8e 01 	call	0x31c	; 0x31c <vListInsertEnd>
    1410:	0f 90       	pop	r0
    1412:	0f be       	out	0x3f, r0	; 63
    1414:	80 91 c9 09 	lds	r24, 0x09C9	; 0x8009c9 <xSchedulerRunning>
    1418:	88 23       	and	r24, r24
    141a:	51 f0       	breq	.+20     	; 0x1430 <xTaskGenericCreate+0x1c6>
    141c:	e0 91 1c 0a 	lds	r30, 0x0A1C	; 0x800a1c <pxCurrentTCB>
    1420:	f0 91 1d 0a 	lds	r31, 0x0A1D	; 0x800a1d <pxCurrentTCB+0x1>
    1424:	86 89       	ldd	r24, Z+22	; 0x16
    1426:	80 17       	cp	r24, r16
    1428:	28 f4       	brcc	.+10     	; 0x1434 <xTaskGenericCreate+0x1ca>
    142a:	37 de       	rcall	.-914    	; 0x109a <vPortYield>
    142c:	81 e0       	ldi	r24, 0x01	; 1
    142e:	09 c0       	rjmp	.+18     	; 0x1442 <xTaskGenericCreate+0x1d8>
    1430:	81 e0       	ldi	r24, 0x01	; 1
    1432:	07 c0       	rjmp	.+14     	; 0x1442 <xTaskGenericCreate+0x1d8>
    1434:	81 e0       	ldi	r24, 0x01	; 1
    1436:	05 c0       	rjmp	.+10     	; 0x1442 <xTaskGenericCreate+0x1d8>
    1438:	d8 8e       	std	Y+24, r13	; 0x18
    143a:	cf 8a       	std	Y+23, r12	; 0x17
    143c:	c6 01       	movw	r24, r12
    143e:	3e cf       	rjmp	.-388    	; 0x12bc <xTaskGenericCreate+0x52>
    1440:	8f ef       	ldi	r24, 0xFF	; 255
    1442:	df 91       	pop	r29
    1444:	cf 91       	pop	r28
    1446:	1f 91       	pop	r17
    1448:	0f 91       	pop	r16
    144a:	ff 90       	pop	r15
    144c:	ef 90       	pop	r14
    144e:	df 90       	pop	r13
    1450:	cf 90       	pop	r12
    1452:	bf 90       	pop	r11
    1454:	af 90       	pop	r10
    1456:	9f 90       	pop	r9
    1458:	8f 90       	pop	r8
    145a:	7f 90       	pop	r7
    145c:	6f 90       	pop	r6
    145e:	5f 90       	pop	r5
    1460:	4f 90       	pop	r4
    1462:	08 95       	ret

00001464 <vTaskStartScheduler>:
    1464:	af 92       	push	r10
    1466:	bf 92       	push	r11
    1468:	cf 92       	push	r12
    146a:	df 92       	push	r13
    146c:	ef 92       	push	r14
    146e:	ff 92       	push	r15
    1470:	0f 93       	push	r16
    1472:	a1 2c       	mov	r10, r1
    1474:	b1 2c       	mov	r11, r1
    1476:	c1 2c       	mov	r12, r1
    1478:	d1 2c       	mov	r13, r1
    147a:	e1 2c       	mov	r14, r1
    147c:	f1 2c       	mov	r15, r1
    147e:	00 e0       	ldi	r16, 0x00	; 0
    1480:	20 e0       	ldi	r18, 0x00	; 0
    1482:	30 e0       	ldi	r19, 0x00	; 0
    1484:	45 e5       	ldi	r20, 0x55	; 85
    1486:	50 e0       	ldi	r21, 0x00	; 0
    1488:	68 ed       	ldi	r22, 0xD8	; 216
    148a:	71 e0       	ldi	r23, 0x01	; 1
    148c:	85 ec       	ldi	r24, 0xC5	; 197
    148e:	9b e0       	ldi	r25, 0x0B	; 11
    1490:	ec de       	rcall	.-552    	; 0x126a <xTaskGenericCreate>
    1492:	81 30       	cpi	r24, 0x01	; 1
    1494:	41 f4       	brne	.+16     	; 0x14a6 <vTaskStartScheduler+0x42>
    1496:	f8 94       	cli
    1498:	80 93 c9 09 	sts	0x09C9, r24	; 0x8009c9 <xSchedulerRunning>
    149c:	10 92 cd 09 	sts	0x09CD, r1	; 0x8009cd <xTickCount+0x1>
    14a0:	10 92 cc 09 	sts	0x09CC, r1	; 0x8009cc <xTickCount>
    14a4:	c0 dd       	rcall	.-1152   	; 0x1026 <xPortStartScheduler>
    14a6:	0f 91       	pop	r16
    14a8:	ff 90       	pop	r15
    14aa:	ef 90       	pop	r14
    14ac:	df 90       	pop	r13
    14ae:	cf 90       	pop	r12
    14b0:	bf 90       	pop	r11
    14b2:	af 90       	pop	r10
    14b4:	08 95       	ret

000014b6 <vTaskSuspendAll>:
    14b6:	80 91 c8 09 	lds	r24, 0x09C8	; 0x8009c8 <uxSchedulerSuspended>
    14ba:	8f 5f       	subi	r24, 0xFF	; 255
    14bc:	80 93 c8 09 	sts	0x09C8, r24	; 0x8009c8 <uxSchedulerSuspended>
    14c0:	08 95       	ret

000014c2 <vTaskIncrementTick>:
    14c2:	0f 93       	push	r16
    14c4:	1f 93       	push	r17
    14c6:	cf 93       	push	r28
    14c8:	df 93       	push	r29
    14ca:	80 91 c8 09 	lds	r24, 0x09C8	; 0x8009c8 <uxSchedulerSuspended>
    14ce:	81 11       	cpse	r24, r1
    14d0:	b2 c0       	rjmp	.+356    	; 0x1636 <vTaskIncrementTick+0x174>
    14d2:	80 91 cc 09 	lds	r24, 0x09CC	; 0x8009cc <xTickCount>
    14d6:	90 91 cd 09 	lds	r25, 0x09CD	; 0x8009cd <xTickCount+0x1>
    14da:	01 96       	adiw	r24, 0x01	; 1
    14dc:	90 93 cd 09 	sts	0x09CD, r25	; 0x8009cd <xTickCount+0x1>
    14e0:	80 93 cc 09 	sts	0x09CC, r24	; 0x8009cc <xTickCount>
    14e4:	80 91 cc 09 	lds	r24, 0x09CC	; 0x8009cc <xTickCount>
    14e8:	90 91 cd 09 	lds	r25, 0x09CD	; 0x8009cd <xTickCount+0x1>
    14ec:	89 2b       	or	r24, r25
    14ee:	99 f5       	brne	.+102    	; 0x1556 <vTaskIncrementTick+0x94>
    14f0:	80 91 e4 09 	lds	r24, 0x09E4	; 0x8009e4 <pxDelayedTaskList>
    14f4:	90 91 e5 09 	lds	r25, 0x09E5	; 0x8009e5 <pxDelayedTaskList+0x1>
    14f8:	20 91 e2 09 	lds	r18, 0x09E2	; 0x8009e2 <pxOverflowDelayedTaskList>
    14fc:	30 91 e3 09 	lds	r19, 0x09E3	; 0x8009e3 <pxOverflowDelayedTaskList+0x1>
    1500:	30 93 e5 09 	sts	0x09E5, r19	; 0x8009e5 <pxDelayedTaskList+0x1>
    1504:	20 93 e4 09 	sts	0x09E4, r18	; 0x8009e4 <pxDelayedTaskList>
    1508:	90 93 e3 09 	sts	0x09E3, r25	; 0x8009e3 <pxOverflowDelayedTaskList+0x1>
    150c:	80 93 e2 09 	sts	0x09E2, r24	; 0x8009e2 <pxOverflowDelayedTaskList>
    1510:	80 91 c5 09 	lds	r24, 0x09C5	; 0x8009c5 <xNumOfOverflows>
    1514:	8f 5f       	subi	r24, 0xFF	; 255
    1516:	80 93 c5 09 	sts	0x09C5, r24	; 0x8009c5 <xNumOfOverflows>
    151a:	e0 91 e4 09 	lds	r30, 0x09E4	; 0x8009e4 <pxDelayedTaskList>
    151e:	f0 91 e5 09 	lds	r31, 0x09E5	; 0x8009e5 <pxDelayedTaskList+0x1>
    1522:	80 81       	ld	r24, Z
    1524:	81 11       	cpse	r24, r1
    1526:	07 c0       	rjmp	.+14     	; 0x1536 <vTaskIncrementTick+0x74>
    1528:	8f ef       	ldi	r24, 0xFF	; 255
    152a:	9f ef       	ldi	r25, 0xFF	; 255
    152c:	90 93 6b 01 	sts	0x016B, r25	; 0x80016b <xNextTaskUnblockTime+0x1>
    1530:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <xNextTaskUnblockTime>
    1534:	10 c0       	rjmp	.+32     	; 0x1556 <vTaskIncrementTick+0x94>
    1536:	e0 91 e4 09 	lds	r30, 0x09E4	; 0x8009e4 <pxDelayedTaskList>
    153a:	f0 91 e5 09 	lds	r31, 0x09E5	; 0x8009e5 <pxDelayedTaskList+0x1>
    153e:	05 80       	ldd	r0, Z+5	; 0x05
    1540:	f6 81       	ldd	r31, Z+6	; 0x06
    1542:	e0 2d       	mov	r30, r0
    1544:	06 80       	ldd	r0, Z+6	; 0x06
    1546:	f7 81       	ldd	r31, Z+7	; 0x07
    1548:	e0 2d       	mov	r30, r0
    154a:	82 81       	ldd	r24, Z+2	; 0x02
    154c:	93 81       	ldd	r25, Z+3	; 0x03
    154e:	90 93 6b 01 	sts	0x016B, r25	; 0x80016b <xNextTaskUnblockTime+0x1>
    1552:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <xNextTaskUnblockTime>
    1556:	20 91 cc 09 	lds	r18, 0x09CC	; 0x8009cc <xTickCount>
    155a:	30 91 cd 09 	lds	r19, 0x09CD	; 0x8009cd <xTickCount+0x1>
    155e:	80 91 6a 01 	lds	r24, 0x016A	; 0x80016a <xNextTaskUnblockTime>
    1562:	90 91 6b 01 	lds	r25, 0x016B	; 0x80016b <xNextTaskUnblockTime+0x1>
    1566:	28 17       	cp	r18, r24
    1568:	39 07       	cpc	r19, r25
    156a:	08 f4       	brcc	.+2      	; 0x156e <vTaskIncrementTick+0xac>
    156c:	69 c0       	rjmp	.+210    	; 0x1640 <vTaskIncrementTick+0x17e>
    156e:	e0 91 e4 09 	lds	r30, 0x09E4	; 0x8009e4 <pxDelayedTaskList>
    1572:	f0 91 e5 09 	lds	r31, 0x09E5	; 0x8009e5 <pxDelayedTaskList+0x1>
    1576:	80 81       	ld	r24, Z
    1578:	88 23       	and	r24, r24
    157a:	99 f0       	breq	.+38     	; 0x15a2 <vTaskIncrementTick+0xe0>
    157c:	e0 91 e4 09 	lds	r30, 0x09E4	; 0x8009e4 <pxDelayedTaskList>
    1580:	f0 91 e5 09 	lds	r31, 0x09E5	; 0x8009e5 <pxDelayedTaskList+0x1>
    1584:	05 80       	ldd	r0, Z+5	; 0x05
    1586:	f6 81       	ldd	r31, Z+6	; 0x06
    1588:	e0 2d       	mov	r30, r0
    158a:	c6 81       	ldd	r28, Z+6	; 0x06
    158c:	d7 81       	ldd	r29, Z+7	; 0x07
    158e:	8a 81       	ldd	r24, Y+2	; 0x02
    1590:	9b 81       	ldd	r25, Y+3	; 0x03
    1592:	20 91 cc 09 	lds	r18, 0x09CC	; 0x8009cc <xTickCount>
    1596:	30 91 cd 09 	lds	r19, 0x09CD	; 0x8009cd <xTickCount+0x1>
    159a:	28 17       	cp	r18, r24
    159c:	39 07       	cpc	r19, r25
    159e:	f8 f4       	brcc	.+62     	; 0x15de <vTaskIncrementTick+0x11c>
    15a0:	19 c0       	rjmp	.+50     	; 0x15d4 <vTaskIncrementTick+0x112>
    15a2:	8f ef       	ldi	r24, 0xFF	; 255
    15a4:	9f ef       	ldi	r25, 0xFF	; 255
    15a6:	90 93 6b 01 	sts	0x016B, r25	; 0x80016b <xNextTaskUnblockTime+0x1>
    15aa:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <xNextTaskUnblockTime>
    15ae:	48 c0       	rjmp	.+144    	; 0x1640 <vTaskIncrementTick+0x17e>
    15b0:	e0 91 e4 09 	lds	r30, 0x09E4	; 0x8009e4 <pxDelayedTaskList>
    15b4:	f0 91 e5 09 	lds	r31, 0x09E5	; 0x8009e5 <pxDelayedTaskList+0x1>
    15b8:	05 80       	ldd	r0, Z+5	; 0x05
    15ba:	f6 81       	ldd	r31, Z+6	; 0x06
    15bc:	e0 2d       	mov	r30, r0
    15be:	c6 81       	ldd	r28, Z+6	; 0x06
    15c0:	d7 81       	ldd	r29, Z+7	; 0x07
    15c2:	8a 81       	ldd	r24, Y+2	; 0x02
    15c4:	9b 81       	ldd	r25, Y+3	; 0x03
    15c6:	20 91 cc 09 	lds	r18, 0x09CC	; 0x8009cc <xTickCount>
    15ca:	30 91 cd 09 	lds	r19, 0x09CD	; 0x8009cd <xTickCount+0x1>
    15ce:	28 17       	cp	r18, r24
    15d0:	39 07       	cpc	r19, r25
    15d2:	28 f4       	brcc	.+10     	; 0x15de <vTaskIncrementTick+0x11c>
    15d4:	90 93 6b 01 	sts	0x016B, r25	; 0x80016b <xNextTaskUnblockTime+0x1>
    15d8:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <xNextTaskUnblockTime>
    15dc:	31 c0       	rjmp	.+98     	; 0x1640 <vTaskIncrementTick+0x17e>
    15de:	8e 01       	movw	r16, r28
    15e0:	0e 5f       	subi	r16, 0xFE	; 254
    15e2:	1f 4f       	sbci	r17, 0xFF	; 255
    15e4:	c8 01       	movw	r24, r16
    15e6:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <vListRemove>
    15ea:	8c 89       	ldd	r24, Y+20	; 0x14
    15ec:	9d 89       	ldd	r25, Y+21	; 0x15
    15ee:	89 2b       	or	r24, r25
    15f0:	21 f0       	breq	.+8      	; 0x15fa <vTaskIncrementTick+0x138>
    15f2:	ce 01       	movw	r24, r28
    15f4:	0c 96       	adiw	r24, 0x0c	; 12
    15f6:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <vListRemove>
    15fa:	8e 89       	ldd	r24, Y+22	; 0x16
    15fc:	90 91 ca 09 	lds	r25, 0x09CA	; 0x8009ca <uxTopReadyPriority>
    1600:	98 17       	cp	r25, r24
    1602:	10 f4       	brcc	.+4      	; 0x1608 <vTaskIncrementTick+0x146>
    1604:	80 93 ca 09 	sts	0x09CA, r24	; 0x8009ca <uxTopReadyPriority>
    1608:	90 e0       	ldi	r25, 0x00	; 0
    160a:	9c 01       	movw	r18, r24
    160c:	22 0f       	add	r18, r18
    160e:	33 1f       	adc	r19, r19
    1610:	22 0f       	add	r18, r18
    1612:	33 1f       	adc	r19, r19
    1614:	22 0f       	add	r18, r18
    1616:	33 1f       	adc	r19, r19
    1618:	82 0f       	add	r24, r18
    161a:	93 1f       	adc	r25, r19
    161c:	b8 01       	movw	r22, r16
    161e:	88 50       	subi	r24, 0x08	; 8
    1620:	96 4f       	sbci	r25, 0xF6	; 246
    1622:	0e 94 8e 01 	call	0x31c	; 0x31c <vListInsertEnd>
    1626:	e0 91 e4 09 	lds	r30, 0x09E4	; 0x8009e4 <pxDelayedTaskList>
    162a:	f0 91 e5 09 	lds	r31, 0x09E5	; 0x8009e5 <pxDelayedTaskList+0x1>
    162e:	80 81       	ld	r24, Z
    1630:	81 11       	cpse	r24, r1
    1632:	be cf       	rjmp	.-132    	; 0x15b0 <vTaskIncrementTick+0xee>
    1634:	b6 cf       	rjmp	.-148    	; 0x15a2 <vTaskIncrementTick+0xe0>
    1636:	80 91 c7 09 	lds	r24, 0x09C7	; 0x8009c7 <uxMissedTicks>
    163a:	8f 5f       	subi	r24, 0xFF	; 255
    163c:	80 93 c7 09 	sts	0x09C7, r24	; 0x8009c7 <uxMissedTicks>
    1640:	df 91       	pop	r29
    1642:	cf 91       	pop	r28
    1644:	1f 91       	pop	r17
    1646:	0f 91       	pop	r16
    1648:	08 95       	ret

0000164a <xTaskResumeAll>:
    164a:	cf 92       	push	r12
    164c:	df 92       	push	r13
    164e:	ef 92       	push	r14
    1650:	ff 92       	push	r15
    1652:	0f 93       	push	r16
    1654:	1f 93       	push	r17
    1656:	cf 93       	push	r28
    1658:	df 93       	push	r29
    165a:	0f b6       	in	r0, 0x3f	; 63
    165c:	f8 94       	cli
    165e:	0f 92       	push	r0
    1660:	80 91 c8 09 	lds	r24, 0x09C8	; 0x8009c8 <uxSchedulerSuspended>
    1664:	81 50       	subi	r24, 0x01	; 1
    1666:	80 93 c8 09 	sts	0x09C8, r24	; 0x8009c8 <uxSchedulerSuspended>
    166a:	80 91 c8 09 	lds	r24, 0x09C8	; 0x8009c8 <uxSchedulerSuspended>
    166e:	81 11       	cpse	r24, r1
    1670:	62 c0       	rjmp	.+196    	; 0x1736 <xTaskResumeAll+0xec>
    1672:	80 91 ce 09 	lds	r24, 0x09CE	; 0x8009ce <uxCurrentNumberOfTasks>
    1676:	81 11       	cpse	r24, r1
    1678:	32 c0       	rjmp	.+100    	; 0x16de <xTaskResumeAll+0x94>
    167a:	60 c0       	rjmp	.+192    	; 0x173c <xTaskResumeAll+0xf2>
    167c:	d7 01       	movw	r26, r14
    167e:	15 96       	adiw	r26, 0x05	; 5
    1680:	ed 91       	ld	r30, X+
    1682:	fc 91       	ld	r31, X
    1684:	16 97       	sbiw	r26, 0x06	; 6
    1686:	c6 81       	ldd	r28, Z+6	; 0x06
    1688:	d7 81       	ldd	r29, Z+7	; 0x07
    168a:	ce 01       	movw	r24, r28
    168c:	0c 96       	adiw	r24, 0x0c	; 12
    168e:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <vListRemove>
    1692:	8e 01       	movw	r16, r28
    1694:	0e 5f       	subi	r16, 0xFE	; 254
    1696:	1f 4f       	sbci	r17, 0xFF	; 255
    1698:	c8 01       	movw	r24, r16
    169a:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <vListRemove>
    169e:	8e 89       	ldd	r24, Y+22	; 0x16
    16a0:	90 91 ca 09 	lds	r25, 0x09CA	; 0x8009ca <uxTopReadyPriority>
    16a4:	98 17       	cp	r25, r24
    16a6:	10 f4       	brcc	.+4      	; 0x16ac <xTaskResumeAll+0x62>
    16a8:	80 93 ca 09 	sts	0x09CA, r24	; 0x8009ca <uxTopReadyPriority>
    16ac:	90 e0       	ldi	r25, 0x00	; 0
    16ae:	9c 01       	movw	r18, r24
    16b0:	22 0f       	add	r18, r18
    16b2:	33 1f       	adc	r19, r19
    16b4:	22 0f       	add	r18, r18
    16b6:	33 1f       	adc	r19, r19
    16b8:	22 0f       	add	r18, r18
    16ba:	33 1f       	adc	r19, r19
    16bc:	82 0f       	add	r24, r18
    16be:	93 1f       	adc	r25, r19
    16c0:	b8 01       	movw	r22, r16
    16c2:	88 50       	subi	r24, 0x08	; 8
    16c4:	96 4f       	sbci	r25, 0xF6	; 246
    16c6:	0e 94 8e 01 	call	0x31c	; 0x31c <vListInsertEnd>
    16ca:	e0 91 1c 0a 	lds	r30, 0x0A1C	; 0x800a1c <pxCurrentTCB>
    16ce:	f0 91 1d 0a 	lds	r31, 0x0A1D	; 0x800a1d <pxCurrentTCB+0x1>
    16d2:	9e 89       	ldd	r25, Y+22	; 0x16
    16d4:	86 89       	ldd	r24, Z+22	; 0x16
    16d6:	98 17       	cp	r25, r24
    16d8:	58 f0       	brcs	.+22     	; 0x16f0 <xTaskResumeAll+0xa6>
    16da:	dc 2c       	mov	r13, r12
    16dc:	09 c0       	rjmp	.+18     	; 0x16f0 <xTaskResumeAll+0xa6>
    16de:	d1 2c       	mov	r13, r1
    16e0:	0f 2e       	mov	r0, r31
    16e2:	f9 ed       	ldi	r31, 0xD9	; 217
    16e4:	ef 2e       	mov	r14, r31
    16e6:	f9 e0       	ldi	r31, 0x09	; 9
    16e8:	ff 2e       	mov	r15, r31
    16ea:	f0 2d       	mov	r31, r0
    16ec:	cc 24       	eor	r12, r12
    16ee:	c3 94       	inc	r12
    16f0:	f7 01       	movw	r30, r14
    16f2:	80 81       	ld	r24, Z
    16f4:	81 11       	cpse	r24, r1
    16f6:	c2 cf       	rjmp	.-124    	; 0x167c <xTaskResumeAll+0x32>
    16f8:	80 91 c7 09 	lds	r24, 0x09C7	; 0x8009c7 <uxMissedTicks>
    16fc:	88 23       	and	r24, r24
    16fe:	79 f0       	breq	.+30     	; 0x171e <xTaskResumeAll+0xd4>
    1700:	80 91 c7 09 	lds	r24, 0x09C7	; 0x8009c7 <uxMissedTicks>
    1704:	88 23       	and	r24, r24
    1706:	91 f0       	breq	.+36     	; 0x172c <xTaskResumeAll+0xe2>
    1708:	dc de       	rcall	.-584    	; 0x14c2 <vTaskIncrementTick>
    170a:	80 91 c7 09 	lds	r24, 0x09C7	; 0x8009c7 <uxMissedTicks>
    170e:	81 50       	subi	r24, 0x01	; 1
    1710:	80 93 c7 09 	sts	0x09C7, r24	; 0x8009c7 <uxMissedTicks>
    1714:	80 91 c7 09 	lds	r24, 0x09C7	; 0x8009c7 <uxMissedTicks>
    1718:	81 11       	cpse	r24, r1
    171a:	f6 cf       	rjmp	.-20     	; 0x1708 <xTaskResumeAll+0xbe>
    171c:	07 c0       	rjmp	.+14     	; 0x172c <xTaskResumeAll+0xe2>
    171e:	f1 e0       	ldi	r31, 0x01	; 1
    1720:	df 16       	cp	r13, r31
    1722:	21 f0       	breq	.+8      	; 0x172c <xTaskResumeAll+0xe2>
    1724:	80 91 c6 09 	lds	r24, 0x09C6	; 0x8009c6 <xMissedYield>
    1728:	81 30       	cpi	r24, 0x01	; 1
    172a:	39 f4       	brne	.+14     	; 0x173a <xTaskResumeAll+0xf0>
    172c:	10 92 c6 09 	sts	0x09C6, r1	; 0x8009c6 <xMissedYield>
    1730:	b4 dc       	rcall	.-1688   	; 0x109a <vPortYield>
    1732:	81 e0       	ldi	r24, 0x01	; 1
    1734:	03 c0       	rjmp	.+6      	; 0x173c <xTaskResumeAll+0xf2>
    1736:	80 e0       	ldi	r24, 0x00	; 0
    1738:	01 c0       	rjmp	.+2      	; 0x173c <xTaskResumeAll+0xf2>
    173a:	80 e0       	ldi	r24, 0x00	; 0
    173c:	0f 90       	pop	r0
    173e:	0f be       	out	0x3f, r0	; 63
    1740:	df 91       	pop	r29
    1742:	cf 91       	pop	r28
    1744:	1f 91       	pop	r17
    1746:	0f 91       	pop	r16
    1748:	ff 90       	pop	r15
    174a:	ef 90       	pop	r14
    174c:	df 90       	pop	r13
    174e:	cf 90       	pop	r12
    1750:	08 95       	ret

00001752 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1752:	cf 93       	push	r28
    1754:	df 93       	push	r29
    1756:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1758:	89 2b       	or	r24, r25
    175a:	99 f0       	breq	.+38     	; 0x1782 <vTaskDelay+0x30>
		{
			vTaskSuspendAll();
    175c:	ac de       	rcall	.-680    	; 0x14b6 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    175e:	80 91 cc 09 	lds	r24, 0x09CC	; 0x8009cc <xTickCount>
    1762:	90 91 cd 09 	lds	r25, 0x09CD	; 0x8009cd <xTickCount+0x1>
    1766:	c8 0f       	add	r28, r24
    1768:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    176a:	80 91 1c 0a 	lds	r24, 0x0A1C	; 0x800a1c <pxCurrentTCB>
    176e:	90 91 1d 0a 	lds	r25, 0x0A1D	; 0x800a1d <pxCurrentTCB+0x1>
    1772:	02 96       	adiw	r24, 0x02	; 2
    1774:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1778:	ce 01       	movw	r24, r28
			}
			xAlreadyYielded = xTaskResumeAll();
    177a:	42 dd       	rcall	.-1404   	; 0x1200 <prvAddCurrentTaskToDelayedList>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    177c:	66 df       	rcall	.-308    	; 0x164a <xTaskResumeAll>
    177e:	81 11       	cpse	r24, r1
		{
			portYIELD_WITHIN_API();
    1780:	01 c0       	rjmp	.+2      	; 0x1784 <vTaskDelay+0x32>
    1782:	8b dc       	rcall	.-1770   	; 0x109a <vPortYield>
		}
	}
    1784:	df 91       	pop	r29
    1786:	cf 91       	pop	r28
    1788:	08 95       	ret

0000178a <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    178a:	0f 2e       	mov	r0, r31
    178c:	f0 ed       	ldi	r31, 0xD0	; 208
    178e:	ef 2e       	mov	r14, r31
    1790:	f9 e0       	ldi	r31, 0x09	; 9
    1792:	ff 2e       	mov	r15, r31
    1794:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1796:	c8 ef       	ldi	r28, 0xF8	; 248
    1798:	d9 e0       	ldi	r29, 0x09	; 9
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    179a:	80 91 cf 09 	lds	r24, 0x09CF	; 0x8009cf <uxTasksDeleted>
    179e:	88 23       	and	r24, r24
    17a0:	41 f1       	breq	.+80     	; 0x17f2 <prvIdleTask+0x68>
		{
			vTaskSuspendAll();
    17a2:	89 de       	rcall	.-750    	; 0x14b6 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    17a4:	d7 01       	movw	r26, r14
			xTaskResumeAll();
    17a6:	1c 91       	ld	r17, X
    17a8:	50 df       	rcall	.-352    	; 0x164a <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    17aa:	11 23       	and	r17, r17
    17ac:	11 f1       	breq	.+68     	; 0x17f2 <prvIdleTask+0x68>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    17ae:	0f b6       	in	r0, 0x3f	; 63
    17b0:	f8 94       	cli
    17b2:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    17b4:	d7 01       	movw	r26, r14
    17b6:	15 96       	adiw	r26, 0x05	; 5
    17b8:	ed 91       	ld	r30, X+
    17ba:	fc 91       	ld	r31, X
    17bc:	16 97       	sbiw	r26, 0x06	; 6
    17be:	06 81       	ldd	r16, Z+6	; 0x06
    17c0:	17 81       	ldd	r17, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    17c2:	c8 01       	movw	r24, r16
    17c4:	02 96       	adiw	r24, 0x02	; 2
    17c6:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <vListRemove>
					--uxCurrentNumberOfTasks;
    17ca:	80 91 ce 09 	lds	r24, 0x09CE	; 0x8009ce <uxCurrentNumberOfTasks>
    17ce:	81 50       	subi	r24, 0x01	; 1
    17d0:	80 93 ce 09 	sts	0x09CE, r24	; 0x8009ce <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    17d4:	80 91 cf 09 	lds	r24, 0x09CF	; 0x8009cf <uxTasksDeleted>
    17d8:	81 50       	subi	r24, 0x01	; 1
    17da:	80 93 cf 09 	sts	0x09CF, r24	; 0x8009cf <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    17de:	0f 90       	pop	r0
    17e0:	0f be       	out	0x3f, r0	; 63
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    17e2:	f8 01       	movw	r30, r16
    17e4:	87 89       	ldd	r24, Z+23	; 0x17
    17e6:	90 8d       	ldd	r25, Z+24	; 0x18
    17e8:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <vPortFree>
		vPortFree( pxTCB );
    17ec:	c8 01       	movw	r24, r16
    17ee:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    17f2:	88 81       	ld	r24, Y
    17f4:	82 30       	cpi	r24, 0x02	; 2
			{
				taskYIELD();
    17f6:	88 f2       	brcs	.-94     	; 0x179a <prvIdleTask+0x10>
    17f8:	50 dc       	rcall	.-1888   	; 0x109a <vPortYield>
    17fa:	cf cf       	rjmp	.-98     	; 0x179a <prvIdleTask+0x10>

000017fc <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    17fc:	80 91 c8 09 	lds	r24, 0x09C8	; 0x8009c8 <uxSchedulerSuspended>
    1800:	81 11       	cpse	r24, r1
    1802:	13 c0       	rjmp	.+38     	; 0x182a <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1804:	80 91 ca 09 	lds	r24, 0x09CA	; 0x8009ca <uxTopReadyPriority>
    1808:	90 e0       	ldi	r25, 0x00	; 0
    180a:	fc 01       	movw	r30, r24
    180c:	ee 0f       	add	r30, r30
    180e:	ff 1f       	adc	r31, r31
    1810:	ee 0f       	add	r30, r30
    1812:	ff 1f       	adc	r31, r31
    1814:	ee 0f       	add	r30, r30
    1816:	ff 1f       	adc	r31, r31
    1818:	8e 0f       	add	r24, r30
    181a:	9f 1f       	adc	r25, r31
    181c:	fc 01       	movw	r30, r24
    181e:	e8 50       	subi	r30, 0x08	; 8
    1820:	f6 4f       	sbci	r31, 0xF6	; 246
    1822:	80 81       	ld	r24, Z
    1824:	88 23       	and	r24, r24
    1826:	29 f0       	breq	.+10     	; 0x1832 <vTaskSwitchContext+0x36>
    1828:	1b c0       	rjmp	.+54     	; 0x1860 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    182a:	81 e0       	ldi	r24, 0x01	; 1
    182c:	80 93 c6 09 	sts	0x09C6, r24	; 0x8009c6 <xMissedYield>
    1830:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1832:	80 91 ca 09 	lds	r24, 0x09CA	; 0x8009ca <uxTopReadyPriority>
    1836:	81 50       	subi	r24, 0x01	; 1
    1838:	80 93 ca 09 	sts	0x09CA, r24	; 0x8009ca <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    183c:	80 91 ca 09 	lds	r24, 0x09CA	; 0x8009ca <uxTopReadyPriority>
    1840:	90 e0       	ldi	r25, 0x00	; 0
    1842:	fc 01       	movw	r30, r24
    1844:	ee 0f       	add	r30, r30
    1846:	ff 1f       	adc	r31, r31
    1848:	ee 0f       	add	r30, r30
    184a:	ff 1f       	adc	r31, r31
    184c:	ee 0f       	add	r30, r30
    184e:	ff 1f       	adc	r31, r31
    1850:	8e 0f       	add	r24, r30
    1852:	9f 1f       	adc	r25, r31
    1854:	fc 01       	movw	r30, r24
    1856:	e8 50       	subi	r30, 0x08	; 8
    1858:	f6 4f       	sbci	r31, 0xF6	; 246
    185a:	80 81       	ld	r24, Z
    185c:	88 23       	and	r24, r24
    185e:	49 f3       	breq	.-46     	; 0x1832 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1860:	80 91 ca 09 	lds	r24, 0x09CA	; 0x8009ca <uxTopReadyPriority>
    1864:	90 e0       	ldi	r25, 0x00	; 0
    1866:	9c 01       	movw	r18, r24
    1868:	22 0f       	add	r18, r18
    186a:	33 1f       	adc	r19, r19
    186c:	22 0f       	add	r18, r18
    186e:	33 1f       	adc	r19, r19
    1870:	22 0f       	add	r18, r18
    1872:	33 1f       	adc	r19, r19
    1874:	28 0f       	add	r18, r24
    1876:	39 1f       	adc	r19, r25
    1878:	d9 01       	movw	r26, r18
    187a:	a8 50       	subi	r26, 0x08	; 8
    187c:	b6 4f       	sbci	r27, 0xF6	; 246
    187e:	11 96       	adiw	r26, 0x01	; 1
    1880:	ed 91       	ld	r30, X+
    1882:	fc 91       	ld	r31, X
    1884:	12 97       	sbiw	r26, 0x02	; 2
    1886:	02 80       	ldd	r0, Z+2	; 0x02
    1888:	f3 81       	ldd	r31, Z+3	; 0x03
    188a:	e0 2d       	mov	r30, r0
    188c:	12 96       	adiw	r26, 0x02	; 2
    188e:	fc 93       	st	X, r31
    1890:	ee 93       	st	-X, r30
    1892:	11 97       	sbiw	r26, 0x01	; 1
    1894:	25 50       	subi	r18, 0x05	; 5
    1896:	36 4f       	sbci	r19, 0xF6	; 246
    1898:	e2 17       	cp	r30, r18
    189a:	f3 07       	cpc	r31, r19
    189c:	29 f4       	brne	.+10     	; 0x18a8 <vTaskSwitchContext+0xac>
    189e:	22 81       	ldd	r18, Z+2	; 0x02
    18a0:	33 81       	ldd	r19, Z+3	; 0x03
    18a2:	fd 01       	movw	r30, r26
    18a4:	32 83       	std	Z+2, r19	; 0x02
    18a6:	21 83       	std	Z+1, r18	; 0x01
    18a8:	fc 01       	movw	r30, r24
    18aa:	ee 0f       	add	r30, r30
    18ac:	ff 1f       	adc	r31, r31
    18ae:	ee 0f       	add	r30, r30
    18b0:	ff 1f       	adc	r31, r31
    18b2:	ee 0f       	add	r30, r30
    18b4:	ff 1f       	adc	r31, r31
    18b6:	8e 0f       	add	r24, r30
    18b8:	9f 1f       	adc	r25, r31
    18ba:	fc 01       	movw	r30, r24
    18bc:	e8 50       	subi	r30, 0x08	; 8
    18be:	f6 4f       	sbci	r31, 0xF6	; 246
    18c0:	01 80       	ldd	r0, Z+1	; 0x01
    18c2:	f2 81       	ldd	r31, Z+2	; 0x02
    18c4:	e0 2d       	mov	r30, r0
    18c6:	86 81       	ldd	r24, Z+6	; 0x06
    18c8:	97 81       	ldd	r25, Z+7	; 0x07
    18ca:	90 93 1d 0a 	sts	0x0A1D, r25	; 0x800a1d <pxCurrentTCB+0x1>
    18ce:	80 93 1c 0a 	sts	0x0A1C, r24	; 0x800a1c <pxCurrentTCB>
    18d2:	08 95       	ret

000018d4 <__udivmodqi4>:
    18d4:	99 1b       	sub	r25, r25
    18d6:	79 e0       	ldi	r23, 0x09	; 9
    18d8:	04 c0       	rjmp	.+8      	; 0x18e2 <__udivmodqi4_ep>

000018da <__udivmodqi4_loop>:
    18da:	99 1f       	adc	r25, r25
    18dc:	96 17       	cp	r25, r22
    18de:	08 f0       	brcs	.+2      	; 0x18e2 <__udivmodqi4_ep>
    18e0:	96 1b       	sub	r25, r22

000018e2 <__udivmodqi4_ep>:
    18e2:	88 1f       	adc	r24, r24
    18e4:	7a 95       	dec	r23
    18e6:	c9 f7       	brne	.-14     	; 0x18da <__udivmodqi4_loop>
    18e8:	80 95       	com	r24
    18ea:	08 95       	ret

000018ec <memset>:
    18ec:	dc 01       	movw	r26, r24
    18ee:	01 c0       	rjmp	.+2      	; 0x18f2 <memset+0x6>
    18f0:	6d 93       	st	X+, r22
    18f2:	41 50       	subi	r20, 0x01	; 1
    18f4:	50 40       	sbci	r21, 0x00	; 0
    18f6:	e0 f7       	brcc	.-8      	; 0x18f0 <memset+0x4>
    18f8:	08 95       	ret

000018fa <strncpy>:
    18fa:	fb 01       	movw	r30, r22
    18fc:	dc 01       	movw	r26, r24
    18fe:	41 50       	subi	r20, 0x01	; 1
    1900:	50 40       	sbci	r21, 0x00	; 0
    1902:	48 f0       	brcs	.+18     	; 0x1916 <strncpy+0x1c>
    1904:	01 90       	ld	r0, Z+
    1906:	0d 92       	st	X+, r0
    1908:	00 20       	and	r0, r0
    190a:	c9 f7       	brne	.-14     	; 0x18fe <strncpy+0x4>
    190c:	01 c0       	rjmp	.+2      	; 0x1910 <strncpy+0x16>
    190e:	1d 92       	st	X+, r1
    1910:	41 50       	subi	r20, 0x01	; 1
    1912:	50 40       	sbci	r21, 0x00	; 0
    1914:	e0 f7       	brcc	.-8      	; 0x190e <strncpy+0x14>
    1916:	08 95       	ret

00001918 <_exit>:
    1918:	f8 94       	cli

0000191a <__stop_program>:
    191a:	ff cf       	rjmp	.-2      	; 0x191a <__stop_program>
